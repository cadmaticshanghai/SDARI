/* $Id: PipeSketchGenerator.mac,v1.0.0 2015/04/18 Wallis.liu $ */

/*
**	这个程序用于生成及管理管子小票图形
*/

#include "include/dmutil.h"
#include "include/win.h"
#include "include/win_panel.h"
#include "include/PmMgeTags.h"
#include "include/pm.h"
#include "include/pm_errors.h"
#include "include/dm_errors.h"
#include "include/pm_drawings.h"
#include "include/pm_core_tags.h"
#include "include/array.mac"
#include "include/cos.h"
#include "include/dw.h"
#include "include/pm_annot.h"
#include "include/dm_cos_schema.h"
#include "include/geoutils.h"
#include "include/PmPipingUtils.h"
#include "opt/pm/EloTools/include/viewutilsELO.h"
#include "include/g2d_ext2df.h"
#include "include/quants.h"
#include "include/pi_math.mac"
#include "include/pi.h"

#include "$MarineToolkit/Piping/PspoolProdInfo.h"
#include "$MarineToolkit/Piping/PipeSketchGenerator.h"
#include "$MarineToolkit/Include/Common_Utility.h"  
#include "$MarineToolkit/Include/String_Utility.h"
#include "$MarineToolkit/Include/Drawing_Utility.h"
#include "$MarineToolkit/Include/Grid_Utility.h"


/*
**脚本语言中似乎无法直接获得一个数组的实际长度，定义一个全局变量用于保存管段信息的数量
**It seem that there isn't method to get the size of a array, define a global var to store the number of pipe spool information
*/
global handle  Block_Name, System_Name, Planning_Unit;
global handle  DisplayGrid;
global handle  NULL_HANDLE = 0;
global int     Grid_SelectedItem = 0;
global int     Grid_SortColumn = -1;
global int     Grid_SortDirection = 1;
global handle  Object_List;                                     /*管段handle列表*/
global handle  Sketch_Tag_Array, Column_Description_Array;
global handle  Object_Info;                                     /*管段信息列表*/
global int     Object_Number = 0;                               /*管段数量*/
global int     Model_Add_Mode = 0;                              /*查找模式0 - 替换，1 - 追加*/
global handle  High_Light_List;                                 /*模型加亮列表*/
global handle  Selected_Objects;
global int     Selected_Objects_Number = 0;
global int     AutoScale = 0;
global int     AutoHighLight = 1;
global handle  MainWindow;
global int     Maximum_Object_Number = 1000;

global handle  Process, Cur_Sketch;
global string  Cur_Spool_Name = "",Cur_Sketch_Name = "";
global handle  Drawing_Form, Select_Form;
global string  Drawing_Form_Name = "";
global handle  Sketch,Sketch_View_Top,Sketch_View_AFT,Sketch_View_SB,Sketch_View_ISO;
global handle  Double_Plate_Set;
global int     Have_Double_Plate = 0;
global handle  Open_Next,Open_Previous;
global string  Proj_Description = "";
global string  Proj_Number = "";
global float   Bending_Radius = 0.0;

global string Icon_My_Check_Out = "$MarineToolkit/ICONS/mycheckout.ico";
global string Icon_Other_Check_Out = "$MarineToolkit/ICONS/checkout.ico";
global string Icon_Local_Server = "$MarineToolkit/ICONS/local_server.ico";
global string Icon_Replica_Check_Out = "$MarineToolkit/ICONS/replica_checkout.ico";
global string Icon_Replica_Server = "$MarineToolkit/ICONS/replica.ico";
global string Icon_Error = "$MarineToolkit/ICONS/error.ico";
global handle Access_List;

/*
**初始化相关对象
*/
init()
{
	Sketch_Tag_Array = A_ALLOC(Column_Number, "STRING");
	A_PUT(Sketch_Tag_Array,0,Tag_Spool_Name);
	A_PUT(Sketch_Tag_Array,1,SketchStatus);
	A_PUT(Sketch_Tag_Array,2,Tag_Sketch_Name);
	A_PUT(Sketch_Tag_Array,3,CreationTime);

	Column_Description_Array = A_ALLOC(Column_Number, "STRING");
	A_PUT(Column_Description_Array,0,"管段名称");
	A_PUT(Column_Description_Array,1,"工艺状态");
	A_PUT(Column_Description_Array,2,"小票名称");
	A_PUT(Column_Description_Array,3,"生成日期");

	Object_Info = alloc_2darray(1,1);
	Spool_Branch = alloc_2darray(1,1);
	Spool_Branch_Direction = alloc_2darray(1,1);

	View_Info = alloc_2darray(1,1);
	View_Positions = alloc_2darray(1,1);
	Bending_Table_Head = alloc_2darray(1,1);

    View_Handles = A_ALLOC(1);
    View_Names = A_ALLOC(1);
    Bending_Action_Number = A_ALLOC(1);

	View_Positions = alloc_2darray(4,2);
	put_2darray(View_Positions,0,0,View1_X);
	put_2darray(View_Positions,0,1,View1_Y);
	put_2darray(View_Positions,1,0,View2_X);
	put_2darray(View_Positions,1,1,View2_Y);
	put_2darray(View_Positions,2,0,View3_X);
	put_2darray(View_Positions,2,1,View3_Y);
	put_2darray(View_Positions,3,0,View4_X);
	put_2darray(View_Positions,3,1,View4_Y);

	Mto_Table = alloc_2darray(1,1);
	Mto_Label_Table = alloc_2darray(1,1);
	Label_Table = alloc_2darray(1,1);
	Cur_Spool_Model_Set = PM_INIT_SET();
	Check_Node_Table = alloc_2darray(1,1);
	Connection_Label_Table = alloc_2darray(1,1);
	Connection_Table = alloc_2darray(1,1);
	Dim_Table = alloc_2darray(1,1);
	Spool_Parts = alloc_2darray(1,1);
	Bending_Actions = alloc_2darray(1,1);
	Assembly_Table = alloc_2darray(1,1);
	Assembly_Label_Table = alloc_2darray(1,1);
	
	Access_List = A_ALLOC(1);

	Double_Plate_Set = PM_INIT_SET();
	
	Proj_Description = Get_Project_Attribute(Tag_Project_Description);
	Proj_Number = Get_Project_Attribute(Tag_Project_Number);
}

set_default()
{
	/*初始化模型集合*/
	Object_List = PM_INIT_SET();

	/*初始化加亮模型集合*/
	High_Light_List = PM_INIT_SET();

	/*初始化选中的模型集合*/
	Selected_Objects = PM_INIT_SET();

	drawing_form = "";

	st = GET_STRING_DEFAULT("PipeSketchGenerator", "Drawing_Form", drawing_form);
	if(st == 0){
		W_SET_PANELITEM_ARGS(Drawing_Form, W_PANEL_VALUE, drawing_form);
		Drawing_Form_Name = drawing_form;
	}
}

/*
**Get the selected objects in grid
*/
get_selected_items(handle wobj)
{
	PM_SETOP_SUB(Selected_Objects, Selected_Objects);
	selected_rows = W_GET_WINDOW_ARG( wobj, W_LISTW_MSVALUE );
	total_lines = STRLEN(selected_rows);
	k = 0;
	for (i = 0; i < total_lines; i = i + 1){
		temp_string = SUBSTRING(selected_rows,i);
		flag = HEAD(temp_string,1);
		if (flag == "1"){
			res = W_SET_WINDOW_ARGS( wobj, W_LISTW_ROW, i);
			selected_row = W_GET_WINDOW_ARG( wobj, W_LISTW_ITEMID );
			model_handle = PM_GET_MEMBER_IN_SET(Object_List, selected_row);
			PM_ADD_OBJECT_TO_SET(model_handle,Selected_Objects);
			k = k + 1;
		}
	}
	Selected_Objects_Number = k;
	return (0);
}

model_list_mode(item, event_type, selection)
{
	if (selection == 0){
		Model_Add_Mode = 0;
	}
	else{
		Model_Add_Mode = 1;
	}
	return(0);
}

/*
**获取全局变量Object_List中保存的模型的生产信息，并将生产信息保存到全局变量ProdInfo中；
*/
get_spool_info()
{
	/* 给保存管段信息的全局数组分配存储空间 */
	A_FREE(Object_Info);
	Object_Info = alloc_2darray(Object_Number,Column_Number);
	A_FREE(Access_List);
	Access_List = A_ALLOC(Object_Number);
	/* 获取管段的信息并保存到全局数组 */
	for (i = 0; i < Object_Number; i = i + 1;){
		object_handle = PM_GET_MEMBER_IN_SET(Object_List, i);
		/*获取管段名称*/
		spool_name = Get_SpoolName(object_handle);
		put_2darray(Object_Info,i,0,spool_name);
		/*获取管段工艺状态*/
		sketch_status = Get_Attribute_Value(object_handle, SketchStatus);
		if(sketch_status != -1){
		   put_2darray(Object_Info,i,1,sketch_status);
		}
		else{
		   put_2darray(Object_Info,i,1,"未检查");
		}
		/*获取小票名称及生成日期*/
		sketch_name = Get_Attribute_Value(object_handle, Tag_Sketch_Name);
		if(!ISINT(sketch_name)){
		   put_2darray(Object_Info,i,2,sketch_name);
		   date_string = Get_Creation_Date(sketch_name);
		   if(!ISINT(date_string)){
		      put_2darray(Object_Info,i,3,date_string);
		   }
		   else{
		      put_2darray(Object_Info,i,3,"0000-00-00");
		   }
		}
		else{
		   put_2darray(Object_Info,i,2,"未生成");
		   put_2darray(Object_Info,i,3,"0000-00-00");
		}
		access = Get_Object_Access_Status(object_handle);
		A_PUT(Access_List,i,access);
	}
	return 0;
}

/*
**将全局变量object_info中保存的生产信息显示到列表中；
**根据全局变量Grid_SortColumn，Grid_SortDirection保存的信息对显示列表进行排序；
*/
publish_model_info()
{
	/* 将管段信息显示到窗口中 */
	W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_ROW, 0);
	W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_DELETEROWS, -1);
	for (i = 0; i < Object_Number; i = i + 1;){
		W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_ROW, 0);
		W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_INSERTROWS, 1);
		/*set access status flag of group*/
		flag = A_GET(Access_List,i);
		icon = Icon_My_Check_Out;
		if(flag == "Local"){
		   icon = Icon_Local_Server;
		}
		else if(flag == "CheckOutByMe"){
		   icon = Icon_My_Check_Out;
		}
		else if(flag == "CheckOutByOther"){
		   icon = Icon_Other_Check_Out;
		}
		else if(flag == "Replica"){
		   icon = Icon_Replica_Server;
		}
		else if(flag == "CheckOutByReplicaUser"){
		   icon = Icon_Replica_Check_Out;
		}
		else{
		   icon = Icon_Error;
		}
		W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_ROW, 0, W_LISTW_COLUMN, 0, W_LISTW_ICON, icon );
		for ( j = 0; j < Column_Number; j = j + 1;){
			Value = get_2darray(Object_Info,i,j);
			if (ISSTRING(Value)){
				W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_ROW, 0, W_LISTW_COLUMN, j, W_LISTW_STRING, Value);
			}
		}
		W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_ITEMID, i);
	}

	W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_ROW, 1);

	/* 自动调整列宽度 Adjust the width of column automatically*/
	for (i=0; i < Column_Number; i = i + 1;){
		W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_COLUMN, i, W_LISTW_COLUMNWIDTH, -1);
	}

	/* 对生产信息列表进行排序 */
	W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_COLUMN, Grid_SortColumn, W_LISTW_SORT, Grid_SortDirection);
}
/*
**创建顶层窗体
**Create Top frame
*/
create_top_frame()
{
	mainform = W_INIT_FRAME();
	W_REALIZE_WINDOW(mainform,  W_FRAME_TITLE, "管段小票生成工具" );
	return(mainform);
}

/*
**创建显示管段信息的格栅
*/
create_grid(main_form)
{
	wobj = W_ADD_WINDOW(main_form, W_MULTISELECT, "DisplayGrid");

	W_REALIZE_WINDOW(wobj,  W_FRAME_RIGHT_OF,    "Block_Name",
						         W_FRAME_BELOW,       "panel_upperpart",
						         W_LISTW_COLUMNS,     Column_Number,
						         W_FRAME_SCROLLBAR,   W_SCROLLBAR_RIGHTEDGE,
						         W_LISTW_HEADER_MODE, W_LISTW_HEADER_BUTTONS,
						         W_LISTW_MODE_REPORT, 0,
						         W_FRAME_COLS,        60,
						         W_FRAME_ROWS,        15,
						         W_LISTW_CALLBACK,    1);

	W_SET_WINDOW_HANDLER(wobj, "grid_handler");

	/*
	**设置格栅的列标题
	**set the column title of grid
	*/
	Set_Column_Title(wobj, Column_Description_Array, Column_Number);

	return(wobj);
}


quit_handler(item, event_type, button_value)
{
	exit();
	U_MESSAGE("退出管段小票生成工具");
	return(99);
}


grid_handler(window, event_type, row, column, item_id)
{
	if (event_type == W_EVENT_ITEM_SELECTED) {
		/* 处理格栅的排序 */
		if (row < 0 & column >= 0) {
			sort_grid(column,window);
		}
		else if(row >= 0 & column == 0){
			/* 获取选中的模型 */
			get_selected_items(DisplayGrid);
			auto_highlight();
			auto_scale_model();
		}
	}
	/* 处理双击数据行的事件 */
	else if (event_type == W_EVENT_ITEM_DOUBLECLICKED) {
		/* 获取选中的模型 */
		get_selected_items(DisplayGrid);
		auto_highlight();
		auto_scale_model();
	}
	return(0);
}

auto_highlight()
{
	/* 处理模型加亮 */
	if (AutoHighLight == 1){
		/* 将已经加亮的模型恢复原来的颜色 */
		model_number = PM_NR_MEMBERS_IN_SET(High_Light_List);
		for (i = 0 ; i < model_number; i = i + 1){
			model = PM_GET_MEMBER_IN_SET(High_Light_List,i);
			Highlight_Object(model,FALSE);
		}
		temp = PM_INIT_SET();
		High_Light_List = PM_COPY_SET(temp);
		PM_FREE_SET(temp);

		/* 加亮选中的模型 */
		model_number = PM_NR_MEMBERS_IN_SET(Selected_Objects);
		for (i = 0; i < model_number; i = i + 1){
			model = PM_GET_MEMBER_IN_SET(Selected_Objects,i);
			Highlight_Object(model,TRUE);
			PM_ADD_OBJECT_TO_SET(model,High_Light_List);
		}
	}
}

auto_scale_model()
{
	/* 处理模型自动缩放 */
	if (AutoScale == 1){
		model_number = PM_NR_MEMBERS_IN_SET(Selected_Objects);
		if (model_number == 1){
			model_handle = PM_GET_MEMBER_IN_SET(Selected_Objects,0);
			Auto_Scale(model_handle);
		}
	}
}

sort_grid(column,window)
{
	/* A column header was clicked; sort the items */
	if (Grid_SortColumn == column) {
		if (Grid_SortDirection == 0) {
			Grid_SortDirection = 1;
		}
		else {
			Grid_SortDirection = 0;
		}
	}
	else {
		Grid_SortDirection = 1;
	}
	Grid_SortColumn = column;
	W_SET_WINDOW_ARGS(window, W_LISTW_COLUMN, column, W_LISTW_SORT, Grid_SortDirection);
}

model_browsing_handler(item, event_type, button_value)
{
	W_UNMAP_FRAME(MainWindow);
	selected_model_number = PM_NR_MEMBERS_IN_SET(High_Light_List);
	if (selected_model_number > 0){
		current_model = PM_GET_MEMBER_IN_SET(High_Light_List, 0);
		parts = PM_GET_OBJECTS_IN_GROUP(current_model);
		part = PM_GET_MEMBER_IN_SET( parts, 0);
		x0 = PM_GET_OBJDATA(part, 0, MMT_TAG_COGX);
		y0 = PM_GET_OBJDATA(part, 0, MMT_TAG_COGY);
		z0 = PM_GET_OBJDATA(part, 0, MMT_TAG_COGZ);
		x = SCAN_QUANT(1,x0);
		y = SCAN_QUANT(1,y0);
		z = SCAN_QUANT(1,z0);
		PM_SET_CURRENT_LOC(x, y, z);
	}
	nth_part = 0;
	PM_PICK_OBJECT("浏览模型",nth_part);
	W_MAP_FRAME(MainWindow);
}


search_objects(item, event_type, button_value)
{
	/* 查询所有的模型组 query all model groups*/
	query = PM_INIT_QUERY("GROUP");
	groups = PM_EXECUTE_QUERY(query);

	/* 获取管段 Get the pipe spool group */
	temp_list = PM_INIT_SET();

	if (!ISINT(groups)){
		group_number = PM_NR_MEMBERS_IN_SET(groups);
		for (i = 0; i < group_number; i = i + 1;){
			group_handle = PM_GET_MEMBER_IN_SET(groups, i);
			group_type = PM_GET_OBJDATA(group_handle, 0, MMT_TAG_GROUPTYPE);
			/* 过滤其它类型的组 Get rid of other type group*/
 			if (group_type == "0"){
				/* 过滤不包含零件的组Get rid of group that content nothing */
				parts = PM_GET_OBJECTS_IN_GROUP(group_handle);
				if (parts != 0){
					part_number = PM_NR_MEMBERS_IN_SET(parts);
					if (part_number !=0){
						/* Get rid of valve*/
						if (part_number == 1){
							part = PM_GET_MEMBER_IN_SET(parts, 0);
							part_type = PM_GET_OBJDATA(part, 0, MMT_TAG_OBJTYPE);
							if(part_type != MMT_OBT_STANDC){
								result = PM_ADD_OBJECT_TO_SET(group_handle,temp_list);
							}
						}
						else{
							/* 将管段的handle保存到全局数组 */
							result = PM_ADD_OBJECT_TO_SET(group_handle,temp_list);
						}
					}
				}
			}
		}
	}

	model_number = PM_NR_MEMBERS_IN_SET(temp_list);
	if (model_number <= 0){
		return 0;
	}

	filter_model(temp_list);

	/* 根据当前模型查找模式将获得的模型添加到全局变量Object_List中 */
	if (Model_Add_Mode == 0){
		PM_SETOP_OR(Object_List,temp_list);
	}

	if (Model_Add_Mode == 1){
	   PM_FREE_SET(Object_List);
	   Object_List = PM_INIT_SET();
		Object_List = PM_COPY_SET(temp_list);
	}

	Object_Number = PM_NR_MEMBERS_IN_SET(Object_List);

	if (Object_Number <= 0){
		PM_FREE_SET(temp_list);
		return 0;
	}

	PM_FREE_SET(temp_list);
	/* 获取并发布生产信息 */
	get_spool_info();
	publish_model_info();
}

filter_model( models )
{
	/* 获取过滤条件 Get filter conditions*/
	system_name = W_GET_PANELITEM_ARG(System_Name,W_PANEL_VALUE);
	block_name =  W_GET_PANELITEM_ARG(Block_Name,W_PANEL_VALUE);
	bon_number = W_GET_PANELITEM_ARG(Planning_Unit,W_PANEL_VALUE);

	temp = PM_INIT_SET();

	/* 过滤掉不符合条件的模型 */
	group_number = PM_NR_MEMBERS_IN_SET(models);
	for (i = 0; i < group_number; i = i + 1;){
		group_handle = PM_GET_MEMBER_IN_SET(models, i);
		parts = PM_GET_OBJECTS_IN_GROUP(group_handle);
		part = PM_GET_MEMBER_IN_SET(parts,0);
		model_system_name = PM_GET_OBJDATA(part,0,MMT_TAG_SYSTEM_NAME);
		model_block_name = PM_GET_OBJDATA(part,0,Tag_BlockNumber);
		if(ISINT(model_block_name)){
		   model_block_name = "*";
		}
		model_bon_number = PM_GET_OBJDATA(part,0,Tag_Spool_PlanningUnit);
		if(ISINT(model_bon_number)){
		   model_bon_number = "*";
		}
		check_system = PATTERN_MATCH(model_system_name,system_name);
		check_block = PATTERN_MATCH(model_block_name,block_name);
		check_bon_number = PATTERN_MATCH(model_bon_number,bon_number);
		if(check_system & check_block & check_bon_number){
		   PM_ADD_OBJECT_TO_SET(group_handle,temp);
	   }
	}
	PM_SETOP_SUB(models,models);
	PM_SETOP_OR(models,temp);
	PM_FREE_SET(temp);
	return(0);
}

/*
get_spool_handle(part)
{
	spool_number = PM_GET_OBJDATA(part,0, MMT_COSA_SPOOL_NAME);
	if (!ISINT(spool_number)){
		spool_handle = PM_GET_OBJECT_GROUP(part, MMT_GRPT_SPOOL);
		return(spool_handle);
	}
	else
	{
		return(-1);
	}
}
*/

get_spool_handle(part)
{
	spool_number = PM_GET_OBJDATA(part, 0, MMT_COSA_SPOOL_NAME);
	if(spool_number ==0 ){
	   U_CONFIRM("选择的零件不属于任何管段");
	   return(0);
	}
	line_name = PM_GET_OBJDATA(part, 0, MMT_TAG_PIPELINE_NAME);
	member_path = PM_GET_OBJDATA(part, 0, MMT_TAG_MEMBERSHIPPATH);
   group_id = SUBSTRING(STRINGTERM(SEARCH(member_path,"@"),":"),1);
	obj_handle = PM_FIND_BY_OBJID(group_id);
	return(obj_handle);
}


pick_objects(item, event_type, button_value)
{
 	tmp = 0;
	flag = TRUE;
	temp = PM_INIT_SET();
	while(flag){
		pick_part = PM_PICK_OBJECT("请选择管段", tmp, "PIPE");
		if (pick_part != 0){
			groups_handle = get_spool_handle(pick_part);
			if (!ISINT(groups_handle)){
				PM_ADD_OBJECT_TO_SET(groups_handle,temp);
				Highlight_Object(groups_handle,TRUE);
			}
			else{
				PM_RM_OBJECT_FROM_SET(groups_handle,temp);
				Highlight_Object(groups_handle,FALSE);
			}
		}
		else{
			flag = FALSE;
		}
	}

	if (Model_Add_Mode == 0){
		PM_SETOP_OR(Object_List,temp);
	}

	if (Model_Add_Mode == 1){
		PM_SETOP_SUB(Object_List,Object_List);
		Object_List = PM_COPY_SET(temp);
	}

	Object_Number = PM_NR_MEMBERS_IN_SET(Object_List);
	if (Object_Number <= 0){
		return 0;
	}

	/* 获取并发布生产信息 */
	get_spool_info();
	publish_model_info();

	for (i = 0; i < Object_Number; i = i + 1;){
		group = PM_GET_MEMBER_IN_SET(Object_List, i);
		Highlight_Object(group,FALSE);
	}

	return(0);
}


options_selected(item, event_type, dummy)
{
	s = W_GET_PANELITEM_ARG(item, W_PANEL_VALUE);
	if ( s == "00" ){
		AutoHighLight = 0;
		AutoScale = 0;
		/* 将已经加亮的模型恢复原来的颜色 */
		model_number = PM_NR_MEMBERS_IN_SET(High_Light_List);
		for (i = 0 ; i < model_number; i = i + 1){
			model = PM_GET_MEMBER_IN_SET(High_Light_List,i);
			Highlight_Object(model,FALSE);
		}
		temp = PM_INIT_SET();
		High_Light_List = PM_COPY_SET(temp);
		PM_FREE_SET(temp);
	}
	else if( s == "10"){
		AutoHighLight = 1;
		AutoScale = 0;
	}
	else if( s == "11"){
		AutoHighLight = 1;
		AutoScale = 1;
	}
	else if( s == "01"){
		AutoHighLight = 0;
		AutoScale = 1;
		/* 将已经加亮的模型恢复原来的颜色 */
		model_number = PM_NR_MEMBERS_IN_SET(High_Light_List);
		for (i = 0 ; i < model_number; i = i + 1){
			model = PM_GET_MEMBER_IN_SET(High_Light_List,i);
			Highlight_Object(model,FALSE);
		}
		temp = PM_INIT_SET();
		High_Light_List = PM_COPY_SET(temp);
		PM_FREE_SET(temp);
	}
	return(0);
}

create_panel_upperpart(mainform)
{
	panel_upperpart = W_ADD_WINDOW(mainform, W_PANEL, "panel_upperpart");
	W_REALIZE_WINDOW(panel_upperpart,   W_FRAME_X,      0,
							            W_FRAME_Y,      0,
							            W_FRAME_ROWS,   2,
							            W_FRAME_COLS,   60);


   Block_Name = W_ADD_PANELITEM(panel_upperpart, W_PANEL_FILL, "Block_Name");
   W_REALIZE_PANELITEM(Block_Name,  W_PANEL_ROW,        0, 
                                    W_PANEL_COL,        0,
                                    W_PANEL_LABEL,      "分段名称:     ",
                                    W_PANEL_TIP,        "Block Name",
                                    W_PANEL_LENGTH,     14,
                                    W_PANEL_VALUE,      "*",
                                    W_PANEL_CALLBACK,   1);

   System_Name = W_ADD_PANELITEM(panel_upperpart, W_PANEL_FILL, "System_Name");
   W_REALIZE_PANELITEM(System_Name, W_PANEL_ROW,        0, 
                                    W_PANEL_COL,        28,
                                    W_PANEL_LABEL,      "系统名称:     ",
                                    W_PANEL_LENGTH,     14,
                                    W_PANEL_VALUE,      "*",
                                    W_PANEL_CALLBACK,   2);

   search_spool = W_ADD_PANELITEM(panel_upperpart, W_PANEL_BUTTON, "search_spool");
   W_REALIZE_PANELITEM(search_spool, W_PANEL_ROW, 	        0, 
                                    W_PANEL_COL,            54,
                                    W_PANEL_BUTTONIMAGE,    "查找",
                                    W_PANEL_WIDTH,          6,
                                    W_PANEL_BUTTONVALUE,    210,
                                    W_PANEL_CALLBACK,       1,
                                    W_PANEL_LAYOUT,         W_LAYOUT_HORIZONTAL);

   Planning_Unit = W_ADD_PANELITEM(panel_upperpart, W_PANEL_FILL, "Planning_Unit");
   W_REALIZE_PANELITEM(Planning_Unit,   W_PANEL_ROW,        1, 
                                        W_PANEL_COL,        0,
                                        W_PANEL_LABEL,      "托盘代号:     ",
                                        W_PANEL_LENGTH,     14,
                                        W_PANEL_VALUE,      "*",
                                        W_PANEL_CALLBACK,   3);

   pick_spool = W_ADD_PANELITEM(panel_upperpart, W_PANEL_BUTTON, "pick_spool");
   W_REALIZE_PANELITEM(pick_spool,  W_PANEL_ROW, 	        1, 
                                    W_PANEL_COL,            54,
                                    W_PANEL_BUTTONIMAGE,    "点选",
                                    W_PANEL_WIDTH,          6,
                                    W_PANEL_BUTTONVALUE,    210,
                                    W_PANEL_CALLBACK,       1,
                                    W_PANEL_LAYOUT,         W_LAYOUT_HORIZONTAL);

   element_add_flag = W_ADD_PANELITEM(panel_upperpart, W_PANEL_CHOICE, "element_add_flag");
   W_REALIZE_PANELITEM(element_add_flag,    W_PANEL_ROW,            2, 
                                            W_PANEL_COL,            0,
                                            W_PANEL_LABEL,          "模型信息列表模式:      ",
                                            W_PANEL_CHOICESTRING,   "追加  ",
                                            W_PANEL_CHOICESTRING,   "替换  ",
                                            W_PANEL_ORDINALVALUE,   0,
                                            W_PANEL_CHOICESTYLE,	W_STYLE_PUSHBUTTONS,
                                            W_PANEL_CALLBACK,       1);

   Options = W_ADD_PANELITEM(panel_upperpart, W_PANEL_TOGGLE, "options");
   W_REALIZE_PANELITEM(Options, W_PANEL_ROW,            2, 
                                W_PANEL_COL,            40,
                                W_PANEL_LABEL,          "",
                                W_PANEL_CHOICESTRING,   "自动加亮    ",
                                W_PANEL_CHOICESTRING,   "自动缩放    ",
                                W_PANEL_VALUE,          "00",
                                W_PANEL_CHOICESTYLE,    W_STYLE_PUSHBUTTONS,
                                W_PANEL_CALLBACK,       1);


	W_SET_PANELITEM_HANDLER(search_spool, "search_objects");
	W_SET_PANELITEM_HANDLER(pick_spool, "pick_objects");
	W_SET_PANELITEM_HANDLER(element_add_flag, "model_list_mode");
	W_SET_PANELITEM_HANDLER(Options, "options_selected");

	return(panel_upperpart);
}

create_command(mainform)
{
	command = W_ADD_WINDOW(mainform, W_PANEL, "command");
	W_REALIZE_WINDOW(command,   W_FRAME_X,      0,
							    W_FRAME_Y,      600,
							    W_FRAME_WIDTH,  300,
							    W_FRAME_HEIGHT, 1);

	Drawing_Form = W_ADD_PANELITEM(command, W_PANEL_FILL, "Drawing_Form");
	W_REALIZE_PANELITEM(Drawing_Form,   W_PANEL_ROW,        0,
                                        W_PANEL_COL,        0,
     				                    W_PANEL_LABEL,      "图框名称:   ",
     				                    W_PANEL_TIP,        "ICGD Name",
     				                    W_PANEL_LENGTH,     40,
     				                    W_PANEL_VALUE,      "",
     				                    W_PANEL_CALLBACK,   0);

	Select_Form = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "Select_Form");
	W_REALIZE_PANELITEM(Select_Form,    W_PANEL_ROW,            0,
                                        W_PANEL_COL,            50,
   						                W_PANEL_BUTTONIMAGE,    "选择图框",
   						                W_PANEL_TIP,            "Select ICGD",
   						                W_PANEL_WIDTH,          10,
   						                W_PANEL_BUTTONVALUE,    209,
   						                W_PANEL_CALLBACK,       1,
   						                W_PANEL_LAYOUT,         W_LAYOUT_HORIZONTAL);


	Create_Sketch = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "Create_Sketch");
	W_REALIZE_PANELITEM(Create_Sketch,  W_PANEL_ROW,            1,
	                                    W_PANEL_COL,            0,
							            W_PANEL_BUTTONIMAGE,    "生成小票",
							            W_PANEL_TIP,            "Create Pipe Sketch",
							            W_PANEL_WIDTH,          10,
							            W_PANEL_BUTTONVALUE,    200,
							            W_PANEL_CALLBACK,       1,
							            W_PANEL_LAYOUT,         W_LAYOUT_HORIZONTAL);

    Cur_Sketch = W_ADD_PANELITEM(command, W_PANEL_FILL, "Cur_Sketch");
	W_REALIZE_PANELITEM(Cur_Sketch, W_PANEL_ROW,            1,
                                    W_PANEL_COL,            12,
     				                W_PANEL_LABEL,          "",
     				                W_PANEL_LENGTH,         34,
     				                W_PANEL_VALUE,          "正在处理管段:   ",
     				                W_PANEL_SENSITIVITY,    0,
     				                W_PANEL_CALLBACK,       0);

    Pro_label = W_ADD_PANELITEM(command, W_PANEL_FILL, "Pro_label");
	W_REALIZE_PANELITEM(Pro_label,  W_PANEL_ROW,        1,
                                    W_PANEL_COL,        48,
  				                    W_PANEL_LABEL,      "进度:",
  				                    W_PANEL_LENGTH,     0,
  				                    W_PANEL_VALUE,      "",
  				                    W_PANEL_CALLBACK,   0);

    Process = W_ADD_PANELITEM(command, W_PANEL_FILL, "Process");
	W_REALIZE_PANELITEM(Process,    W_PANEL_ROW,            1,
                                    W_PANEL_COL,            53,
     				                W_PANEL_LABEL,          "",
     				                W_PANEL_LENGTH,         7,
     				                W_PANEL_VALUE,          "0/0",
     				                W_PANEL_SENSITIVITY,    0,
     				                W_PANEL_CALLBACK,       0);

	Open_Sketch = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "Open_Sketch");
	W_REALIZE_PANELITEM(Open_Sketch,    W_PANEL_ROW,         2,
	                                    W_PANEL_COL,         0,
							            W_PANEL_BUTTONIMAGE, "打开小票",
							            W_PANEL_WIDTH,       10,
							            W_PANEL_BUTTONVALUE, 201,
							            W_PANEL_CALLBACK,    1,
							            W_PANEL_LAYOUT,      W_LAYOUT_HORIZONTAL);

	Open_Previous = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "Open_Previous");
	W_REALIZE_PANELITEM(Open_Previous,  W_PANEL_ROW,         2,
	                                    W_PANEL_COL,         12,
							            W_PANEL_BUTTONIMAGE, "打开前一个",
							            W_PANEL_WIDTH,       10,
							            W_PANEL_BUTTONVALUE, 202,
							            W_PANEL_CALLBACK,    1,
							            W_PANEL_TIP,         "Open Previous Pipe Sketch",
							            W_PANEL_LAYOUT,      W_LAYOUT_HORIZONTAL);

	Open_Next = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "Open_Next");
	W_REALIZE_PANELITEM(Open_Next,  W_PANEL_ROW,         2,
	                                W_PANEL_COL,         24,
							        W_PANEL_BUTTONIMAGE, "打开下一个",
							        W_PANEL_WIDTH,       10,
							        W_PANEL_BUTTONVALUE, 203,
							        W_PANEL_CALLBACK,    1,
							        W_PANEL_TIP,         "Open Next Pipe Sketch",
							        W_PANEL_LAYOUT,      W_LAYOUT_HORIZONTAL);

	Browse_Model = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "Browse_Model");
	W_REALIZE_PANELITEM(Browse_Model,   W_PANEL_ROW,         2,
	                                    W_PANEL_COL,         36,
							            W_PANEL_BUTTONIMAGE, "浏览模型",
							            W_PANEL_WIDTH,       10,
							            W_PANEL_BUTTONVALUE, 204,
							            W_PANEL_CALLBACK,    1,
							            W_PANEL_LAYOUT,      W_LAYOUT_HORIZONTAL);

	Delete_Sketch = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "Delete_Sketch");
	W_REALIZE_PANELITEM(Delete_Sketch,  W_PANEL_ROW,         3,
	                                    W_PANEL_COL,         0,
   							            W_PANEL_BUTTONIMAGE, "删除小票",
   							            W_PANEL_WIDTH,       10,
   							            W_PANEL_BUTTONVALUE, 301,
   							            W_PANEL_CALLBACK,    1,
   							            W_PANEL_LAYOUT,      W_LAYOUT_HORIZONTAL);

	Print_Sketch = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "Print_Sketch");
	W_REALIZE_PANELITEM(Print_Sketch,   W_PANEL_ROW,         3,
	                                    W_PANEL_COL,         12,
   							            W_PANEL_BUTTONIMAGE, "打印小票",
   							            W_PANEL_WIDTH,       10,
   							            W_PANEL_BUTTONVALUE, 302,
   							            W_PANEL_CALLBACK,    1,
   							            W_PANEL_LAYOUT,      W_LAYOUT_HORIZONTAL);

	Export_Dxf = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "Export_Dxf");
	W_REALIZE_PANELITEM(Export_Dxf,   W_PANEL_ROW,         3,
                                      W_PANEL_COL,         24,
   							          W_PANEL_BUTTONIMAGE, "导出DXF",
   							          W_PANEL_WIDTH,       10,
   							          W_PANEL_BUTTONVALUE, 303,
   							          W_PANEL_CALLBACK,    1,
   							          W_PANEL_LAYOUT,      W_LAYOUT_HORIZONTAL);

	Export_Pdf = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "Export_Pdf");
	W_REALIZE_PANELITEM(Export_Pdf,   W_PANEL_ROW,         3,
                                      W_PANEL_COL,         36,
   							          W_PANEL_BUTTONIMAGE, "导出PDF",
   							          W_PANEL_WIDTH,       10,
   							          W_PANEL_BUTTONVALUE, 304,
   							          W_PANEL_CALLBACK,    1,
   							          W_PANEL_LAYOUT,      W_LAYOUT_HORIZONTAL);

	quit = W_ADD_PANELITEM(command, W_PANEL_BUTTON, "quit");
	W_REALIZE_PANELITEM(quit,  W_PANEL_ROW, 	    3,
	                           W_PANEL_COL,         50,
							   W_PANEL_BUTTONIMAGE, "退出",
							   W_PANEL_WIDTH,       10,
							   W_PANEL_BUTTONVALUE, 305,
							   W_PANEL_CALLBACK,    1,
							   W_PANEL_CLOSEBUTTON, 1,
							   W_PANEL_LAYOUT,      W_LAYOUT_HORIZONTAL);

	W_SET_PANELITEM_HANDLER(Select_Form, "select_form_handler");
	W_SET_PANELITEM_HANDLER(quit, "quit_handler");
	W_SET_PANELITEM_HANDLER(Create_Sketch, "create_sketch_handler");
	W_SET_PANELITEM_HANDLER(Export_Pdf, "export_pdf_handler");
	W_SET_PANELITEM_HANDLER(Export_Dxf, "export_dxf_handler");
	W_SET_PANELITEM_HANDLER(Print_Sketch, "print_sketch_handler");
	W_SET_PANELITEM_HANDLER(Delete_Sketch, "delete_sketch_handler");
	W_SET_PANELITEM_HANDLER(Open_Sketch, "open_sketch_handler");
	W_SET_PANELITEM_HANDLER(Open_Next, "open_sketch_handler");
	W_SET_PANELITEM_HANDLER(Open_Previous, "open_sketch_handler");
	W_SET_PANELITEM_HANDLER(Browse_Model, "model_browsing_handler");

	return(command);
}

delete_sketch_handler(item, event_type, button_value)
{
	/* 检查是否已经选择模型 */
	spools_number = PM_NR_MEMBERS_IN_SET(Selected_Objects);
	if (spools_number <= 0){
		U_CONFIRM("请先选择管段");
		return(0);
	}

	sel = A_ALLOC(2);
	A_PUT(sel,0,"保留最新版本");
	A_PUT(sel,1,"删除所有版本");
	si = 1;
	res = DM_CALL_SCRIPT("macro/Select.mac","U_Select",
		"请选择删除模式",2,sel,si);
	A_FREE(sel);

   if(res == -1){
      return(0);
   }
   else if(res == 0){
   	/*循环处理选中的管段*/
   	for(i=0;i<spools_number;i=i+1;){
      	/*检查是否已经生成小票*/
      	spool_handle = PM_GET_MEMBER_IN_SET(Selected_Objects,i);
      	sketch_name = Get_Attribute_Value(spool_handle,Tag_Sketch_Name);
         if(ISSTRING(sketch_name) & sketch_name != "Unset"){
         	current_version = String_To_Int(SUBSTRING(SEARCH(sketch_name,"-SK"),3));
         	for(k=0;k<current_version;k=k+1;){
         	   drawing_name = STRINGTERM(sketch_name,"-SK") + "-SK" + ITOASCII(k);
         	   doc_guid = "";
         	   res = PM_FIND_DRAWING_WITH_NAME(drawing_name,doc_guid);
         	   if(doc_guid != ""){
         	      res = PM_DELETE_DRAWING(drawing_name);
         	      if(res == 0){
         	         mess = "小票<" + drawing_name + ">已经被删除";
         	         U_MESSAGE(mess);
         	      }
         	      else{
         	         prompt_error(drawing_name,res);
         	      }
         	   }
         	}
         }
      }
   }
   else if(res == 1){
   	/*循环处理选中的管段*/
   	for(i=0;i<spools_number;i=i+1;){
      	/*检查是否已经生成小票*/
      	spool_handle = PM_GET_MEMBER_IN_SET(Selected_Objects,i);
      	sketch_name = Get_Attribute_Value(spool_handle,Tag_Sketch_Name);
         if(ISSTRING(sketch_name) & sketch_name != "Unset"){
         	current_version = String_To_Int(SUBSTRING(SEARCH(sketch_name,"-SK"),3));
         	for(k=0;k<=current_version;k=k+1;){
         	   drawing_name = STRINGTERM(sketch_name,"-SK") + "-SK" + ITOASCII(k);
         	   doc_guid = "";
         	   res = PM_FIND_DRAWING_WITH_NAME(drawing_name,doc_guid);
         	   if(doc_guid != ""){
         	      res = PM_DELETE_DRAWING(drawing_name);
         	      if(res == 0){
         	         mess = "小票<" + drawing_name + ">已经被删除";
         	         U_MESSAGE(mess);
         	      }
         	      else{
         	         prompt_error(drawing_name,res);
         	      }
         	   }
         	}
         }
         res = Set_Attribute_Value(spool_handle,Tag_Sketch_Name,"Unset");
         /*将生成的小票名称显示在格栅中*/
         id = find_spool_grid_id(spool_handle);
         if(id != -1){
            W_SET_WINDOW_ARGS(DisplayGrid,W_LISTW_FINDID,id);
            row = W_GET_WINDOW_ARG(DisplayGrid,W_LISTW_ROW);
            W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_ROW, row, W_LISTW_COLUMN, 2, W_LISTW_STRING, "Unset");
         }
      }
   }
   PM_SAVE(0,1,1);
   return(0);
}

prompt_error(drawing_name,res)
{
   if(res == -1){
      mess = "小票<" + drawing_name + ">无法删除";
      U_MESSAGE(mess);
   }
   else if(res == MMT_E_DRW_NOTFOUND){
      mess = "小票<" + drawing_name + ">不存在";
      U_MESSAGE(mess);
   }
   else if(res == DM_E_DOC_NOT_OWNER){
      mess = "你没有删除小票<" + drawing_name + ">的权限";
      U_MESSAGE(mess);
   }
   else{
      mess = "小票<" + drawing_name + ">无法删除";
      U_MESSAGE(mess);
   }
   return(0);

}

open_sketch_handler(item, event_type, button_value)
{
	/* 检查是否已经选择模型 */
	spools_number = PM_NR_MEMBERS_IN_SET(Selected_Objects);
	if (spools_number <= 0){
		U_CONFIRM("请先选择管段");
		return(0);
	}
	else if(spools_number > 1){
		U_CONFIRM("一次只能打开一个图形");
		return(0);
	}

	if(item == Open_Next){
	   row_number = W_GET_WINDOW_ARG(DisplayGrid, W_LISTW_NUMOFCHOICES);
	   current_row = W_GET_WINDOW_ARG(DisplayGrid, W_LISTW_ROW);
	   new_row = current_row + 1;
	   if(new_row >= row_number){
	      U_CONFIRM("当前管段已经是最后一个管段");
	      return(0);
	   }
	   ms_value = W_GET_WINDOW_ARG(DisplayGrid, W_LISTW_MSVALUE);
	   ms_value = "0" + HEAD(ms_value,STRLEN(ms_value)-1);
	   res = W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_MSVALUE, ms_value);
	   item_id = W_GET_WINDOW_ARG(DisplayGrid,W_LISTW_ITEMID);
	   grid_handler(DisplayGrid, W_EVENT_ITEM_SELECTED, new_row, 0, item_id);
	}
	else if(item == Open_Previous){
	   row_number = W_GET_WINDOW_ARG(DisplayGrid, W_LISTW_NUMOFCHOICES);
	   current_row = W_GET_WINDOW_ARG(DisplayGrid, W_LISTW_ROW);
	   new_row = current_row - 1;
	   if(new_row < 0){
	      U_CONFIRM("当前管段已经是第一个管段");
	      return(0);
	   }
	   ms_value = W_GET_WINDOW_ARG(DisplayGrid, W_LISTW_MSVALUE);
	   ms_value =  TAIL(ms_value,STRLEN(ms_value)-1) + "0";
	   res = W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_MSVALUE, ms_value);
	   item_id = W_GET_WINDOW_ARG(DisplayGrid,W_LISTW_ITEMID);
	   grid_handler(DisplayGrid, W_EVENT_ITEM_SELECTED, new_row, 0, item_id);
	}

	/*检查是否已经生成小票*/
	spool_handle = PM_GET_MEMBER_IN_SET(Selected_Objects,0);
	drawing_name = Get_Attribute_Value(spool_handle,Tag_Sketch_Name);
	if(ISINT(drawing_name)){
	   U_CONFIRM("尚未生成小票");
	   return(0);
	}

	/*检查小票图形是否存在（有可能被手工删除或者其它原因）*/
	doc_guid = "";
	res = PM_FIND_DRAWING_WITH_NAME(drawing_name,doc_guid);
	if(doc_guid == ""){
	   U_CONFIRM("小票图形不存在");
	   return(0);
	}

	/*检查当前是否有打开的图形*/
	current_drawing = PM_GET_ACTIVE_DRW_NAME();
	if(current_drawing != ""){
	   PM_SAVE_ACTIVE_DRW();
	   PM_CHECK_IN_ACTIVE_DRW();
	   PM_CLOSE_ACTIVE_DRW();
	}

   PM_OPEN_DRAWING(drawing_name,PM_DRW_OFLG_EDIT,"","");

	W_UNMAP_FRAME(MainWindow);
	st = PM_EDIT_ACTIVE_DRW(0);
	W_MAP_FRAME(MainWindow);

	dwg_name = PM_GET_ACTIVE_DRW_NAME();
	if(dwg_name != ""){
		st = PM_SAVE_ACTIVE_DRW();
		if(st){
			U_CONFIRM("无法保存当前图形 <" + dwg_name + ">!");
		}
		else {
			st = PM_CHECK_IN_ACTIVE_DRW();
			if(st){
				U_CONFIRM("无法Check In当前图形 <" + dwg_name + ">!");
			}
		}
		PM_CLOSE_ACTIVE_DRW();
	}

	return(0);
}

print_sketch_handler(item, event_type, button_value)
{
	/* 检查是否已经选择模型 */
	spools_number = PM_NR_MEMBERS_IN_SET(Selected_Objects);
	if (spools_number <= 0){
		U_CONFIRM("请先选择管段");
		return(0);
	}

	/*检查管段小票是否已经生成*/
	for(i=0;i<spools_number;i=i+1;){

   	/*检查是否已经生成小票*/
   	spool_handle = PM_GET_MEMBER_IN_SET(Selected_Objects,i);
   	spool_name = Get_SpoolName(spool_handle);
   	drawing_name = Get_Attribute_Value(spool_handle,Tag_Sketch_Name);
   	if(ISINT(drawing_name)){
   	   mess = "管段<" + spool_name + ">尚未生成小票";
   	   U_MESSAGE(mess);
   	}

   	/*检查小票图形是否存在（有可能被手工删除或者其它原因）*/
   	doc_guid = "";
   	res = PM_FIND_DRAWING_WITH_NAME(drawing_name,doc_guid);
   	if(doc_guid == ""){
   	   mess = "小票<"+drawing_name+">不存在";
   	   U_MESSAGE(mess);
   	   return(0);
   	}
   }

   /*循环打印小票*/
	for(i=0;i<spools_number;i=i+1;){

   	spool_handle = PM_GET_MEMBER_IN_SET(Selected_Objects,i);
   	spool_name = Get_SpoolName(spool_handle);
   	drawing_name = Get_Attribute_Value(spool_handle,Tag_Sketch_Name);

      /*检查当前是否有打开的图形*/
   	current_drawing = PM_GET_ACTIVE_DRW_NAME();
   	if(current_drawing != ""){
   	   PM_SAVE_ACTIVE_DRW();
   	   PM_CHECK_IN_ACTIVE_DRW();
   	   PM_CLOSE_ACTIVE_DRW();
	   }

	   PM_OPEN_DRAWING(drawing_name,PM_DRW_OFLG_EDIT,"","");
	   mess = "开始打印图形<" + drawing_name + ">";
	   U_MESSAGE(mess);
	   res = PM_PLOT_ACTIVE_DRW(0);
	   if(res == -1){
	      DM_EDIT_SHEET_PLOT_SETTINGS();
         res = PM_PLOT_ACTIVE_DRW(0);
         if(res == -1){
            mess = "图形<" + drawing_name + ">打印失败";
            U_MESSAGE(mess);
         }
	   }
	   else if(res == MMT_E_DRW_NOTACTIVE){
   	   mess = "图形<" + drawing_name + ">无法激活，打印失败";
   	   U_MESSAGE(mess);
	   }
	   else{
   	   mess = "图形<" + drawing_name + ">打印结束";
   	   U_MESSAGE(mess);
	   }
	}
   return(0);
}

export_pdf_handler(item, event_type, button_value)
{
	/* 检查是否已经选择模型 */
	spools_number = PM_NR_MEMBERS_IN_SET(Selected_Objects);
	if (spools_number <= 0){
		U_CONFIRM("请先选择管段");
		return(0);
	}

	path = U_GET_DIRECTORY("选择输PDF文件出路径", "c:\\", "", 0);
	if(ISINT(path)){
	   return(0);
	}

	/*循环输出管段小票图*/
	for(i=0;i<spools_number;i=i+1;){

   	/*检查是否已经生成小票*/
   	spool_handle = PM_GET_MEMBER_IN_SET(Selected_Objects,i);
   	spool_name = Get_SpoolName(spool_handle);
   	drawing_name = Get_Attribute_Value(spool_handle,Tag_Sketch_Name);
   	if(ISINT(drawing_name)){
   	   mess = "管段<" + spool_name + ">尚未生成小票";
   	   U_MESSAGE(mess);
   	}
   	else{
      	/*检查小票图形是否存在（有可能被手工删除或者其它原因）*/
      	doc_guid = "";
      	res = PM_FIND_DRAWING_WITH_NAME(drawing_name,doc_guid);
      	if(doc_guid == ""){
      	   mess = "小票<"+drawing_name+">不存在";
      	   U_MESSAGE(mess);
      	}
      	else{
            /*检查当前是否有打开的图形*/
         	current_drawing = PM_GET_ACTIVE_DRW_NAME();
         	if(current_drawing != ""){
         	   PM_SAVE_ACTIVE_DRW();
         	   PM_CHECK_IN_ACTIVE_DRW();
         	   PM_CLOSE_ACTIVE_DRW();
      	   }

      	   res = PM_OPEN_DRAWING(drawing_name,PM_DRW_OFLG_EDIT,"","");
      	   if(res == -1){
      	      mess = "无法打开图形<" + drawing_name + ">，输出失败";
      	      U_MESSAGE(mess);
      	   }
      	   else{
         	   mess = "开始输出图形<" + drawing_name + ">的PDF文件";
         	   U_MESSAGE(mess);
         	   format = G2D_EXT_FRM_PDF;
         	   output_dir = path;
         	   template_dwr = "";
         	   res = Export_Active_Drw(format, template_dwr, output_dir);
         	   if(res == -1){
         	      mess = "图形<" + drawing_name + ">输出失败";
         	      U_MESSAGE(mess);
         	   }
         	   else if(res == MMT_E_DRW_NOTACTIVE){
            	   mess = "图形<" + drawing_name + ">无法激活，输出失败";
            	   U_MESSAGE(mess);
         	   }
         	   else{
            	   mess = "图形<" + drawing_name + ">输出结束";
            	   U_MESSAGE(mess);
         	   }
         	}
      	}
   	}
	}
   return(0);
}

export_dxf_handler(item, event_type, button_value)
{
	/* 检查是否已经选择模型 */
	spools_number = PM_NR_MEMBERS_IN_SET(Selected_Objects);
	if (spools_number <= 0){
		U_CONFIRM("请先选择管段");
		return(0);
	}

	path = U_GET_DIRECTORY("选择输DXF文件出路径", "c:\\", "", 0);
	if(ISINT(path)){
	   return(0);
	}

	/*循环输出管段小票图*/
	for(i=0;i<spools_number;i=i+1;){

   	/*检查是否已经生成小票*/
   	spool_handle = PM_GET_MEMBER_IN_SET(Selected_Objects,i);
   	spool_name = Get_SpoolName(spool_handle);
   	drawing_name = Get_Attribute_Value(spool_handle,Tag_Sketch_Name);
   	if(ISINT(drawing_name)){
   	   mess = "管段<" + spool_name + ">尚未生成小票";
   	   U_MESSAGE(mess);
   	}
   	else{
      	/*检查小票图形是否存在（有可能被手工删除或者其它原因）*/
      	doc_guid = "";
      	res = PM_FIND_DRAWING_WITH_NAME(drawing_name,doc_guid);
      	if(doc_guid == ""){
      	   mess = "小票<"+drawing_name+">不存在";
      	   U_MESSAGE(mess);
      	}
      	else{
            /*检查当前是否有打开的图形*/
         	current_drawing = PM_GET_ACTIVE_DRW_NAME();
         	if(current_drawing != ""){
         	   PM_SAVE_ACTIVE_DRW();
         	   PM_CHECK_IN_ACTIVE_DRW();
         	   PM_CLOSE_ACTIVE_DRW();
      	   }

      	   res = PM_OPEN_DRAWING(drawing_name,PM_DRW_OFLG_EDIT,"","");
      	   if(res == -1){
      	      mess = "无法打开图形<" + drawing_name + ">，输出失败";
      	      U_MESSAGE(mess);
      	   }
      	   else{
         	   mess = "开始输出图形<" + drawing_name + ">的DXF文件";
         	   U_MESSAGE(mess);
         	   format = G2D_EXT_FRM_DXF_2000;
         	   output_dir = path;
         	   template_dwr = "";
         	   res = Export_Active_Drw(format, template_dwr, output_dir);
         	   if(res == -1){
         	      mess = "图形<" + drawing_name + ">输出失败";
         	      U_MESSAGE(mess);
         	   }
         	   else if(res == MMT_E_DRW_NOTACTIVE){
            	   mess = "图形<" + drawing_name + ">无法激活，输出失败";
            	   U_MESSAGE(mess);
         	   }
         	   else{
            	   mess = "图形<" + drawing_name + ">输出结束";
            	   U_MESSAGE(mess);
         	   }
         	}
      	}
   	}
	}
   return(0);
}

select_form_handler(item, event_type, button_value)
{
   drawing_form = DM_SELECT_ICGD("",2);
   if(ISSTRING(drawing_form) & drawing_form != ""){
      W_SET_PANELITEM_ARGS(Drawing_Form, W_PANEL_VALUE, drawing_form);
      SET_STRING_DEFAULT("PipeSketchGenerator", "Drawing_Form", drawing_form);
      Drawing_Form_Name = drawing_form;
   }
   return(0);
}

create_sketch_handler(item, event_type, button_value)
{
	/* 检查是否已经选择模型 */
	spools_number = PM_NR_MEMBERS_IN_SET(Selected_Objects);

	if (spools_number <= 0){
		U_CONFIRM("请先选择管段");
		return(0);
	}

	/* 检查图框等设置是否正确 */


	/* 循环生成选中的管段的小票 */
	x0 = 0;y0 = 0;z0 = 0;
	PM_GET_CURRENT_LOC(x0,y0,z0);
	start_time = GET_TIME();
	for(i=0;i<spools_number;i=i+1;){
		process_info = ITOASCII(i+1) + "/" + ITOASCII(spools_number);
		W_SET_PANELITEM_ARGS(Process, W_PANEL_VALUE, process_info);
		Current_Spool_Handle = PM_GET_MEMBER_IN_SET(Selected_Objects, i);
		Cur_Spool_Model_Set = PM_GET_OBJECTS_IN_GROUP(Current_Spool_Handle);
		Cur_Spool_Name = PM_GET_OBJDATA(Current_Spool_Handle,0,Tag_Spool_Name);
		sketch_info = "正在处理管段<" + Cur_Spool_Name + ">";
		W_SET_PANELITEM_ARGS(Cur_Sketch, W_PANEL_VALUE, sketch_info);				
		access = Get_Object_Access_Status(Current_Spool_Handle);
		if(access != "CheckOutByMe"){
			mess = "你没有管段<" + Cur_Spool_Name + ">的修改权限,无法生成小票";
			U_CONFIRM(mess);
		}	
		else{
			/*查找是否有开孔管理生成的复板*/
			PM_SETOP_SUB(Double_Plate_Set,Double_Plate_Set);
			Have_Double_Plate = 0;
			double_plate_handle = find_double_plate();
			if(!ISINT(double_plate_handle)){
				Have_Double_Plate = 1;
				PM_ADD_OBJECT_TO_SET(double_plate_handle,Double_Plate_Set);
			}
			res = generate_sketch();	
			if(res == -1){
				mess = "无法生成管段:" + Cur_Spool_Name + "的小票";
				U_MESSAGE(mess);
			}					
		}
	}
	end_time = GET_TIME();
	consumption = end_time - start_time;
	sketch_info = "处理完毕，共耗时" + ITOASCII(consumption) + "秒";
	W_SET_PANELITEM_ARGS(Cur_Sketch, W_PANEL_VALUE, sketch_info);
	PM_SET_CURRENT_LOC(x0,y0,z0);
	return(0);
}

/*
--查找当前管段是否有使用开孔管理生成的复板
*/
find_double_plate()
{
   pipe_number = PM_NR_MEMBERS_IN_SET(Cur_Spool_Model_Set);
   for(i=0;i<pipe_number;i=i+1;){
      pipe = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,i);
      group = PM_GET_OBJDATA(pipe,0,MMT_TAG_MEMBERSHIPPATH);
      turn = 0;
      if(ISSTRING(group)){
         flag = 1;
         while(flag){
            group = SEARCH(group,"G@");
            if(ISSTRING(group)){
               group = SUBSTRING(group,2);
               oid = STRINGTERM(group,":");
               group_handle = PM_FIND_BY_OBJID(oid);
               if(!ISINT(group_handle)){
                  group_type = PM_GET_OBJDATA(group_handle,0,MMT_TAG_GROUPTYPE);
                  if(group_type == "19"){
                     penetration = PM_GET_OBJECTS_IN_GROUP(group_handle);
                     part_number = PM_NR_MEMBERS_IN_SET(penetration);
                     for(k=0;k<part_number;k=k+1;){
                        part_handle = PM_GET_MEMBER_IN_SET(penetration,k);
                        pid = PM_GET_OBJDATA(part_handle,0,MMT_TAG_PARTID);
                        shape = DM_PARTID_DATA(pid,DM_COSA_SHAPE);
                        if(shape == "7"){
                           return(part_handle);
                        }
                     }
                     return(-1);
                  }
               }
            }
            else{
               flag = 0;
            }
            if(turn > 5){
               flag = 0;
            }
            turn = turn + 1;
         }
      }
   }
   return(-1);
}

generate_sketch()
{
   Cur_Sketch_Name = get_drawing_name();
   /*创建小票图形*/
   res = create_drawing();
   if(res == -1){
      return(-1);
   }

   res = PM_OPEN_DRAWING(Cur_Sketch_Name,PM_DRW_OFLG_EDIT,"","");
   if(res != 0){
      mess = "无法打开小票图:" + Cur_Sketch_Name;
      U_MESSAGE(mess);
      return(-1);
   }

   /*创建管段视图*/
   res = create_view();
   if(res != 0){
      mess = "无法在小票图:" + Cur_Sketch_Name + "中创建管段视图";
      U_MESSAGE(mess);
      return(-1);
   }

   /*将管段视图分配到小票图中*/
   res = assign_views_to_drawing();
   if(res != 0){
      mess = "无法将管段视图分配给小票图:" + Cur_Sketch_Name;
      U_MESSAGE(mess);
      return(-1);
   }

   /*将管段中的pipe按照规则排列好*/
   sort_spool_branch();

   /*将管段中的part按照规则排列好*/
   sort_spool_parts();

   /* 获取管段材料表信息*/
   res = get_mto_table();

   if(res != 0){
      mess = "获取管段:" + Cur_Spool_Name + "的材料信息时出错";
      U_MESSAGE(mess);
      return(-1);
   }

   /* 绘制材料表*/
   res = draw_mto_table();

   /*获取校管表，连接表，连接编号标注等信息*/
   get_check_table_and_connection_table();
   draw_check_table();
   draw_connection_table();

   /*获取并绘制弯管表信息*/
   get_bending_table();
   draw_bending_table();

   /*添加零件的装配参考标识及相关装配信息*/
   add_assembly_information();

   /*获取并绘制装配表信息*/
   get_assembly_table();
   draw_assembly_table();

   /*合并标注信息*/
   filtrate_assembly_label();
   get_label_table();

   /*标注相关信息*/
   draw_label();

   /*获取尺寸标注信息*/
   get_dimension_table();

   /*标注尺寸*/
   draw_dimension();


   /*设置标题信息*/
   set_header_field();

   /*保存小票图*/
   res = PM_SAVE_ACTIVE_DRW();
   if(res != 0){
      mess = "无法保存小票图:" + Cur_Sketch_Name;
      U_MESSAGE(mess);
      return(-1);
   }

   /*CheckIn小票图*/
   res = PM_CHECK_IN_ACTIVE_DRW();
   if(res != 0){
      mess = "无法CheckIn小票图:" + Cur_Sketch_Name;
      U_MESSAGE(mess);
      return(-1);
   }

   /*关闭小票图*/
   res = PM_CLOSE_ACTIVE_DRW();
   if(res != 0){
      mess = "无法关闭小票图:" + Cur_Sketch_Name;
      U_MESSAGE(mess);
      return(-1);
   }
   return(0);
}

/*如果有多个零件的装配信息参考相同的一个零件，图面上会出现重复标注的现象
**这段代码用于过滤重复的装配参考标注
*/
filtrate_assembly_label()
{
   temp = alloc_2darray(Assembly_Label_Number,4);
   assembly_label_number = 0;
   for(i=0;i<Assembly_Label_Number;i=i+1;){
      if(assembly_label_number == 0){
         label = get_2darray(Assembly_Label_Table,i,0);
         x = get_2darray(Assembly_Label_Table,i,1);
         y = get_2darray(Assembly_Label_Table,i,2);
         z = get_2darray(Assembly_Label_Table,i,3);
         put_2darray(temp,assembly_label_number,0,label);
         put_2darray(temp,assembly_label_number,1,x);
         put_2darray(temp,assembly_label_number,2,y);
         put_2darray(temp,assembly_label_number,3,z);
         assembly_label_number = assembly_label_number + 1;
      }
      else{
         label = get_2darray(Assembly_Label_Table,i,0);
         exist = 0;
         for(k=0;k<assembly_label_number;k=k+1;){
            label0 = get_2darray(Assembly_Label_Table,k,0);
            if(label0 == label){
               exist = 1;
            }
         }
         if(!exist){
            x = get_2darray(Assembly_Label_Table,i,1);
            y = get_2darray(Assembly_Label_Table,i,2);
            z = get_2darray(Assembly_Label_Table,i,3);
            put_2darray(temp,assembly_label_number,0,label);
            put_2darray(temp,assembly_label_number,1,x);
            put_2darray(temp,assembly_label_number,2,y);
            put_2darray(temp,assembly_label_number,3,z);
            assembly_label_number = assembly_label_number + 1;
         }
      }
   }

   /*将过滤后的结果存入全局变量*/
	Assembly_Label_Number = assembly_label_number;
	/*初始化装配表标注信息全局数组*/
   free_2darray(Assembly_Label_Table);
   Assembly_Label_Table = alloc_2darray(Assembly_Label_Number,4);

   /*将装配表标注信息从临时数组拷贝到全局数组*/
	for (n = 0; n < Assembly_Label_Number; n = n + 1;){
	   for(m = 0; m < 4; m = m + 1){
	      info = get_2darray(temp,n,m);
	      put_2darray(Assembly_Label_Table, n, m, info);
	   }
	}

	/*释放临时数组的资源*/
	free_2darray(temp);
}

/*给零件添加相关的装配参考信息，主要包括下面内容
--如果弯管上有多个弯头，给弯头添加一些顺序号以示区别
*/
add_assembly_information()
{
   /*添加弯头BEND装配信息*/
   branch_number = 0;
   bend_number = 0;
   for(i=0;i<Spool_Part_Number;i=i+1;){
      type = get_2darray(Spool_Parts,i,4);
      if(type == "BEND"){
         branch = get_2darray(Spool_Parts,i,0);
         if(branch != branch_number){
            branch_number = branch;
            bend_number = 0;
         }
         info = "";
         if(bend_number == 0){
            info = "B";
         }
         else{
            info = "B" + ITOASCII(bend_number);
         }
         put_2darray(Spool_Parts,i,13,info);
         bend_number = bend_number + 1;
      }
   }
   return(0);
}

/* 设置标题栏中的相关信息 */
set_header_field()
{	
    page_header_rec = DM_INIT_TAGREC();
    res = PM_GET_HEADER_FROM_ACTIVE_DRW(page_header_rec);
    if(res != 0){
        U_CONFIRM("无法获取标题栏数据");
        return(0);
    }
    /*表面处理信息*/
    pre_treatment = Get_Attribute_Value(Current_Spool_Handle,Tag_Spool_PrevTreatment);
    if(ISSTRING(pre_treatment)){
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_PipePreTre,pre_treatment);
    }

    inside_treatment = Get_Attribute_Value(Current_Spool_Handle,Tag_Spool_SurfTreatmentIn);
    if(ISSTRING(inside_treatment)){
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_InSurfTreat,inside_treatment);
    }

    outside_treatment = Get_Attribute_Value(Current_Spool_Handle,Tag_Spool_SurfTreatmentOut);
    if(ISSTRING(outside_treatment)){
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_OutSurfTreat,outside_treatment);
    }
    
    /*管段名称*/
    spool_name = Get_Attribute_Value(Current_Spool_Handle,Tag_Spool_Name);
    if(ISSTRING(spool_name)){
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_SpoolName,spool_name);
    } 

    /*托盘代号*/
    planning_unit = Get_Attribute_Value(Current_Spool_Handle,Tag_Spool_PlanningUnit);
    if(ISSTRING(planning_unit)){
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_PlanningUnit,planning_unit);
    }

    /*重量*/
    weight_f = Get_Pipe_Spool_Weight(Current_Spool_Handle);
    weight = "";
    S_PRINTF(weight,"%.2f",weight_f);
    DM_SET_TAGVAL(page_header_rec,Tag_Drawing_SpoolWeight,weight);
    
    /*试验压力*/
    test_pressure = Get_Attribute_Value(Current_Spool_Handle,Tag_Spool_TestPressure);
    if(ISSTRING(test_pressure)){
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_TestPress,test_pressure);
    }

    /*页码信息*/
    page_number = Get_Attribute_Value(Current_Spool_Handle,Tag_Spool_Page);
    if(ISSTRING(page_number)){
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_PageNumber,page_number);
    }
    /*
    total_page = Get_Attribute_Value(Current_Spool_Handle,Tag_Spool_TotalPage);
    if(ISSTRING(total_page)){
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_TotalPage,total_page);
    }
	*/
    /*图号信息*/
    drawing_number = get_drawing_number();
	if(ISSTRING(drawing_number)){
		DM_SET_TAGVAL(page_header_rec,Tag_Drawing_DrawingNumber,drawing_number);
	}
	
    /*注解信息*/
    sketch_note = get_sketch_note();
    DM_SET_TAGVAL(page_header_rec,Tag_Drawing_Note,sketch_note);

    /*管材信息*/
    tube_info = get_tube_info();
	if(ISSTRING(tube_info)){
		DM_SET_TAGVAL(page_header_rec,Tag_Drawing_PipeMaterial,tube_info);
	}
	
    /*系统名称*/
    system_name = Get_Def_Spool_System_Name(Current_Spool_Handle);
	if(ISSTRING(system_name)){
		DM_SET_TAGVAL(page_header_rec,Tag_Drawing_SystemName,system_name);
	}
	
    /*垫片材料*/                                                      
    gasket_material = Get_Attribute_Value(Current_Spool_Handle,Tag_Spool_GasketMaterial);   
    if(ISSTRING(gasket_material)){
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_GasketMat,gasket_material);
    }
    
    /* 绝缘材料 */
    insulation_material = get_insulation_material(Current_Spool_Handle);   
    if(ISSTRING(insulation_material)){
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_Insulation,insulation_material);
    }
    
    /* 弯模半径 */
	
    if( Bending_Radius > 0){
        radius_str = "";                  
        S_PRINTF(radius_str,"%d",Bending_Radius); 
        DM_SET_TAGVAL(page_header_rec,Tag_Drawing_BendingRadiu,radius_str);      
    }
   
    /* 项目信息 */ 
	if(ISSTRING(Proj_Description)){
		DM_SET_TAGVAL(page_header_rec,Tag_Drawing_ShipName,Proj_Description);
	}
    if(ISSTRING(Proj_Number)){
		DM_SET_TAGVAL(page_header_rec,Tag_Drawing_ShipNumber,Proj_Number);
	}
       		
	/*设置标题栏信息*/
	res = PM_SET_HEADER_TO_ACTIVE_DRW(page_header_rec);
	return(0);
}

get_drawing_number()
{
    drawing_number = PM_GET_OBJDATA(Current_Spool_Handle,0,Tag_Spool_DrawingNumber);
	return(drawing_number);
}

get_tube_info()
{
   flag = 1;
   tube_info = "";
   i = 0;
   spool_type = Get_Attribute_Value(Current_Spool_Handle,Tag_Spool_Type);
   if(!ISSTRING(spool_type)){
      spool_type = "PRE";
   }
   while(flag){
      part_type = get_2darray(Spool_Parts,i,4);
      if(part_type == "TUBE"){
         mto_number = get_2darray(Spool_Parts,i,5);
         mto = String_To_Int(mto_number)-1;
         tube_description = get_2darray(Mto_Table,mto,3);
         tube_info = spool_type + "-" + tube_description;
         tube_info = HEAD(tube_info,50);
         return(tube_info);
      }
      if(i>=Spool_Part_Number){
         tube_info = spool_type + "-" + "Unset";
         tube_info = HEAD(tube_info,50);
         return(tube_info);
      }
      i = i + 1;
   }
}

get_sketch_note()
{
   flag = 1;
   sketch_note = "";
   i = 0;
   while(flag){
      pipe = get_2darray(Spool_Parts,i,1);
      nth = get_2darray(Spool_Parts,i,3);
      system_name = PM_GET_OBJDATA(pipe, nth, MMT_TAG_SYSTEM_NAME);
      if(ISSTRING(system_name)){
         return(system_name);
      }
      if(i>=Spool_Part_Number){
         return("Unset");
      }
      i = i + 1;
   }
}

get_spool_weight()
{
   weight = 0.0;
   for(i=0;i<Mto_Number;i=i+1;){
      part_weight = get_2darray(Mto_Table,i,5);
      weight = weight + part_weight;
   }
   return(weight);
}

get_label_table()
{
   /*初始化标注全局数组*/
   Label_Number = Mto_Number + Connection_Label_Number + Assembly_Label_Number;
   free_2darray(Label_Table);
   Label_Table = alloc_2darray(Label_Number,4);

   /*将零件编号标注加入到标注全局数组*/
   start = 0;
   for(i=0;i<Mto_Number;i=i+1;){
      put_2darray(Label_Table,start,0,"MTO");
      label = get_2darray(Mto_Label_Table,i,0);
      put_2darray(Label_Table,start,1,label);
      /*获取三维点的坐标*/
      x = get_2darray(Mto_Label_Table,i,1);
      y = get_2darray(Mto_Label_Table,i,2);
      z = get_2darray(Mto_Label_Table,i,3);
      u = String_To_Int(x);
      v = String_To_Int(y);
      w = String_To_Int(z);
      /*将三维坐标转换成平面坐标*/
      view_h = A_GET(View_Handles,3);
      Translate_3D_To_2D(view_h,View_Scale,View4_X,View4_Y,u,v,w);
      put_2darray(Label_Table,start,2,u);
      put_2darray(Label_Table,start,3,v);
      start = start + 1;
   }

   /*将连接点编号标注加入到标注全局数组*/
   for(i=0;i<Connection_Label_Number;i=i+1;){
   /*for(i=0;i<2;i=i+1;){*/
      put_2darray(Label_Table,start,0,"CON");
      label = get_2darray(Connection_Label_Table,i,0);
      put_2darray(Label_Table,start,1,label);
      /*获取三维点的坐标*/
      x = get_2darray(Connection_Label_Table,i,1);
      y = get_2darray(Connection_Label_Table,i,2);
      z = get_2darray(Connection_Label_Table,i,3);
      /*将三维坐标转换成平面坐标*/
      view_h = A_GET(View_Handles,3);
      Translate_3D_To_2D(view_h,View_Scale,View4_X,View4_Y,x,y,z);
      put_2darray(Label_Table,start,2,x);
      put_2darray(Label_Table,start,3,y);
      start = start + 1;
   }

   /*将装配编号标注加入到标注全局数组*/
   for(i=0;i<Assembly_Label_Number;i=i+1;){
      put_2darray(Label_Table,start,0,"ASS");
      label = get_2darray(Assembly_Label_Table,i,0);
      put_2darray(Label_Table,start,1,label);
      /*获取三维点的坐标*/
      x = get_2darray(Assembly_Label_Table,i,1);
      y = get_2darray(Assembly_Label_Table,i,2);
      z = get_2darray(Assembly_Label_Table,i,3);
      /*将三维坐标转换成平面坐标*/
      view_h = A_GET(View_Handles,3);
      Translate_3D_To_2D(view_h,View_Scale,View4_X,View4_Y,x,y,z);
      put_2darray(Label_Table,start,2,x);
      put_2darray(Label_Table,start,3,y);
      start = start + 1;
   }

   return(0);
}

draw_label()
{
   /*计算视图每一个边最多的标注个数及间隔*/
   int label_number_per_side;
   label_number_per_side = Label_Number / 4;
   less_number = Label_Number - label_number_per_side * 4;
   if(less_number != 0){
      label_number_per_side = label_number_per_side + 1;
   }

   if(label_number_per_side < 8){
      label_number_per_side = 8;
   }

   gap = View_Size / label_number_per_side;


   /*创建一个数组，用于保存可能的标注位置*/
   temp = alloc_2darray(4*label_number_per_side,3);
   /*初始化相关变量*/
   x1 = View4_X - View_Size / 2;
   x2 = View4_X + View_Size / 2;
   y1 = View4_Y - View_Size / 2;
   y2 = View4_Y + View_Size / 2;
   position_number = 0;
   for(i=0;i<label_number_per_side;i=i+1;){
      /*视图下部*/
      x = x1 + i * gap;
      y = y1;
      put_2darray(temp,position_number,0,"YES");
      put_2darray(temp,position_number,1,x);
      put_2darray(temp,position_number,2,y);
      position_number = position_number + 1;
      /*视图右侧*/
      x = x2;
      y = y1 + i * gap;
      put_2darray(temp,position_number,0,"YES");
      put_2darray(temp,position_number,1,x);
      put_2darray(temp,position_number,2,y);
      position_number = position_number + 1;
      /*视图上部*/
      x = x2 - i * gap;
      y = y2;
      put_2darray(temp,position_number,0,"YES");
      put_2darray(temp,position_number,1,x);
      put_2darray(temp,position_number,2,y);
      position_number = position_number + 1;
      /*视图左侧*/
      x = x1;
      y = y2 - i * gap;
      put_2darray(temp,position_number,0,"YES");
      put_2darray(temp,position_number,1,x);
      put_2darray(temp,position_number,2,y);
      position_number = position_number + 1;
   }

   /*开始标注*/
   style_name = "";
	drafting_style = GetFirstDraftingStyle(style_name);
   dw = PM_START_PAGE_ANNOTATION(style_name);
   DW_ACTIVATEVIEW(dw);

   /*初始化标注标志*/
   label_mark = A_ALLOC(Label_Number);
   for(i=0;i<Label_Number;i=i+1;){
      A_PUT(label_mark,i,"YES");
   }

   /*循环查找距离最近的标注点和标注位置*/
   loop_mark = 1;
   while(loop_mark)
   {
      /*循环查找离标注点最近的标注位置，并将其写在获得的标注位置上*/
      label_sequence = -1000;
      position_sequence = -1000;
      min_dis = 10000000;
      for(i=0;i<Label_Number;i=i+1;){
         check = A_GET(label_mark,i);
         if(check == "YES"){
            x0 = get_2darray(Label_Table,i,2);
            y0 = get_2darray(Label_Table,i,3);
            for(j=0;j<4*label_number_per_side;j=j+1;){
               flag = get_2darray(temp,j,0);
               if(flag == "YES"){
                  x1 = get_2darray(temp,j,1);
                  y1 = get_2darray(temp,j,2);
                  u = x1 - x0;
                  v = y1 - y0;
                  distance = SQRT(u*u + v*v);
                  if(distance<min_dis){
                     min_dis = distance;
                     label_sequence = i;
                     position_sequence = j;
                  }
               }
            }
         }

      }
      if(label_sequence != -1000 & position_sequence != -1000){
         /*获取标注内容、标注点位置并设置标志*/
         A_PUT(label_mark,label_sequence,"NO");
         type = get_2darray(Label_Table,label_sequence,0);
         label = get_2darray(Label_Table,label_sequence,1);
         x0 = get_2darray(Label_Table,label_sequence,2);
         y0 = get_2darray(Label_Table,label_sequence,3);

         /*获取标注位置并设置标志*/
         put_2darray(temp,position_sequence,0,"NO");
         x = get_2darray(temp,position_sequence,1);
         y = get_2darray(temp,position_sequence,2);

         /*根据不同的标准类型执行不同的标注*/
         if(type == "MTO"){
            draw_mto_label(label,x,y,x0,y0);
         }
         else if(type == "CON"){
            draw_connection_label(label,x,y,x0,y0);
         }
         else if(type == "ASS"){
            draw_assembly_label(label,x,y,x0,y0);
         }
      }
      else{
         loop_mark=0;
      }
   }

   PM_TERMINATE_PAGE_ANNOTATION(1);
   return(0);
}

draw_mto_label(label,x0,y0,x1,y1)
{
   r = Mto_Label_Circle_Radius;
   DW_COLOR(Mto_Label_Text_Colour);
	DW_TSIZE(Mto_Label_Text_Height);
	DW_TATTR(0.0,0.0,5);
	DW_TEXT(label,x0,y0);
	DW_COLOR(Mto_Label_Leader_Line_Colour);
	DW_LTYPE(Mto_Label_Leader_Line_Type,Mto_Label_Leader_Line_PattenLength);
	DW_ARC(x0-r,y0,x0,y0,x0-r,y0);
	x_diff = x0-x1;
	y_diff = y0-y1;
	len = SQRT(x_diff*x_diff+y_diff*y_diff);
	x2 = x0 + Mto_Label_Circle_Radius*(x1-x0)/len;
	y2 = y0 + Mto_Label_Circle_Radius*(y1-y0)/len;
	DW_POLY(x2,y2,x1,y1);
	return(0);
}

draw_connection_label(label,x0,y0,x01,y01)
{
   InitDrawingSettings();

   DW_COLOR(Connection_Label_Text_Colour);
	DW_TSIZE(Connection_Label_Text_Height);
	DW_TATTR(0.0,0.0,5);
	DW_TEXT(label,x0,y0);
	DW_COLOR(Connection_Label_Leader_Line_Colour);
	DW_LTYPE(Connection_Label_Leader_Line_Type,Connection_Label_Leader_Line_PattenLength);
	nr_char = STRLEN(label);
	length = (nr_char * Connection_Label_Text_Height)/2;
	height = Connection_Label_Text_Height;
	x1 = x0 - length - height/2;
	y1 = y0;
	x2 = x0 - length;
	y2 = y0 + height;
	x3 = x0 + length;
	y3 = y2;
	x4 = x0 + length + height/2;
	y4 = y1;
	x5 = x3;
	y5 = y0 - height;
	x6 = x2;
	y6 = y5;
	DW_POLY(x1,y1,x2,y2);
	DW_POLY(x2,y2,x3,y3);
	DW_POLY(x3,y3,x4,y4);
	DW_POLY(x4,y4,x5,y5);
	DW_POLY(x5,y5,x6,y6);
	DW_POLY(x6,y6,x1,y1);

	if(x01<x1){
	   x = x1;
	   y = y1;
	}
	else if(x01>x4){
	   x = x4;
	   y = y4;
	}
	else{
	   if(y01<y0){
   	   x = x0;
   	   y = y5;
	   }
	   else{
   	   x = x0;
   	   y = y2;
	   }
	}
	DW_POLY(x,y,x01,y01);
   return(0);
}

draw_assembly_label(label,x0,y0,x01,y01)
{
   InitDrawingSettings();

   DW_COLOR(Connection_Label_Text_Colour);
	DW_TSIZE(Connection_Label_Text_Height);
	DW_TATTR(0.0,0.0,5);
	DW_TEXT(label,x0,y0);
	DW_COLOR(Connection_Label_Leader_Line_Colour);
	DW_LTYPE(Connection_Label_Leader_Line_Type,Connection_Label_Leader_Line_PattenLength);
	nr_char = STRLEN(label);
	length = (nr_char + 1) * Connection_Label_Text_Height;
	height = Connection_Label_Text_Height;
	x1 = x0 - length/2;
	y1 = y0 + height;
	x2 = x0 + length/2;
	y2 = y1;
	x3 = x2;
	y3 = y0 - height;
	x4 = x1;
	y4 = y3;
	DW_POLY(x1,y1,x2,y2);
	DW_POLY(x2,y2,x3,y3);
	DW_POLY(x3,y3,x4,y4);
	DW_POLY(x4,y4,x1,y1);

	if(x01<x1){
	   if(y01<y4){
   	   x = x4;
   	   y = y4;
	   }
	   else if(y01>y1){
   	   x = x1;
   	   y = y1;
	   }
	   else{
   	   x = x1;
   	   y = y0;
	   }
	}
	else if(x01>x3){
	   if(y01<y4){
   	   x = x3;
   	   y = y3;
	   }
	   else if(y01>y1){
   	   x = x2;
   	   y = y2;
	   }
	   else{
   	   x = x2;
   	   y = y0;
	   }
	}
	else{
	   if(y01<y0){
   	   x = x0;
   	   y = y3;
	   }
	   else{
   	   x = x0;
   	   y = y2;
	   }
	}
	DW_POLY(x,y,x01,y01);
   return(0);
}

/*将管段视图分配到小票图中*/
assign_views_to_drawing()
{
   for(i=0;i<4;i=i+1;){
      view = A_GET(View_Names,i);
      origin_x = get_2darray(View_Positions,i,0);
      origin_y = get_2darray(View_Positions,i,1);
      PM_ASSIGN_VIEW_TO_PAGE(view,origin_x,origin_y,View_Scale);
   }
   return(0);
}

/*获取小票图名称*/
get_drawing_name()
{
   drawing_name = "";
   flag = 1;
   i = 0;
   while(flag){
      drawing_name = Cur_Spool_Name + "-SK" + ITOASCII(i);
      doc_guid = "";
      res = PM_FIND_DRAWING_WITH_NAME(drawing_name,doc_guid);
      if(res <= 0){
         flag = 0;
      }
      i = i + 1;
   }
   return(drawing_name);
}

/*创建小票图*/
create_drawing()
{
    bom_set = PM_INIT_SET();
	header_tag_rec = DM_INIT_TAGREC();
	dname = "";
	icgd_name = Drawing_Form_Name;
    res = PM_CREATE_DRAWING(Cur_Sketch_Name, "PipeSketch", PM_DRW_CFLG_GLOBAL, bom_set, icgd_name, header_tag_rec, dname);
    DM_FREE_TAGREC(header_tag_rec);
    if(res != 0){
        return(-1);
    }

    /*将生成的小票名称写入管段的属性中*/
    Set_Attribute_Value(Current_Spool_Handle,Tag_Sketch_Name,Cur_Sketch_Name);
    PM_SAVE(0,1,1);

    /*将生成的小票名称显示在格栅中*/
    id = find_spool_grid_id(Current_Spool_Handle);
    if(id != -1){
        W_SET_WINDOW_ARGS(DisplayGrid,W_LISTW_FINDID,id);
        row = W_GET_WINDOW_ARG(DisplayGrid,W_LISTW_ROW);
        W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_ROW, row, W_LISTW_COLUMN, 2, W_LISTW_STRING, Cur_Sketch_Name);
    }

    /*将小票生成的日期显示到格栅中*/
    date_string = Get_Creation_Date(Cur_Sketch_Name);
    if(!ISINT(date_string)){
        W_SET_WINDOW_ARGS(DisplayGrid, W_LISTW_ROW, row, W_LISTW_COLUMN, 3, W_LISTW_STRING, date_string);
    }
    return(0);
}

find_spool_grid_id(handle spool_handle)
{
   for(i=0;i<Object_Number;i=i+1;){
      obj_handle = PM_GET_MEMBER_IN_SET(Object_List,i);
      if(spool_handle == obj_handle){
         return(i);
      }
   }
   return(-1);
}

/* 计算管段各个视图的相关参数并保存到全局数组中
   0.    ViewName       视图的名称后缀
   1~3.  Point          视图视点位置
   4~6.  Vdir           视图方向(应该是视向的反方向)
   7~9.  Vup            视图的向上方向
*/
get_spool_view_para()
{
   /* 获取管段所占的三维空间 */
   xmin = 0; ymin = 0; zmin = 0;xmax = 0;ymax = 0;zmax = 0;
   res = PM_GET_BBOX_OF_SET(Cur_Spool_Model_Set,xmin,xmax, ymin,ymax, zmin,zmax);
   if(res == -1){
      message = "无法计算管段:" + Cur_Spool_Name + "所占的三维空间范围,无法生成管段";
      U_MESSAGE(message);
      return(-1);
   }

   if(Have_Double_Plate){
      x1min = 0; y1min = 0; z1min = 0;x1max = 0;y1max = 0;z1max = 0;
      res = PM_GET_BBOX_OF_SET(Double_Plate_Set,x1min,x1max, y1min,y1max, z1min,z1max);
      if(x1min<xmin){
         xmin=x1min;
      }
      if(x1max>xmax){
         xmax = x1max;
      }
      if(y1min<ymin){
         ymin=y1min;
      }
      if(y1max>ymax){
         ymax = y1max;
      }
      if(z1min<zmin){
         zmin=z1min;
      }
      if(z1max>zmax){
         zmax = z1max;
      }
   }

   /*为了使视图的可见性更好,特别是管段只有一个直管时，将视图范围稍为放大一点*/
   xmin=xmin-100;
   ymin=ymin-100;
   zmin=zmin-100;
   xmax=xmax+100;
   ymax=ymax+100;
   zmax=zmax+100;

   /* 计算视图比例 */
   length_x = xmax-xmin;
   length_y = ymax-ymin;
   length_z = zmax-zmin;
   xx = length_x*length_x;
   yy = length_y*length_y;
   zz = length_z*length_z;
   length = SQRT(xx+yy+zz);
   View_Scale = length/View_Size;

   free_2darray(View_Info);
   View_Info = alloc_2darray(4,15);
   /* 设置视图名称后缀 */
   /*
   view_name = Cur_Sketch_Name + "-V1";
   put_2darray(View_Info,0,0,view_name);
   view_name = Cur_Sketch_Name + "-V2";
   put_2darray(View_Info,1,0,view_name);
   view_name = Cur_Sketch_Name + "-V3";
   put_2darray(View_Info,2,0,view_name);
   view_name = Cur_Sketch_Name + "-V4";
   put_2darray(View_Info,3,0,view_name);
   */
   view_name = "Side";
   put_2darray(View_Info,0,0,view_name);
   view_name = "Front";
   put_2darray(View_Info,1,0,view_name);
   view_name = "Top";
   put_2darray(View_Info,2,0,view_name);
   view_name = "ISO1";
   put_2darray(View_Info,3,0,view_name);
   /* 计算视图视点位置 */
   view_point_x = (xmax - xmin)/2+xmin;
   view_point_y = ymin;
   view_point_z = (zmax - zmin)/2+zmin;
   put_2darray(View_Info,0,1,view_point_x);
   put_2darray(View_Info,0,2,view_point_y);
   put_2darray(View_Info,0,3,view_point_z);
   view_point_x = xmin;
   view_point_y = (ymax - ymin)/2+ymin;
   view_point_z = (zmax - zmin)/2+zmin;
   put_2darray(View_Info,1,1,view_point_x);
   put_2darray(View_Info,1,2,view_point_y);
   put_2darray(View_Info,1,3,view_point_z);
   view_point_x = (xmax - xmin)/2+xmin;
   view_point_y = (ymax - ymin)/2+ymin;
   view_point_z = zmax;
   put_2darray(View_Info,2,1,view_point_x);
   put_2darray(View_Info,2,2,view_point_y);
   put_2darray(View_Info,2,3,view_point_z);
   /* 计算视图视向 */
   view_dir_x = 0;
   view_dir_y = -1;
   view_dir_z = 0;
   put_2darray(View_Info,0,4,view_dir_x);
   put_2darray(View_Info,0,5,view_dir_y);
   put_2darray(View_Info,0,6,view_dir_z);
   view_dir_x = -1;
   view_dir_y = 0;
   view_dir_z = 0;
   put_2darray(View_Info,1,4,view_dir_x);
   put_2darray(View_Info,1,5,view_dir_y);
   put_2darray(View_Info,1,6,view_dir_z);
   view_dir_x = 0;
   view_dir_y = 0;
   view_dir_z = 1;
   put_2darray(View_Info,2,4,view_dir_x);
   put_2darray(View_Info,2,5,view_dir_y);
   put_2darray(View_Info,2,6,view_dir_z);
   /* 计算视图向上方向 */
   view_up_dir_x = 0;
   view_up_dir_y = 0;
   view_up_dir_z = 1;
   put_2darray(View_Info,0,7,view_up_dir_x);
   put_2darray(View_Info,0,8,view_up_dir_y);
   put_2darray(View_Info,0,9,view_up_dir_z);
   view_up_dir_x = 0;
   view_up_dir_y = 0;
   view_up_dir_z = 1;
   put_2darray(View_Info,1,7,view_up_dir_x);
   put_2darray(View_Info,1,8,view_up_dir_y);
   put_2darray(View_Info,1,9,view_up_dir_z);
   view_up_dir_x = 0;
   view_up_dir_y = 1;
   view_up_dir_z = 0;
   put_2darray(View_Info,2,7,view_up_dir_x);
   put_2darray(View_Info,2,8,view_up_dir_y);
   put_2darray(View_Info,2,9,view_up_dir_z);
   /* 计算视图空间范围 */
   view_umin = -(xmax-xmin)/2;
   view_umax = (xmax-xmin)/2;
   view_vmin = -(zmax-zmin)/2;
   view_vmax = (zmax-zmin)/2;
   view_depth = ymax-ymin;
   put_2darray(View_Info,0,10,view_umin);
   put_2darray(View_Info,0,11,view_umax);
   put_2darray(View_Info,0,12,view_vmin);
   put_2darray(View_Info,0,13,view_vmax);
   put_2darray(View_Info,0,14,view_depth);
   view_umin = -(ymax-ymin)/2;
   view_umax = (ymax-ymin)/2;
   view_vmin = -(zmax-zmin)/2;
   view_vmax = (zmax-zmin)/2;
   view_depth = xmax-xmin;
   put_2darray(View_Info,1,10,view_umin);
   put_2darray(View_Info,1,11,view_umax);
   put_2darray(View_Info,1,12,view_vmin);
   put_2darray(View_Info,1,13,view_vmax);
   put_2darray(View_Info,1,14,view_depth);
   view_umin = -(xmax-xmin)/2;
   view_umax = (xmax-xmin)/2;
   view_vmin = -(ymax-ymin)/2;
   view_vmax = (ymax-ymin)/2;
   view_depth = zmax-zmin;
   put_2darray(View_Info,2,10,view_umin);
   put_2darray(View_Info,2,11,view_umax);
   put_2darray(View_Info,2,12,view_vmin);
   put_2darray(View_Info,2,13,view_vmax);
   put_2darray(View_Info,2,14,view_depth);
   /* 计算三维视图的相关参数 */
   rot = AxoRotAngle;
   slope = AxoSlopeAngle;
   vpx=0;vpy=0;vpz=0;vdx=0;vdy=0;vdz=0;udx=0;udy=0;udz=0;umin=0;vmin=0;umax=0;vmax=0;depth=0;
   compute_axo_params(rot, slope, xmin,xmax, ymin,ymax, zmin, zmax, vpx, vpy, vpz, vdx, vdy, vdz, udx, udy, udz, umin, vmin, umax, vmax, depth);
   /*三维视图的视点*/
   put_2darray(View_Info,3,1,vpx);
   put_2darray(View_Info,3,2,vpy);
   put_2darray(View_Info,3,3,vpz);
   /*三维视图的视向*/
   put_2darray(View_Info,3,4,vdx);
   put_2darray(View_Info,3,5,vdy);
   put_2darray(View_Info,3,6,vdz);
   /*三维视图的向上方向*/
   put_2darray(View_Info,3,7,udx);
   put_2darray(View_Info,3,8,udy);
   put_2darray(View_Info,3,9,udz);
   /* 三维视图的空间范围 */
   put_2darray(View_Info,3,10,umin);
   put_2darray(View_Info,3,11,umax);
   put_2darray(View_Info,3,12,vmin);
   put_2darray(View_Info,3,13,vmax);
   put_2darray(View_Info,3,14,depth);
}

/*
	Compute axo view params.
	The code is borrowed from DefViews.mac

	Input args; rot, slope, xmin,xmax, ymin,ymax, zmin, zmax
	Output args: vpx, vpy, vpz, vdx, vdy, vdz, umin, vmin, umax, vmax, depth
*/

compute_axo_params(rot, slope, xmin,xmax, ymin,ymax, zmin, zmax,
	vpx, vpy, vpz, vdx, vdy, vdz, udx, udy, udz, umin, vmin, umax, vmax, depth  )
{
	xxmin = xmin;
	xxmax= xmax;
	yymin= ymin;
	yymax= ymax;
	zzmin= zmin;
	zzmax= zmax;

	set_m_x = (xxmin+xxmax)/2;
	set_m_y = (yymin+yymax)/2;
	set_m_z = (zzmin+zzmax)/2;

	xx2=(xxmax - xxmin)*(xxmax - xxmin);
	yy2=(yymax - yymin)*(yymax - yymin);
	zz2=(zzmax - zzmin)*(zzmax - zzmin);

	mbb_diag = SQRT( xx2+ yy2+ zz2);

    vdx = COS(rot)*COS(slope);
    vdy = SIN(rot)*COS(slope);
    vdz = SIN(slope);

    udx = COS(rot)*COS(slope+90);
    udy = SIN(rot)*COS(slope+90);
    udz = SIN(slope+90);

    /*
    if( DEBUG )U_MESSAGE("rot "+FTOASCII(rot)+" slope "+FTOASCII(slope)+"vd "
    	+FTOASCII(vdx)+", "+FTOASCII(vdy)+", "+FTOASCII(vdz));
    	*/

	/*
		Position view point on the surface of a sphere with radius long enough so that
		the front plane does not clip objects in the active set.
	*/

	vpx = set_m_x + vdx*(mbb_diag/2 + 100);
	vpy = set_m_y + vdy*(mbb_diag/2 + 100);
	vpz = set_m_z + vdz*(mbb_diag/2 + 100);

	d = mbb_diag/2 + 100;

	/* Use default limits for axo view */
	umin = -d; umax = d; vmin = -d; vmax = d; depth = mbb_diag + 200;

	return(0);
}

/*创建管段视图*/
create_view()
{
   get_spool_view_para();
   View_Handles = A_ALLOC(4);
   View_Names = A_ALLOC(4);
   for(i=0;i<4;i=i+1;){
      view_name = get_2darray(View_Info,i,0);
      A_PUT(View_Names,i,view_name);
      screen = "";
      display = "";
      in_drawing = 1;
      view_handle = PM_CREATE_VIEW(view_name,in_drawing, screen, display);
      set_view_parameter(view_handle,i);
      PM_VISUALIZE_SET_TO_VIEW(Cur_Spool_Model_Set,view_handle);
      if(Have_Double_Plate){
         res = PM_REVISUALIZE_SET_TO_VIEW(Double_Plate_Set,view_handle);
      }
      A_PUT(View_Handles,i,view_handle);
   }
   return(0);
}

/*设置管段视图的参数*/
set_view_parameter(handle view_handle,int i)
{
   /* 设置视点 */
   view_point_x = get_2darray(View_Info,i,1);
   view_point_y = get_2darray(View_Info,i,2);
   view_point_z = get_2darray(View_Info,i,3);
   PM_SET_VIEW_PARAMETERS(view_handle, "POINT", view_point_x,view_point_y,view_point_z);
   /* 设置视向 */
   view_dir_x = get_2darray(View_Info,i,4);
   view_dir_y = get_2darray(View_Info,i,5);
   view_dir_z = get_2darray(View_Info,i,6);
   PM_SET_VIEW_PARAMETERS(view_handle, "VDIR", view_dir_x,view_dir_y,view_dir_z);
   /* 设置视向上方向 */
   view_up_dir_x = get_2darray(View_Info,i,7);
   view_up_dir_y = get_2darray(View_Info,i,8);
   view_up_dir_z = get_2darray(View_Info,i,9);
   PM_SET_VIEW_PARAMETERS(view_handle, "VUP", view_up_dir_x,view_up_dir_y,view_up_dir_z);
   /* 设置视向上方向 */
   umin = get_2darray(View_Info,i,10);
   umax = get_2darray(View_Info,i,11);
   vmin = get_2darray(View_Info,i,12);
   vmax = get_2darray(View_Info,i,13);
   depth = get_2darray(View_Info,i,14);
   PM_SET_VIEW_PARAMETERS(view_handle, "LIMITS", umin, umax, vmin, vmax, depth);
   /*设置视图中是否显示隔热层*/
   PM_SET_VIEW_PARAMETERS(view_handle, "SHOW_INSULATION", 0);

   return(0);
}

/*将管段主管及分支的零件按顺序排好*/
sort_spool_branch()
{

   /*获取管段pipe的数量*/
   pipe_number = PM_NR_MEMBERS_IN_SET(Cur_Spool_Model_Set);
   /*创建一个临时数组用于保存各个pipe在管段中所在的分支及其顺序*/
   /*0 - pipe在管段中的分支序号，主管为0
   **1 - pipe在管段分支中的顺序号，从0开始编号，只有主管上的pipe会有这个编号（支管不允许再开支管）；
   **2 - pipe的方向标识，0 - 安照正常的方向，1 - 反向；
   */
   mark = alloc_2darray(pipe_number,3);
   /*初始化数组*/
   for(i=0;i<pipe_number;i=i+1;){
      for(j=0;j<3;j=j+1;){
         put_2darray(mark,i,j,10000);
      }
   }

   /*如果只有一个pipe，则管段没有支管*/
   if(pipe_number == 1){
      pipe = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,0);
      Spool_Branch_Number = 1;
      Main_Branch_Pipe_Number = 1;
      free_2darray(Spool_Branch);
      Spool_Branch = alloc_2darray(1,1);
      put_2darray(Spool_Branch,0,0,pipe);

      free_2darray(Spool_Branch_Direction);
      Spool_Branch_Direction = alloc_2darray(1,1);
      put_2darray(Spool_Branch_Direction,0,0,0);

      return(0);
   }
   /*如果有多个pipe，则管段可能有支管*/
   else{
      /*循环查找管段中连接点最多的pipe*/
      /*如果直管上带有多个的贯通件或者管夹，则这个方法不一定是正确的*/
      main_pipe_sequ = 0;
      max_connection = 0;
      for(i=0;i<pipe_number;i=i+1;){
         pipe = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,i);
         /*管子带贯通件时，因为贯通件有三个连接点，如果主管也只有三个连接点，有可能会把贯通件当成主管*/
         pipe_part_number = PM_NR_PARTS_IN_PIPE(pipe);
         if(pipe_part_number != -1){
            conn_number = PM_GET_NR_OF_CONPNTS(pipe);
            if(conn_number > max_connection){
               main_pipe_sequ = i;
               max_connection = conn_number;
            }
         }
      }

      main_number = 10;
      forward_number = main_number;
      backward_number = main_number;

      /*记住主管的pipe序号*/
      put_2darray(mark,main_pipe_sequ,0,0);
      put_2darray(mark,main_pipe_sequ,1,main_number);
      put_2darray(mark,main_pipe_sequ,2,0);
      /*查找主管的首尾连接对象，如果连接的对象属于当前管段，则连接的对象为属于主管的pipe*/

      head = NULL_HANDLE;
      tail = NULL_HANDLE;
      node_id1 = 0;
      main_pipe = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,main_pipe_sequ);
      connected_obj = PM_GET_CONNECTED_OBJECT(main_pipe, 1, node_id1);
      if(!ISINT(connected_obj)){
         flag = belong_to_spool(connected_obj);
         if(flag){
            head = connected_obj;
         }
      }

      node_id2 = 0;
      connected_obj = PM_GET_CONNECTED_OBJECT(main_pipe, 2, node_id2);
      if(!ISINT(connected_obj)){
         flag = belong_to_spool(connected_obj);
         if(flag){
            tail = connected_obj;
         }
      }

      /*如果主管的首端连接到本管段的其它pipe或者Standard component,则需要将其插入到当前主管的前面的位置*/
      while(head != NULL_HANDLE){
         main_pipe = head;
         sequ = get_pipe_sequence(head);
         forward_number = forward_number - 1;
         put_2darray(mark,sequ,0,0);
         put_2darray(mark,sequ,1,forward_number);
         if(node_id1 == 1){
            connected_obj = PM_GET_CONNECTED_OBJECT(main_pipe, 2, node_id1);
            put_2darray(mark,sequ,2,1);
         }
         else{
            connected_obj = PM_GET_CONNECTED_OBJECT(main_pipe, 1, node_id1);
            put_2darray(mark,sequ,2,0);
         }
         if(!ISINT(connected_obj)){
            flag = belong_to_spool(connected_obj);
            if(flag){
               head = connected_obj;
            }
         }
         /*如果向前已经找不到在主管上的pipe,则设置相关标识，退出循环*/
         if (main_pipe == head){
            head = NULL_HANDLE;
         }
      }

      /*如果主管的末端连接到本管段的其它pipe或者Standard component,则需要将其插入到当前主管的后面的位置*/
      while(tail != NULL_HANDLE){
         main_pipe = tail;
         sequ = get_pipe_sequence(tail);
         backward_number = backward_number + 1;
         put_2darray(mark,sequ,0,0);
         put_2darray(mark,sequ,1,backward_number);
         if(node_id2 == 1){
            connected_obj = PM_GET_CONNECTED_OBJECT(main_pipe, 2, node_id2);
            put_2darray(mark,sequ,2,0);
         }
         else{
            connected_obj = PM_GET_CONNECTED_OBJECT(main_pipe, 1, node_id2);
            put_2darray(mark,sequ,2,1);
         }
         if(!ISINT(connected_obj)){
            flag = belong_to_spool(connected_obj);
            if(flag){
               tail = connected_obj;
            }
         }
         /*如果向前已经找不到在主管上的pipe,则设置相关标识，退出循环*/
         if (main_pipe == tail){
            tail = NULL_HANDLE;
         }
      }

      /*根据主管的pipe的连接点寻找对应的支管，并对其进行排序
      --这个算法会漏掉连接在支管末端的套管（standard component)
      */
      branch_number = 1;
      for(i=forward_number;i<=backward_number;i=i+1;){
         for(j=0;j<pipe_number;j=j+1;){
            branch_sequ = get_2darray(mark,j,0);
            pipe_sequ = get_2darray(mark,j,1);
            if(branch_sequ == 0 & pipe_sequ == i){
               main_pipe = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,j);
               conn_number = PM_GET_NR_OF_CONPNTS(main_pipe);
               /*如果连接数大于2，则这个主管上的pipe可能连接了支管*/
               if(conn_number>2){
                  node_id = 0;
                  for(k=3;k<=conn_number;k=k+1){
                     connected_obj = PM_GET_CONNECTED_OBJECT(main_pipe, k, node_id);
                     /*如果连接对象存在，判断是否属于当前管段，如果是，则应该是支管*/
                     if(!ISINT(connected_obj)){
                        flag = belong_to_spool(connected_obj);
                        if(flag){
                           branch = connected_obj;
                           pipe_sequ = get_pipe_sequence(branch);
                           put_2darray(mark,pipe_sequ,0,branch_number);
                           if(node_id == 1){
                              put_2darray(mark,pipe_sequ,2,0);
                           }
                           else{
                              put_2darray(mark,pipe_sequ,2,1);
                           }
                           branch_number = branch_number + 1;
                        }
                     }
                  }
               }
            }
         }
      }

      /*修改正支管末端的套管问题（standard component)*/
      for(i=0;i<pipe_number;i=i+1){
         branch_sequ = get_2darray(mark,i,0);
         if(branch_sequ == 10000){
            put_2darray(mark,i,0,branch_number);
            branch_number = branch_number + 1;
         }
      }


      /* 修正主管末端的套管问题(主管末端带一个标准零件的套管的时候套管会丢失)*/

      fix_sleeve = 0;
      /*
      if(pipe_number == 2){
         pipe1 = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,0);
         pipe1_part_number = PM_NR_PARTS_IN_PIPE(pipe1);
         if(pipe1_part_number == -1){
      		fix_sleeve = 1;
				branch_sequ = get_2darray(mark,0,0);
				if(branch_sequ != 0){
					put_2darray(mark,0,0,0);
					pipe_sequ = get_2darray(mark,1,1) + 1;
					put_2darray(mark,0,1,pipe_sequ);
				}
				branch_number = 1;
         }
         pipe2 = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,1);
         pipe2_part_number = PM_NR_PARTS_IN_PIPE(pipe2);
         if(pipe2_part_number == -1){
         	fix_sleeve = 1;
				branch_sequ = get_2darray(mark,1,0);
				if(branch_sequ != 0){
					put_2darray(mark,1,0,0);
					pipe_sequ = get_2darray(mark,0,1) + 1;
					put_2darray(mark,1,1,pipe_sequ);
				}
				branch_number = 1;
         }
      }
      */

      /*下面的代码用于显示各个pipe所属的分支及其序号*/
      if(Debug){
         U_MESSAGE("************************管段上各个PIPE及其分支顺序***************************");
         for(i=0;i<pipe_number;i=i+1;){
            s1 = get_2darray(mark,i,0);
            s2 = get_2darray(mark,i,1);
            mess = ITOASCII(i) + "--" + ITOASCII(s1) + "--" + ITOASCII(s2);
            U_MESSAGE(mess);
         }
         U_MESSAGE("管段分支数量" + ITOASCII(branch_number));
      }


      /*将SPOOL各个分支的pipe按照其顺序保存到全局变量中*/
      Spool_Branch_Number = branch_number;
      Main_Branch_Pipe_Number = backward_number - forward_number + 1;
      if(fix_sleeve){
      	Main_Branch_Pipe_Number = 2;
	      free_2darray(Spool_Branch);
	      Spool_Branch = alloc_2darray(Spool_Branch_Number,Main_Branch_Pipe_Number);
	      free_2darray(Spool_Branch_Direction);
	      Spool_Branch_Direction = alloc_2darray(Spool_Branch_Number,Main_Branch_Pipe_Number);
	      for(i=0;i<pipe_number;i=i+1;){
	         pipe = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,i);
	         branch_number = get_2darray(mark,i,0);
	         sequ_number = get_2darray(mark,i,1);
	         direction = get_2darray(mark,i,2);
	         if(branch_number==0){
	         	forward_number = get_2darray(mark,1,1);
	            sequ = sequ_number - forward_number;
	            put_2darray(Spool_Branch,branch_number,sequ,pipe);
	            put_2darray(Spool_Branch_Direction,branch_number,sequ,direction);
	         }
	         else{
	            put_2darray(Spool_Branch,branch_number,0,pipe);
	            put_2darray(Spool_Branch,branch_number,0,pipe);
	            put_2darray(Spool_Branch_Direction,branch_number,0,direction);
	         }
	      }
      }
      else{
	      free_2darray(Spool_Branch);
	      Spool_Branch = alloc_2darray(Spool_Branch_Number,Main_Branch_Pipe_Number);
	      free_2darray(Spool_Branch_Direction);
	      Spool_Branch_Direction = alloc_2darray(Spool_Branch_Number,Main_Branch_Pipe_Number);
	      for(i=0;i<pipe_number;i=i+1;){
	         pipe = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,i);
	         branch_number = get_2darray(mark,i,0);
	         sequ_number = get_2darray(mark,i,1);
	         direction = get_2darray(mark,i,2);
	         if(branch_number==0){
	            sequ = sequ_number - forward_number;
	            put_2darray(Spool_Branch,branch_number,sequ,pipe);
	            put_2darray(Spool_Branch_Direction,branch_number,sequ,direction);
	         }
	         else{
	            put_2darray(Spool_Branch,branch_number,0,pipe);
	            put_2darray(Spool_Branch,branch_number,0,pipe);
	            put_2darray(Spool_Branch_Direction,branch_number,0,direction);
	         }
	      }
	   }
      return(0);
   }
   return(0);
}


/*检查连接的对象是否属于当前管段*/
belong_to_spool(handle pipe_handle)
{
   /*获取管段pipe的数量*/
   pipe_number = PM_NR_MEMBERS_IN_SET(Cur_Spool_Model_Set);
   for(i=0;i<pipe_number;i=i+1){
      pipe = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,i);
      if(pipe == pipe_handle){
         return(1);
      }
   }
   return(0);
}

get_pipe_sequence(handle pipe_handle)
{
   /*获取管段pipe的数量*/
   pipe_number = PM_NR_MEMBERS_IN_SET(Cur_Spool_Model_Set);
   for(i=0;i<pipe_number;i=i+1){
      pipe = PM_GET_MEMBER_IN_SET(Cur_Spool_Model_Set,i);
      if(pipe == pipe_handle){
         return(i);
      }
   }
   return(0);
}

/*获取管段零件表信息及零件号标注相关信息*/
/*零件表内容
1 - mto number       零件编号
2 - quantity         长度或者数量
3 - unit             单位
4 - description      零件描述
5 - cutting Length   下料长度
6 - Weight           重量
*/
/*零件标注信息内容
1 - part number   零件编号
2 - anno_x        零件标注点X坐标
3 - anno_y        零件标注点Y坐标
4 - anno_z        零件标注点Z坐标
*/
get_mto_table()
{
   /*定义用于临时保存零件信息的数组*/
   temp_mto = alloc_2darray(Max_Spool_Parts_Number,7);
   temp_anno = alloc_2darray(Max_Spool_Parts_Number,4);
   mto_number = 1;
   continue = 0;
   bent_piece_number = 0;
   /*处理主管零件信息*/
   for(i=0;i<Spool_Part_Number;i=i+1;){
      pipe_handle = get_2darray(Spool_Parts,i,1);
      part_handle = get_2darray(Spool_Parts,i,2);
      nth_part = get_2darray(Spool_Parts,i,3);
      type = get_2darray(Spool_Parts,i,4);
      /*如果零件为开支管的虚拟零件*/
      if(type == "ROOT" | type == "DoublePlate" | type == "PENETRATION"){
         /*如果支管虚拟零件为最后一个零件*/
         if(i == Spool_Part_Number-1){
            continue = 0;
         }
         else{
            branch = get_2darray(Spool_Parts,i,0);
            next_branch = get_2darray(Spool_Parts,i+1,0);
            /*如果支管虚拟零件为所在分支的最后一个零件*/
            if(branch != next_branch){
               continue = 0;
            }
            else{
               next_type = get_2darray(Spool_Parts,i+1,4);
               if(next_type == "ROOT" | next_type == "BEND" | next_type == "DoublePlate" | next_type == "PENETRATION" | type == "HOLE"){
                  continue = 1;
               }
               else{
                  continue = 0;
               }
            }
         }
      }
      else if(type == "TUBE"){
         next_type = get_2darray(Spool_Parts,i+1,4);
         /*管材为弯管中间直段或者最后一个直段*/
         if(continue){
            put_2darray(Spool_Parts,i,5,ITOASCII(mto_number));
            put_2darray(Spool_Parts,i,12,bent_piece_number);
            /*如果直段为最后一个零件*/
            if(i == Spool_Part_Number-1){
               continue = 0;
            }
            else{
               branch = get_2darray(Spool_Parts,i,0);
               next_branch = get_2darray(Spool_Parts,i+1,0);
               /*如果直段为所在分支的最后一个零件*/
               if(branch != next_branch){
                  continue = 0;
               }
               else{
                  if(next_type == "ROOT" | next_type == "BEND"){
                     continue = 1;
                  }
                  else{
                     continue = 0;
                  }
               }
            }
         }
         /*管材为弯管第一个直段或独立的直段*/
         else{
            /*直段为弯管的第一个直段*/
            length = 0;
            is_bent_pipe = get_type_of_bent_part(pipe_handle,nth_part);
            if(is_bent_pipe != -1){
               bent_piece_number = bent_piece_number + 1;
               continue = 1;
               /*零件编号*/
               put_2darray(temp_mto,mto_number-1,0,ITOASCII(mto_number));
               /*管材长度*/
               final_length = get_piece_final_length(pipe_handle,nth_part);
               length_str = "";
               S_PRINTF(length_str, "%d", final_length);
               put_2darray(temp_mto,mto_number-1,1,length_str);
               /*零件单位*/
               put_2darray(temp_mto,mto_number-1,2,"mm");
               /*零件描述*/
               description = get_part_description(pipe_handle,nth_part,type);
               put_2darray(temp_mto,mto_number-1,3,description);
               /*零件下料长度*/
               cutting_length = get_piece_cutting_length(pipe_handle,nth_part);
               length_str = "";
               S_PRINTF(length_str, "%d", cutting_length);
               put_2darray(temp_mto,mto_number-1,4,length_str);
               /*零件重量*/
               weight = PM_GET_OBJDATA(pipe_handle,nth_part,MMT_TAG_MASS);
               weight_f = String_To_Float(weight);
               S_PRINTF(weight,"%.2f",weight_f);
               put_2darray(temp_mto,mto_number-1,5,weight);

               /*标注信息*/
               put_2darray(temp_anno,mto_number-1,0,ITOASCII(mto_number));
               x = FTOASCII(get_2darray(Spool_Parts,i,6));
               y = FTOASCII(get_2darray(Spool_Parts,i,7));
               z = FTOASCII(get_2darray(Spool_Parts,i,8));
               put_2darray(temp_anno,mto_number-1,1,x);
               put_2darray(temp_anno,mto_number-1,2,y);
               put_2darray(temp_anno,mto_number-1,3,z);

               put_2darray(Spool_Parts,i,5,ITOASCII(mto_number));
               put_2darray(Spool_Parts,i,12,bent_piece_number);
               mto_number = mto_number + 1;

            }
            /*管材为一个独立的直段*/
            else{
               /*零件编号*/
               put_2darray(temp_mto,mto_number-1,0,ITOASCII(mto_number));
               /*管材长度*/
               final_length = get_piece_final_length(pipe_handle,nth_part);
               length_str = "";
               S_PRINTF(length_str, "%d", final_length);
               put_2darray(temp_mto,mto_number-1,1,length_str);
               /*零件单位*/
               put_2darray(temp_mto,mto_number-1,2,"mm");
               /*零件描述*/
               description = get_part_description(pipe_handle,nth_part,type);
               put_2darray(temp_mto,mto_number-1,3,description);
               /*零件下料长度*/
               cutting_length = get_piece_cutting_length(pipe_handle,nth_part);
               length_str = "";
               S_PRINTF(length_str, "%d", cutting_length);
               put_2darray(temp_mto,mto_number-1,4,length_str);
               /*零件重量*/
               weight = PM_GET_OBJDATA(pipe_handle,nth_part,MMT_TAG_MASS);
               weight_f = String_To_Float(weight);
               S_PRINTF(weight,"%.2f",weight_f);
               put_2darray(temp_mto,mto_number-1,5,weight);

               /*标注信息*/
               put_2darray(temp_anno,mto_number-1,0,ITOASCII(mto_number));
               x = FTOASCII((get_2darray(Spool_Parts,i,6) + get_2darray(Spool_Parts,i,9)) / 2);
               y = FTOASCII((get_2darray(Spool_Parts,i,7) + get_2darray(Spool_Parts,i,10)) / 2);
               z = FTOASCII((get_2darray(Spool_Parts,i,8) + get_2darray(Spool_Parts,i,11)) / 2);
               put_2darray(temp_anno,mto_number-1,1,x);
               put_2darray(temp_anno,mto_number-1,2,y);
               put_2darray(temp_anno,mto_number-1,3,z);

               put_2darray(Spool_Parts,i,5,ITOASCII(mto_number));
               continue = 0;
               mto_number = mto_number + 1;
            }
         }
      }
      else if(type == "BEND"){
         /*弯头为跟着直管后面的弯头*/
         if(continue){
            put_2darray(Spool_Parts,i,12,bent_piece_number);
            put_2darray(Spool_Parts,i,5,ITOASCII(mto_number));
            /*如果弯头为最后一个零件*/
            if(i == Spool_Part_Number-1){
               continue = 0;
            }
            else{
               branch = get_2darray(Spool_Parts,i,0);
               next_branch = get_2darray(Spool_Parts,i+1,0);
               /*如果弯头为所在分支的最后一个零件*/
               if(branch != next_branch){
                  continue = 0;
               }
               else{
                  if(next_type == "TUBE" | next_type == "BEND" ){
                     continue = 1;
                  }
                  else{
                     continue = 0;
                  }
               }
            }

         }
         /*弯头为弯管的第一个零件*/
         else{
            /*零件编号*/
            put_2darray(temp_mto,mto_number-1,0,ITOASCII(mto_number));
            /*管材长度*/
            final_length = get_piece_final_length(pipe_handle,nth_part);
            length_str = "";
            S_PRINTF(length_str, "%d", final_length);
            put_2darray(temp_mto,mto_number-1,1,length_str);
            /*零件单位*/
            put_2darray(temp_mto,mto_number-1,2,"mm");
            /*零件描述*/
            description = get_part_description(pipe_handle,nth_part,type);
            put_2darray(temp_mto,mto_number-1,3,description);
            /*零件下料长度*/
            cutting_length = get_piece_cutting_length(pipe_handle,nth_part);
            length_str = "";
            S_PRINTF(length_str, "%d", cutting_length);
            put_2darray(temp_mto,mto_number-1,4,length_str);
            /*零件重量*/
            weight = PM_GET_OBJDATA(pipe_handle,nth_part,MMT_TAG_MASS);
            weight_f = String_To_Float(weight);
            S_PRINTF(weight,"%.2f",weight_f);
            put_2darray(temp_mto,mto_number-1,5,weight);

            /*标注信息*/
            put_2darray(temp_anno,mto_number-1,0,ITOASCII(mto_number));
            x = FTOASCII(get_2darray(Spool_Parts,i,6));
            y = FTOASCII(get_2darray(Spool_Parts,i,7));
            z = FTOASCII(get_2darray(Spool_Parts,i,8));
            put_2darray(temp_anno,mto_number-1,1,x);
            put_2darray(temp_anno,mto_number-1,2,y);
            put_2darray(temp_anno,mto_number-1,3,z);

            continue = 0;
            mto_number = mto_number + 1;
         }
      }
      /*除了管材，弯头，支管根部以及开孔管理生成的复板及焊接在管材表面的零件（比如套管）以外其它类型的零件*/
      else{
         continue = 0;
         /*零件编号*/
         put_2darray(temp_mto,mto_number-1,0,ITOASCII(mto_number));
         /*零件数量*/
         put_2darray(temp_mto,mto_number-1,1,"1");
         /*零件单位*/
         put_2darray(temp_mto,mto_number-1,2,"个");
         /*零件描述*/
         pipe = get_2darray(Spool_Parts,i,1);
         nth_part = get_2darray(Spool_Parts,i,3);
         description = get_part_description(pipe,nth_part,type);
         put_2darray(temp_mto,mto_number-1,3,description);
         /*零件下料长度*/
         put_2darray(temp_mto,mto_number-1,4,"0");
         /*零件重量*/
         nth_part = get_2darray(Spool_Parts,i,3);
         weight = PM_GET_OBJDATA(pipe,nth_part,MMT_TAG_MASS);
         weight_f = String_To_Float(weight);
         S_PRINTF(weight,"%.2f",weight_f);
         put_2darray(temp_mto,mto_number-1,5,weight);

         /*标注信息*/
         put_2darray(temp_anno,mto_number-1,0,ITOASCII(mto_number));
         x = FTOASCII(get_2darray(Spool_Parts,i,6));
         y = FTOASCII(get_2darray(Spool_Parts,i,7));
         z = FTOASCII(get_2darray(Spool_Parts,i,8));
         put_2darray(temp_anno,mto_number-1,1,x);
         put_2darray(temp_anno,mto_number-1,2,y);
         put_2darray(temp_anno,mto_number-1,3,z);

         put_2darray(Spool_Parts,i,5,ITOASCII(mto_number));
         mto_number = mto_number + 1;
      }
   }

   /*处理复板及套管等焊接在管材表面的零件*/
   for(i=0;i<Spool_Part_Number;i=i+1;){
      type = get_2darray(Spool_Parts,i,4);
      if(type == "DoublePlate"){
         doubleplate_handle = get_2darray(Spool_Parts,i,2);
         /*零件编号*/
         put_2darray(temp_mto,mto_number-1,0,ITOASCII(mto_number));
         /*零件数量*/
         put_2darray(temp_mto,mto_number-1,1,"1");
         /*零件单位*/
         put_2darray(temp_mto,mto_number-1,2,"个");
         /*零件描述*/
         description = get_doubleplate_description(doubleplate_handle);
         put_2darray(temp_mto,mto_number-1,3,description);
         /*零件下料长度*/
         put_2darray(temp_mto,mto_number-1,4,"0");
         /*零件重量*/
         weight = PM_GET_OBJDATA(doubleplate_handle,0,MMT_TAG_MASS);
         weight_f = String_To_Float(weight);
         S_PRINTF(weight,"%.2f",weight_f);
         put_2darray(temp_mto,mto_number-1,5,weight);

         /*标注信息*/
         put_2darray(temp_anno,mto_number-1,0,ITOASCII(mto_number));
         x = FTOASCII(get_2darray(Spool_Parts,i,6));
         y = FTOASCII(get_2darray(Spool_Parts,i,7));
         z = FTOASCII(get_2darray(Spool_Parts,i,8));
         put_2darray(temp_anno,mto_number-1,1,x);
         put_2darray(temp_anno,mto_number-1,2,y);
         put_2darray(temp_anno,mto_number-1,3,z);

         put_2darray(Spool_Parts,i,5,ITOASCII(mto_number));
         mto_number = mto_number + 1;
      }
      else if(type == "PENETRATION"){
         penetration = get_2darray(Spool_Parts,i,2);
         /*零件编号*/
         put_2darray(temp_mto,mto_number-1,0,ITOASCII(mto_number));
         /*零件数量*/
         put_2darray(temp_mto,mto_number-1,1,"1");
         /*零件单位*/
         put_2darray(temp_mto,mto_number-1,2,"个");
         /*零件描述*/
         description = get_part_description(penetration,0,type);
         put_2darray(temp_mto,mto_number-1,3,description);
         /*零件下料长度*/
         put_2darray(temp_mto,mto_number-1,4,"0");
         /*零件重量*/
         weight = PM_GET_OBJDATA(penetration,0,MMT_TAG_MASS);
         weight_f = String_To_Float(weight);
         S_PRINTF(weight,"%.2f",weight_f);
         put_2darray(temp_mto,mto_number-1,5,weight);

         /*标注信息*/
         put_2darray(temp_anno,mto_number-1,0,ITOASCII(mto_number));
         x = FTOASCII(get_2darray(Spool_Parts,i,6));
         y = FTOASCII(get_2darray(Spool_Parts,i,7));
         z = FTOASCII(get_2darray(Spool_Parts,i,8));
         put_2darray(temp_anno,mto_number-1,1,x);
         put_2darray(temp_anno,mto_number-1,2,y);
         put_2darray(temp_anno,mto_number-1,3,z);

         put_2darray(Spool_Parts,i,5,ITOASCII(mto_number));
         mto_number = mto_number + 1;
      }
   }

   /*初始化材料表全局数组*/
   free_2darray(Mto_Table);
   Mto_Table = alloc_2darray(mto_number - 1,6);
   Mto_Number = mto_number - 1;

   /*将材料表信息从临时数组拷贝到全局数组*/
	for (n = 0; n < mto_number - 1; n = n + 1;){
	   for(m = 0; m < 6; m = m + 1){
	      info = get_2darray(temp_mto,n,m);
	      put_2darray(Mto_Table, n, m, info);
	   }
	}

	if(Debug){
	   U_MESSAGE("*****************材料表内容****************************");
	   for(i=0;i<Mto_Number;i=i+1;){
	      s1 = get_2darray(Mto_Table,i,0);
	      s2 = get_2darray(Mto_Table,i,1);
	      s3 = get_2darray(Mto_Table,i,2);
	      s4 = get_2darray(Mto_Table,i,3);
	      s5 = get_2darray(Mto_Table,i,4);
	      s6 = get_2darray(Mto_Table,i,5);
	      mess = s1 + ";" + s2 + ";" + s3 + ";" + s4 + ";" + s5 + ";" + s6 ;
	      U_MESSAGE(mess);
	   }
	}

	/*初始化材料表标注信息全局数组*/
   free_2darray(Mto_Label_Table);
   Mto_Label_Table = alloc_2darray(Mto_Number,4);

   /*将材料表标注信息从临时数组拷贝到全局数组*/
	for (n = 0; n < Mto_Number; n = n + 1;){
	   for(m = 0; m < 4; m = m + 1){
	      info = get_2darray(temp_anno,n,m);
	      put_2darray(Mto_Label_Table, n, m, info);
	   }
	}

	/*保存弯管数量到全局变量*/
	Bent_Piece_Number = bent_piece_number;

	/*释放临时数组的资源*/
	free_2darray(temp_mto);
	free_2darray(temp_anno);
   return(0);
}

get_doubleplate_description(doubleplate_handle)
{
   return("复板");
}

/*将各个Branch的零件按照顺序排好，对支管根部，直接用一个虚拟零件代替*/
/*管支架的管夹是以STANDARD COMPONENT的形式加入到管子模型中的，在处理管段时，需要将这些零件去掉*/
/*
1 - int        branch编号;
2 - handle     所属的pipe的handle;
3 - handle     part的handle，如果是虚拟的支管根部，直接用字符串“ROOT”代替;
4 - int        part在pipe中序号,如果是虚拟的支管根部，则为主管对应这个支管的连接点编号;
5 - string     part的类型TUBE,FLANGE,BEND,ELBOW,REDUCER,TEE...;
6 - string     MTO零件编号,初始值为10000;
7 - float      零件编号标注x坐标,如果是直管段，则为直管段的首端x坐标;
8 - float      零件编号标注y坐标,如果是直管段，则为直管段的首端y坐标;
9 - float      零件编号标注z坐标,如果是直管段，则为直管段的首端z坐标;
10- float      尺寸标注x坐标,如果是直管段，则为直管段的末端x坐标;
11- float      尺寸标注y坐标,如果是直管段，则为直管段的末端y坐标;
12- float      尺寸标注z坐标,如果是直管段，则为直管段的末端z坐标;
13- int        Ppiece编号,初始值为10000;
14- string     装配参考信息,初始值为10000;
15- float      Ppiece的首端余量,初始值为10000;
16- float      Ppiece的中间余量,初始值为10000;
17- float      Ppiece的末端余量,初始值为10000;
*/
sort_spool_parts()
{
   /*定义用于临时保存零件信息的数组*/
   spool_parts = alloc_2darray(50,17);
   part_number = 0;
   /*处理主管零件信息*/
   for(i=0;i<Main_Branch_Pipe_Number;i=i+1;){
      pipe = get_2darray(Spool_Branch,0,i);
      branch_part_number = PM_NR_PARTS_IN_PIPE(pipe);

      /* 管路中间插入TEE时，TEE会独立形成一个PIPE，执行这个函数时返回值为-1*/
      /* 直管段上如果添加了诸如套管一类的贯通件，贯通件会独立形成一个PIPE,执行这个函数时返回值为-1*/
      if(branch_part_number == -1){
         branch_part_number=1;
      }
      direction = get_2darray(Spool_Branch_Direction,0,i);
      if(!direction){
         /*循环处理pipe中的零件*/
         for(k=0;k<branch_part_number;k=k+1;){
            part_sequence = k+1;
            part_obj_id = PM_GET_OBJDATA(pipe,part_sequence,MMT_TAG_OBJID);
            part_handle = PM_FIND_BY_OBJID(part_obj_id);
            /*获取零件类型*/
            comp_type = Get_Component_Type(part_handle);
            if(Debug){
               U_MESSAGE("零件类型 - " + comp_type);
            }
            /*除去管夹等属于管支架的零件*/
            if(comp_type != "CLAMP"){
               put_2darray(spool_parts,part_number,0,0);
               put_2darray(spool_parts,part_number,1,pipe);
               put_2darray(spool_parts,part_number,2,part_handle);
               put_2darray(spool_parts,part_number,3,part_sequence);
               if(ISSTRING(comp_type)){
                  put_2darray(spool_parts,part_number,4,comp_type);
               }
               else{
                  put_2darray(spool_parts,part_number,4,"OTHER");
               }
               put_2darray(spool_parts,part_number,5,10000);
               /*获取零件零件编号标注及尺寸标注的坐标*/
               x0=0;y0=0;z0=0;x1=0;y1=0;z1=0;
               get_part_coordinate(pipe,part_sequence,comp_type,x0,y0,z0,x1,y1,z1);
               put_2darray(spool_parts,part_number,6,x0);
               put_2darray(spool_parts,part_number,7,y0);
               put_2darray(spool_parts,part_number,8,z0);
               put_2darray(spool_parts,part_number,9,x1);
               put_2darray(spool_parts,part_number,10,y1);
               put_2darray(spool_parts,part_number,11,z1);
               put_2darray(spool_parts,part_number,12,10000);
               put_2darray(spool_parts,part_number,13,10000);
               put_2darray(spool_parts,part_number,14,10000);
               put_2darray(spool_parts,part_number,15,10000);
               put_2darray(spool_parts,part_number,16,10000);
               part_number = part_number + 1;
               /*如果零件为直管段，判断是否有支管在这个直管段上，如果有，则将其按照顺序插入到零件清单中*/
               if(comp_type == "TUBE"){
                  if(have_branch(pipe)){
                     insert_branch_root(spool_parts,part_number,pipe,part_sequence);
                  }
               }
               /*如果零件为弯头，判断是否有支管在这个弯头段上，如果有，则将其按照顺序插入到零件清单中*/
               /*
               if(comp_type == "BEND"){
                  if(have_branch(pipe)){
                     insert_bend_branch_root(spool_parts,part_number,pipe,part_sequence);
                  }
               }
               */
            }
         }
      }
      else{
         /*循环处理pipe中的零件*/
         for(k=branch_part_number-1;k>=0;k=k-1;){
            part_sequence = k+1;
            part_obj_id = PM_GET_OBJDATA(pipe,part_sequence,MMT_TAG_OBJID);
            part_handle = PM_FIND_BY_OBJID(part_obj_id);
            /*获取零件的类型*/
            comp_type = Get_Component_Type(part_handle);
            if(Debug){
               U_MESSAGE("零件类型 - " + comp_type);
            }
            if(comp_type != "CLAMP"){
               put_2darray(spool_parts,part_number,0,0);
               put_2darray(spool_parts,part_number,1,pipe);
               put_2darray(spool_parts,part_number,2,part_handle);
               put_2darray(spool_parts,part_number,3,part_sequence);
               if(ISSTRING(comp_type)){
                  put_2darray(spool_parts,part_number,4,comp_type);
               }
               else{
                  put_2darray(spool_parts,part_number,4,"OTHER");
               }
               put_2darray(spool_parts,part_number,5,10000);

               /*获取零件零件编号标注及尺寸标注的坐标*/
               x0=0;y0=0;z0=0;x1=0;y1=0;z1=0;
               get_part_coordinate(pipe,part_sequence,comp_type,x0,y0,z0,x1,y1,z1);
               put_2darray(spool_parts,part_number,6,x0);
               put_2darray(spool_parts,part_number,7,y0);
               put_2darray(spool_parts,part_number,8,z0);
               put_2darray(spool_parts,part_number,9,x1);
               put_2darray(spool_parts,part_number,10,y1);
               put_2darray(spool_parts,part_number,11,z1);
               put_2darray(spool_parts,part_number,12,10000);
               put_2darray(spool_parts,part_number,13,10000);
               put_2darray(spool_parts,part_number,14,10000);
               put_2darray(spool_parts,part_number,15,10000);
               put_2darray(spool_parts,part_number,16,10000);
               part_number = part_number + 1;
               /*如果零件为直管段，判断是否有支管在这个直管段上，如果有，则将其按照顺序插入到零件清单中*/
               if(comp_type == "TUBE"){
                  if(have_branch(pipe)){
                     insert_branch_root(spool_parts,part_number,pipe,part_sequence);
                  }
               }
               /*如果零件为弯头，判断是否有支管在这个弯头段上，如果有，则将其按照顺序插入到零件清单中*/
               if(comp_type == "BEND"){
                  if(have_branch(pipe)){
                     insert_bend_branch_root(spool_parts,part_number,pipe,part_sequence);
                  }
               }
            }
         }
      }
   }
   main_branch_part_number = part_number;
   /*处理支管零件,通过主管上的虚拟零件及TEE来找对应的支管*/
   branch_number = 1;
   for(i=0;i<main_branch_part_number;i=i+1;){
      is_branch_root = get_2darray(spool_parts,i,2);
      is_tee = get_2darray(spool_parts,i,4);
      if(ISSTRING(is_branch_root)){
         if(is_branch_root == "ROOT"){
            pipe = get_2darray(spool_parts,i,1);
            node_id = get_2darray(spool_parts,i,3);
            insert_branch_parts(spool_parts,part_number,pipe,node_id,branch_number);
            branch_number = branch_number + 1;
         }
      }
      else if(is_tee == "TEE"){
         pipe = get_2darray(spool_parts,i,1);
         insert_branch_parts(spool_parts,part_number,pipe,3,branch_number);
         branch_number = branch_number + 1;
      }
   }

   /*处理贯通件及支管末端的stdc*/
   /*套管添加到管子末端时，根据建模方式的不同，有时候是pipe的一个零件，有时候自身是一个pipe*/
   for(i=1;i<Spool_Branch_Number;i=i+1){
      pipe = get_2darray(Spool_Branch,i,0);
      pipe_part_number = PM_NR_PARTS_IN_PIPE(pipe);
      if(pipe_part_number == -1){
         check = is_on_surface(pipe);
         check_hole = is_hole(pipe);
         /*将SLEEVE等PENETRATION管子表面零件插入对应的TUBE零件的后边*/
         if(check){
            insert_penetration(spool_parts,part_number,pipe);
         }
         else if(check_hole){
            insert_hole(spool_parts,part_number,pipe);
         }
         /*将支管末端的套管等standard component添加到对应的支管后面*/
         else{
            check = find_in_parts(spool_parts,part_number,pipe);
            if(!check){
               add_stdc_to_branch_end(spool_parts,part_number,pipe);
            }
         }
      }
      else{
         check = find_in_parts(spool_parts,part_number,pipe);
         if(!check){
            add_stdc_to_branch_end(spool_parts,part_number,pipe);
         }
      }
   }

   /*如果存在开孔管理生成的复板，将其插入到对应的位置上*/
   if(Have_Double_Plate){
      insert_double_plate(spool_parts,part_number);
   }

   /*将结果存入全局变量*/
   Spool_Part_Number = part_number;
   free_2darray(Spool_Parts);
   Spool_Parts = alloc_2darray(Spool_Part_Number,17);
   for(i=0;i<Spool_Part_Number;i=i+1;){
      v0 = get_2darray(spool_parts,i,0);
      v1 = get_2darray(spool_parts,i,1);
      v2 = get_2darray(spool_parts,i,2);
      v3 = get_2darray(spool_parts,i,3);
      v4 = get_2darray(spool_parts,i,4);
      v5 = get_2darray(spool_parts,i,5);
      v6 = get_2darray(spool_parts,i,6);
      v7 = get_2darray(spool_parts,i,7);
      v8 = get_2darray(spool_parts,i,8);
      v9 = get_2darray(spool_parts,i,9);
      v10 = get_2darray(spool_parts,i,10);
      v11 = get_2darray(spool_parts,i,11);
      v12 = 10000;
      v13 = 10000;
      v14 = 10000;
      v15 = 10000;
      v16 = 10000;
      put_2darray(Spool_Parts,i,0,v0);
      put_2darray(Spool_Parts,i,1,v1);
      put_2darray(Spool_Parts,i,2,v2);
      put_2darray(Spool_Parts,i,3,v3);
      put_2darray(Spool_Parts,i,4,v4);
      put_2darray(Spool_Parts,i,5,v5);
      put_2darray(Spool_Parts,i,6,v6);
      put_2darray(Spool_Parts,i,7,v7);
      put_2darray(Spool_Parts,i,8,v8);
      put_2darray(Spool_Parts,i,9,v9);
      put_2darray(Spool_Parts,i,10,v10);
      put_2darray(Spool_Parts,i,11,v11);
      put_2darray(Spool_Parts,i,12,v12);
      put_2darray(Spool_Parts,i,13,v13);
      put_2darray(Spool_Parts,i,14,v14);
      put_2darray(Spool_Parts,i,15,v15);
      put_2darray(Spool_Parts,i,16,v16);
   }

	/*释放临时数组的资源*/
	free_2darray(spool_parts);
	print_parts_info();
   return(0);
}


/*检查pipe是否已经被添加到零件序列中*/
find_in_parts(spool_parts,part_number,pipe)
{
   check = 0;
   for(i=0;i<part_number;i=i+1;){
      pipe0 = get_2darray(spool_parts,i,1);
      if(pipe0 == pipe){
         check = 1;
      }
   }
   return(check);
}

/*判断Standard Component是否为SET-ON类型的零件*/
is_on_surface(pipe)
{
   connection_type1 = PM_GET_CONPNT_DATA(pipe,1,"ft1");
   connection_type2 = PM_GET_CONPNT_DATA(pipe,2,"ft1");
   if(connection_type1 == "Auxiliary point" & connection_type2 == "Auxiliary point"){
      return(1);
   }
   else{
      return(0);
   }
}

/*判断Standard Component是否为测深管的透气孔零件*/
is_hole(pipe)
{
   comp_type = Get_Component_Type(pipe);
   if(comp_type == "HOLE"){
      return(1);
   }
   else{
      return(0);
   }
}

/*将复板及其相关信息插入到零件序列中
--spool_parts     2d_array    管段的零件序列
--part_number     int         管段的零件个数
*/
insert_double_plate(spool_parts,part_number)
{
   /*获取复板的位置信息*/
   double_plate_handle = PM_GET_MEMBER_IN_SET(Double_Plate_Set,0);
   xs = PM_GET_OBJDATA(double_plate_handle,0,MMT_TAG_ORIG_X);
   ys = PM_GET_OBJDATA(double_plate_handle,0,MMT_TAG_ORIG_Y);
   zs = PM_GET_OBJDATA(double_plate_handle,0,MMT_TAG_ORIG_Z);
   x = String_To_Float(xs);
   y = String_To_Float(ys);
   z = String_To_Float(zs);

   /*计算复板在零件序列中的正确位置*/
   pos = find_double_plate_position(spool_parts,part_number,x,y,z);

   /*将复板后面的零件相应地向后挪动一位*/
   if(pos != -1){
      for(i=part_number;i>pos;i=i-1;){
         v0  = get_2darray(spool_parts,i-1,0);
         v1  = get_2darray(spool_parts,i-1,1);
         v2  = get_2darray(spool_parts,i-1,2);
         v3  = get_2darray(spool_parts,i-1,3);
         v4  = get_2darray(spool_parts,i-1,4);
         v5  = get_2darray(spool_parts,i-1,5);
         v6  = get_2darray(spool_parts,i-1,6);
         v7  = get_2darray(spool_parts,i-1,7);
         v8  = get_2darray(spool_parts,i-1,8);
         v9  = get_2darray(spool_parts,i-1,9);
         v10 = get_2darray(spool_parts,i-1,10);
         v11 = get_2darray(spool_parts,i-1,11);
         v12 = get_2darray(spool_parts,i-1,12);
         v13 = get_2darray(spool_parts,i-1,13);
         v14 = get_2darray(spool_parts,i-1,14);
         v15 = get_2darray(spool_parts,i-1,15);
         v16 = get_2darray(spool_parts,i-1,16);
         put_2darray(spool_parts,i,0,v0);
         put_2darray(spool_parts,i,1,v1);
         put_2darray(spool_parts,i,2,v2);
         put_2darray(spool_parts,i,3,v3);
         put_2darray(spool_parts,i,4,v4);
         put_2darray(spool_parts,i,5,v5);
         put_2darray(spool_parts,i,6,v6);
         put_2darray(spool_parts,i,7,v7);
         put_2darray(spool_parts,i,8,v8);
         put_2darray(spool_parts,i,9,v9);
         put_2darray(spool_parts,i,10,v10);
         put_2darray(spool_parts,i,11,v11);
         put_2darray(spool_parts,i,12,v12);
         put_2darray(spool_parts,i,13,v13);
         put_2darray(spool_parts,i,14,v14);
         put_2darray(spool_parts,i,15,v15);
         put_2darray(spool_parts,i,16,v16);
      }
   }

   /*将复板信息存入零件信息列表中*/
   branch_number = get_2darray(spool_parts,pos,0);
   put_2darray(spool_parts,pos+1,0,branch_number);
   put_2darray(spool_parts,pos+1,1,10000);
   put_2darray(spool_parts,pos+1,2,double_plate_handle);
   put_2darray(spool_parts,pos+1,3,10000);
   put_2darray(spool_parts,pos+1,4,"DoublePlate");
   put_2darray(spool_parts,pos+1,5,10000);
   put_2darray(spool_parts,pos+1,6,x);
   put_2darray(spool_parts,pos+1,7,y);
   put_2darray(spool_parts,pos+1,8,z);
   put_2darray(spool_parts,pos+1,9,x);
   put_2darray(spool_parts,pos+1,10,y);
   put_2darray(spool_parts,pos+1,11,z);
   put_2darray(spool_parts,pos+1,12,10000);
   put_2darray(spool_parts,pos+1,13,10000);
   put_2darray(spool_parts,pos+1,14,10000);
   put_2darray(spool_parts,pos+1,15,10000);
   put_2darray(spool_parts,pos+1,16,10000);
   part_number = part_number + 1;
   return(0);
}


/*将复板及其相关信息插入到零件序列中
--spool_parts     2d_array    管段的零件序列
--part_number     int         管段的零件个数
--sleeve          handle      套管的handle
*/
insert_penetration(spool_parts,part_number,penetration)
{
   /*获取套管的位置信息*/
   xs = PM_GET_OBJDATA(penetration,0,MMT_TAG_ORIG_X);
   ys = PM_GET_OBJDATA(penetration,0,MMT_TAG_ORIG_Y);
   zs = PM_GET_OBJDATA(penetration,0,MMT_TAG_ORIG_Z);
   if(Debug){
      U_MESSAGE("**********************贯通件坐标**************************");
      U_MESSAGE("x="+xs+";y="+ys+";z="+zs);
   }
   x = String_To_Float(xs);
   y = String_To_Float(ys);
   z = String_To_Float(zs);

   /*计算套管在零件序列中的正确位置*/
   pos = find_double_plate_position(spool_parts,part_number,x,y,z);
   /*将套管后面的零件相应地向后挪动一位*/
   if(pos != -1){
      for(i=part_number;i>pos;i=i-1;){
         v0  = get_2darray(spool_parts,i-1,0);
         v1  = get_2darray(spool_parts,i-1,1);
         v2  = get_2darray(spool_parts,i-1,2);
         v3  = get_2darray(spool_parts,i-1,3);
         v4  = get_2darray(spool_parts,i-1,4);
         v5  = get_2darray(spool_parts,i-1,5);
         v6  = get_2darray(spool_parts,i-1,6);
         v7  = get_2darray(spool_parts,i-1,7);
         v8  = get_2darray(spool_parts,i-1,8);
         v9  = get_2darray(spool_parts,i-1,9);
         v10 = get_2darray(spool_parts,i-1,10);
         v11 = get_2darray(spool_parts,i-1,11);
         v12 = get_2darray(spool_parts,i-1,12);
         v13 = get_2darray(spool_parts,i-1,13);
         v14 = get_2darray(spool_parts,i-1,14);
         v15 = get_2darray(spool_parts,i-1,15);
         v16 = get_2darray(spool_parts,i-1,16);
         put_2darray(spool_parts,i,0,v0);
         put_2darray(spool_parts,i,1,v1);
         put_2darray(spool_parts,i,2,v2);
         put_2darray(spool_parts,i,3,v3);
         put_2darray(spool_parts,i,4,v4);
         put_2darray(spool_parts,i,5,v5);
         put_2darray(spool_parts,i,6,v6);
         put_2darray(spool_parts,i,7,v7);
         put_2darray(spool_parts,i,8,v8);
         put_2darray(spool_parts,i,9,v9);
         put_2darray(spool_parts,i,10,v10);
         put_2darray(spool_parts,i,11,v11);
         put_2darray(spool_parts,i,12,v12);
         put_2darray(spool_parts,i,13,v13);
         put_2darray(spool_parts,i,14,v14);
         put_2darray(spool_parts,i,15,v15);
         put_2darray(spool_parts,i,16,v16);
      }
   }
   else{
      return(-1);
   }

   /*将套管信息存入零件信息列表中*/
   branch_number = get_2darray(spool_parts,pos,0);
   put_2darray(spool_parts,pos+1,0,branch_number);
   put_2darray(spool_parts,pos+1,1,penetration);
   put_2darray(spool_parts,pos+1,2,penetration);
   put_2darray(spool_parts,pos+1,3,10000);
   put_2darray(spool_parts,pos+1,4,"PENETRATION");
   put_2darray(spool_parts,pos+1,5,10000);
   put_2darray(spool_parts,pos+1,6,x);
   put_2darray(spool_parts,pos+1,7,y);
   put_2darray(spool_parts,pos+1,8,z);
   put_2darray(spool_parts,pos+1,9,x);
   put_2darray(spool_parts,pos+1,10,y);
   put_2darray(spool_parts,pos+1,11,z);
   put_2darray(spool_parts,pos+1,12,10000);
   put_2darray(spool_parts,pos+1,13,10000);
   put_2darray(spool_parts,pos+1,14,10000);
   put_2darray(spool_parts,pos+1,15,10000);
   put_2darray(spool_parts,pos+1,16,10000);
   part_number = part_number + 1;
   return(0);
}

/*将测深管透气孔及其相关信息插入到零件序列中
--spool_parts     2d_array    管段的零件序列
--part_number     int         管段的零件个数
--hole            handle      开孔零件的handle
*/
insert_hole(spool_parts,part_number,pipe)
{
   /*获取开孔零件的位置信息*/
   x = PM_GET_CONPNT_DATA(pipe,1,"x");
   y = PM_GET_CONPNT_DATA(pipe,1,"y");
   z = PM_GET_CONPNT_DATA(pipe,1,"z");
   x1=String_To_Float(x);
   y1=String_To_Float(y);
   z1=String_To_Float(z);
   x = PM_GET_CONPNT_DATA(pipe,2,"x");
   y = PM_GET_CONPNT_DATA(pipe,2,"y");
   z = PM_GET_CONPNT_DATA(pipe,2,"z");
   x2=String_To_Float(x);
   y2=String_To_Float(y);
   z2=String_To_Float(z);

   /*计算开孔零件在零件序列中的正确位置*/
   pos = find_hole_position(spool_parts,part_number,x2,y2,z2);
   pos = 1;
   /*将开孔零件后面的零件相应地向后挪动一位*/
   if(pos != -1){
      for(i=part_number;i>pos;i=i-1;){
         v0  = get_2darray(spool_parts,i-1,0);
         v1  = get_2darray(spool_parts,i-1,1);
         v2  = get_2darray(spool_parts,i-1,2);
         v3  = get_2darray(spool_parts,i-1,3);
         v4  = get_2darray(spool_parts,i-1,4);
         v5  = get_2darray(spool_parts,i-1,5);
         v6  = get_2darray(spool_parts,i-1,6);
         v7  = get_2darray(spool_parts,i-1,7);
         v8  = get_2darray(spool_parts,i-1,8);
         v9  = get_2darray(spool_parts,i-1,9);
         v10 = get_2darray(spool_parts,i-1,10);
         v11 = get_2darray(spool_parts,i-1,11);
         v12 = get_2darray(spool_parts,i-1,12);
         v13 = get_2darray(spool_parts,i-1,13);
         v14 = get_2darray(spool_parts,i-1,14);
         v15 = get_2darray(spool_parts,i-1,15);
         v16 = get_2darray(spool_parts,i-1,16);
         put_2darray(spool_parts,i,0,v0);
         put_2darray(spool_parts,i,1,v1);
         put_2darray(spool_parts,i,2,v2);
         put_2darray(spool_parts,i,3,v3);
         put_2darray(spool_parts,i,4,v4);
         put_2darray(spool_parts,i,5,v5);
         put_2darray(spool_parts,i,6,v6);
         put_2darray(spool_parts,i,7,v7);
         put_2darray(spool_parts,i,8,v8);
         put_2darray(spool_parts,i,9,v9);
         put_2darray(spool_parts,i,10,v10);
         put_2darray(spool_parts,i,11,v11);
         put_2darray(spool_parts,i,12,v12);
         put_2darray(spool_parts,i,13,v13);
         put_2darray(spool_parts,i,14,v14);
         put_2darray(spool_parts,i,15,v15);
         put_2darray(spool_parts,i,16,v16);
      }
   }
   else{
      return(-1);
   }

   /*将开孔零件信息存入零件信息列表中*/
   branch_number = get_2darray(spool_parts,pos,0);
   put_2darray(spool_parts,pos+1,0,branch_number);
   put_2darray(spool_parts,pos+1,1,pipe);
   put_2darray(spool_parts,pos+1,2,pipe);
   put_2darray(spool_parts,pos+1,3,10000);
   put_2darray(spool_parts,pos+1,4,"HOLE");
   put_2darray(spool_parts,pos+1,5,10000);
   put_2darray(spool_parts,pos+1,6,x1);
   put_2darray(spool_parts,pos+1,7,y1);
   put_2darray(spool_parts,pos+1,8,z1);
   put_2darray(spool_parts,pos+1,9,x2);
   put_2darray(spool_parts,pos+1,10,y2);
   put_2darray(spool_parts,pos+1,11,z2);
   put_2darray(spool_parts,pos+1,12,10000);
   put_2darray(spool_parts,pos+1,13,10000);
   put_2darray(spool_parts,pos+1,14,10000);
   put_2darray(spool_parts,pos+1,15,10000);
   put_2darray(spool_parts,pos+1,16,10000);
   part_number = part_number + 1;
   return(0);
}


/*将支管末端的套管等stdc及其相关信息插入到零件序列中
--spool_parts     2d_array    管段的零件序列
--part_number     int         管段的零件个数
--stdc            handle      套管等stdc的handle
*/
add_stdc_to_branch_end(spool_parts,part_number,stdc)
{
   /*获取stdc所连接的对象*/
	connected_node_id = 0;
	conn_obj = PM_GET_CONNECTED_OBJECT(stdc, 1, connected_node_id);
	if(ISINT(conn_obj)){
	   conn_obj = PM_GET_CONNECTED_OBJECT(stdc, 2, connected_node_id);
	}
	else{
      flag = belong_to_spool(conn_obj);
      if(!flag){
         conn_obj = PM_GET_CONNECTED_OBJECT(stdc, 2, connected_node_id);
      }
	}

   /*计算stdc在零件序列中的正确位置*/
   pos = find_stdc_position(spool_parts,part_number,stdc);
   /*将stdc后面的零件相应地向后挪动一位*/
   if(pos != -1){
      for(i=part_number;i>pos;i=i-1;){
         v0  = get_2darray(spool_parts,i-1,0);
         v1  = get_2darray(spool_parts,i-1,1);
         v2  = get_2darray(spool_parts,i-1,2);
         v3  = get_2darray(spool_parts,i-1,3);
         v4  = get_2darray(spool_parts,i-1,4);
         v5  = get_2darray(spool_parts,i-1,5);
         v6  = get_2darray(spool_parts,i-1,6);
         v7  = get_2darray(spool_parts,i-1,7);
         v8  = get_2darray(spool_parts,i-1,8);
         v9  = get_2darray(spool_parts,i-1,9);
         v10 = get_2darray(spool_parts,i-1,10);
         v11 = get_2darray(spool_parts,i-1,11);
         v12 = get_2darray(spool_parts,i-1,12);
         v13 = get_2darray(spool_parts,i-1,13);
         v14 = get_2darray(spool_parts,i-1,14);
         v15 = get_2darray(spool_parts,i-1,15);
         v16 = get_2darray(spool_parts,i-1,16);
         put_2darray(spool_parts,i,0,v0);
         put_2darray(spool_parts,i,1,v1);
         put_2darray(spool_parts,i,2,v2);
         put_2darray(spool_parts,i,3,v3);
         put_2darray(spool_parts,i,4,v4);
         put_2darray(spool_parts,i,5,v5);
         put_2darray(spool_parts,i,6,v6);
         put_2darray(spool_parts,i,7,v7);
         put_2darray(spool_parts,i,8,v8);
         put_2darray(spool_parts,i,9,v9);
         put_2darray(spool_parts,i,10,v10);
         put_2darray(spool_parts,i,11,v11);
         put_2darray(spool_parts,i,12,v12);
         put_2darray(spool_parts,i,13,v13);
         put_2darray(spool_parts,i,14,v14);
         put_2darray(spool_parts,i,15,v15);
         put_2darray(spool_parts,i,16,v16);
      }
   }
   else{
      return(-1);
   }

   /*将stdc信息存入零件信息列表中*/
   branch_number = get_2darray(spool_parts,pos,0);
   put_2darray(spool_parts,pos+1,0,branch_number);
   put_2darray(spool_parts,pos+1,1,stdc);
   put_2darray(spool_parts,pos+1,2,stdc);
   pipe_part_number = PM_NR_PARTS_IN_PIPE(stdc);
   if(pipe_part_number == -1){
      put_2darray(spool_parts,pos+1,3,0);
   }
   else{
      put_2darray(spool_parts,pos+1,3,1);
   }
   type = Get_Component_Type(stdc);
   put_2darray(spool_parts,pos+1,4,type);
   put_2darray(spool_parts,pos+1,5,10000);
   /*获取零件零件编号标注及尺寸标注的坐标*/
   x0=0;y0=0;z0=0;x1=0;y1=0;z1=0;
   get_part_coordinate(stdc,1,type,x0,y0,z0,x1,y1,z1);
   put_2darray(spool_parts,pos+1,6,x0);
   put_2darray(spool_parts,pos+1,7,y0);
   put_2darray(spool_parts,pos+1,8,z0);
   put_2darray(spool_parts,pos+1,9,x1);
   put_2darray(spool_parts,pos+1,10,y1);
   put_2darray(spool_parts,pos+1,11,z1);
   put_2darray(spool_parts,pos+1,12,10000);
   put_2darray(spool_parts,pos+1,13,10000);
   put_2darray(spool_parts,pos+1,14,10000);
   put_2darray(spool_parts,pos+1,15,10000);
   put_2darray(spool_parts,pos+1,16,10000);
   part_number = part_number + 1;
   return(0);
}


/*获取复板在零件序列中的序号
--输入值
--spool_parts     2d_array    管段的零件序列
--spool_parts     int         管段的零件个数
--x,y,z           float       复板的位置坐标
--返回值
--                int         复板的前一个零件的序号
--如果直管段上有多个套管或者复板，这个算法可能会出错
*/
find_double_plate_position(spool_parts,part_number,x,y,z)
{
   for(i=0;i<part_number;i=i+1;){
      type = get_2darray(spool_parts,i,4);
      /*如果是直管，根据位置判断复板是否在这个直管上*/
      if(type == "TUBE"){
         x0=0.0;y0=0.0;z0=0.0;x1=0.0;y1=0.0;z1=0.0;
         pipe = get_2darray(spool_parts,i,1);
         nth_part = get_2darray(spool_parts,i,3);
         objgeom = PM_CREATE_PNTSET(10);
         PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
         PM_GET_PNT(objgeom, 0, x0, y0, z0);
         PM_GET_PNT(objgeom, 1, x1, y1, z1);
         PM_FREE_PNTSET(objgeom);
         distance = 0;
         res = is_root_on_tube(x,y,z,x0,y0,z0,x1,y1,z1,distance);
         if(res){
            branch_root_number = find_root_number_on_tube(spool_parts,part_number,i);
            /*如果直管段上没开支管，则直接返回*/
            if(branch_root_number == 0){
               return(i);
            }
            /*如果直管上开了支管，则计算复板与支管的相对位置*/
            else{
               for(k=i+1;k<=i+branch_root_number;k=k+1){
                  x2 = get_2darray(spool_parts,k,9);
                  y2 = get_2darray(spool_parts,k,10);
                  z2 = get_2darray(spool_parts,k,11);
                  distance = 0;
                  res = is_root_on_tube(x,y,z,x0,y0,z0,x2,y2,z2,distance);
                  if(res){
                     return(k-1);
                  }
               }
               return(k-1);
            }
         }
      }
   }
   return(-1);
}

/*获取开孔零件在零件序列中的序号
--输入值
--spool_parts     2d_array    管段的零件序列
--spool_parts     int         管段的零件个数
--x,y,z           float       开孔零件的位置坐标
--返回值
--                int         复板的前一个零件的序号
--x,y,z           float       开孔零件的位置坐标于主管中心线的交点坐标
*/
find_hole_position(spool_parts,part_number,x,y,z)
{
   for(i=0;i<part_number;i=i+1;){
      type = get_2darray(spool_parts,i,4);
      /*如果是直管，根据位置判断复板是否在这个直管上*/
      if(type == "TUBE"){
         x0=0.0;y0=0.0;z0=0.0;x1=0.0;y1=0.0;z1=0.0;
         pipe = get_2darray(spool_parts,i,1);
         nth_part = get_2darray(spool_parts,i,3);
         objgeom = PM_CREATE_PNTSET(10);
         PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
         PM_GET_PNT(objgeom, 0, x0, y0, z0);
         PM_GET_PNT(objgeom, 1, x1, y1, z1);
         PM_FREE_PNTSET(objgeom);

   		point_set = PM_CREATE_PNTSET(10);
   		PM_SET_PNT(point_set, 0, x0, y0, z0);
   		PM_SET_PNT(point_set, 1, x1, y1, z1);
   		PM_SET_PNT(point_set, 2, x, y, z);
   		distance = 0.0;
   		project_point_to_line(point_set, distance);
   		PM_GET_PNT(point_set, 3, x, y, z);
   		PM_FREE_PNTSET(point_set);

         distance = 0;
         res = is_root_on_tube(x,y,z,x0,y0,z0,x1,y1,z1,distance);
         if(res){
            branch_root_number = find_root_number_on_tube(spool_parts,part_number,i);
            /*如果直管段上没开支管，则直接返回*/
            if(branch_root_number == 0){
               return(i);
            }
            /*如果直管上开了支管，则计算复板与支管的相对位置*/
            else{
               for(k=i+1;k<=i+branch_root_number;k=k+1){
                  x2 = get_2darray(spool_parts,k,9);
                  y2 = get_2darray(spool_parts,k,10);
                  z2 = get_2darray(spool_parts,k,11);
                  distance = 0;
                  res = is_root_on_tube(x,y,z,x0,y0,z0,x2,y2,z2,distance);
                  if(res){
                     return(k-1);
                  }
               }
               return(k-1);
            }
         }
      }
   }
   return(-1);
}

/*获取支管末端的stdc在零件序列中的序号
--输入值
--spool_parts     2d_array    管段的零件序列
--spool_parts     int         管段的零件个数
--connected_obj   handle      stdc连接的对象的handle
--返回值
--                int         stdc所连接的零件的序号
*/
find_stdc_position(spool_parts,part_number,connected_obj)
{
   find = 0;
   for(i=0;i<part_number;i=i+1;){
      pipe = get_2darray(spool_parts,i,1);
      if(pipe == connected_obj){
         find = 1;
      }
      if(pipe != connected_obj & find == 1){
         pos = i-1;
         return pos;
      }
   }
   return(part_number-1);
}

/*查找复板所在的直管段上是否有支管，有的话则返回支管数量
--spool_parts     2d_array    管段的零件序列
--spool_parts     int         管段的零件个数
--i               int         直管零件的零件序号
*/
find_root_number_on_tube(spool_parts,part_number,i)
{
   tube_branch = get_2darray(spool_parts,i,0);
   root_number = 0;
   for(k=i+1;k<part_number;k=k+1){
      branch = get_2darray(spool_parts,k,0);
      if(branch != tube_branch){
         return(root_number);
      }
      type = get_2darray(spool_parts,k,4);
      if(type != "ROOT"){
         return(root_number);
      }
      root_number = root_number + 1;
   }
   return(0);
}

print_parts_info()
{
   /*输出零件信息*/
   if(Debug){
      U_MESSAGE("**********输出零件排序后的信息**********");
   }
   for(i=0;i<Spool_Part_Number;i=i+1;){
      v0 = ITOASCII(get_2darray(Spool_Parts,i,0));
      v10 = get_2darray(Spool_Parts,i,1);
      if(ISSTRING(v10)){
         v1 = v10;
      }
      else{
         v1 = "handle";
      }
      v20 = get_2darray(Spool_Parts,i,2);
      if(ISSTRING(v20)){
         v2 = v20;
      }
      else{
         v2 = "handle";
      }
      v3 = ITOASCII(get_2darray(Spool_Parts,i,3));
      v4 = get_2darray(Spool_Parts,i,4);
      v50 = get_2darray(Spool_Parts,i,5);
      if(ISSTRING(v50)){
         v5=v50;
      }
      else{
         v5 = ITOASCII(v50);
      }
      v6 = ITOASCII(get_2darray(Spool_Parts,i,6));
      v7 = ITOASCII(get_2darray(Spool_Parts,i,7));
      v8 = ITOASCII(get_2darray(Spool_Parts,i,8));
      v9 = ITOASCII(get_2darray(Spool_Parts,i,9));
      v10 = ITOASCII(get_2darray(Spool_Parts,i,10));
      v11 = ITOASCII(get_2darray(Spool_Parts,i,11));
      v12 = ITOASCII(get_2darray(Spool_Parts,i,12));
      mess = ITOASCII(i) + ":" + v0 + "-" + v1 + "-" + v2 + "-" + v3 + "-" + v4 + "-" + v5 + "-" + v6 + "-" + v7 + "-" + v8 + "-" + v9 + "-" + v10 + "-" + v11 + "-" + v12;
      U_MESSAGE(mess);
   }
   return(0);
}

/*根据零件的类型计算零件号标注及尺寸标注的位置
--pipe      handle   管子零件所属的PIPE的handle
--nth_part  int      管子零件在所属PIPE中的序号
--x0,y0,z0  float    管子零件用于标注零件号的坐标(如果是直管，则为首端坐标）
--x1,y1,z1  float    管子零件用于尺寸标注的坐标（如果是直管，则为末端坐标）
*/
get_part_coordinate(pipe,nth_part,type,x0,y0,z0,x1,y1,z1)
{
   if(type == "TUBE"){
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
      PM_GET_PNT(objgeom, 0, x0, y0, z0);
      PM_GET_PNT(objgeom, 1, x1, y1, z1);
      PM_FREE_PNTSET(objgeom);
   }
   /*point1,2为拐点位置*/
   else if(type == "BEND"){
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
      PM_GET_PNT(objgeom, 1, x0, y0, z0);
      PM_GET_PNT(objgeom, 1, x1, y1, z1);
      PM_FREE_PNTSET(objgeom);
   }
   else if(type == "ELBOW"){
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
      PM_GET_PNT(objgeom, 1, x0, y0, z0);
      PM_GET_PNT(objgeom, 1, x1, y1, z1);
      PM_FREE_PNTSET(objgeom);
   }
   else if(type == "REDUCER"){
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
      if(nth_part == 1){
         PM_GET_PNT(objgeom, 0, x1, y1, z1);
      }
      else{
         PM_GET_PNT(objgeom, 1, x1, y1, z1);
      }
      xx1=0;yy1=0;zz1=0;xx2=0;yy2=0;zz2=0;
      PM_GET_PNT(objgeom, 0, xx1, yy1, zz1);
      PM_GET_PNT(objgeom, 1, xx2, yy2, zz2);
      PM_FREE_PNTSET(objgeom);
      x0=(xx1+xx2)/2;
      y0=(yy1+yy2)/2;
      z0=(zz1+zz2)/2;
   }
   else if(type == "FLANGE"){
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
      PM_GET_PNT(objgeom, 0, x1, y1, z1);
      xx1=0;yy1=0;zz1=0;xx2=0;yy2=0;zz2=0;
      PM_GET_PNT(objgeom, 0, xx1, yy1, zz1);
      PM_GET_PNT(objgeom, 1, xx2, yy2, zz2);
      PM_FREE_PNTSET(objgeom);
      x0=(xx1+xx2)/2;
      y0=(yy1+yy2)/2;
      z0=(zz1+zz2)/2;
      if(nth_part == 1){
         x = ""; y = ""; z = "";
         x = PM_GET_CONPNT_DATA(pipe,1,"x");
         y = PM_GET_CONPNT_DATA(pipe,1,"y");
         z = PM_GET_CONPNT_DATA(pipe,1,"z");
         x1=String_To_Float(x);
         y1=String_To_Float(y);
         z1=String_To_Float(z);
      }
      else{
         x = ""; y = ""; z = "";
         x = PM_GET_CONPNT_DATA(pipe,2,"x");
         y = PM_GET_CONPNT_DATA(pipe,2,"y");
         z = PM_GET_CONPNT_DATA(pipe,2,"z");
         x1=String_To_Float(x);
         y1=String_To_Float(y);
         z1=String_To_Float(z);
      }
   }
   else if(type == "TEE"){
      x = ""; y = ""; z = "";
      x = PM_GET_CONPNT_DATA(pipe,4,"x");
      y = PM_GET_CONPNT_DATA(pipe,4,"y");
      z = PM_GET_CONPNT_DATA(pipe,4,"z");
      x0=String_To_Float(x);
      y0=String_To_Float(y);
      z0=String_To_Float(z);
      x1=x0;
      y1=y0;
      z1=z0;
   }
   else if(type == "CLAMP"){
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
      PM_GET_PNT(objgeom, 2, x0, y0, z0);
      PM_GET_PNT(objgeom, 2, x1, y1, z1);
      PM_FREE_PNTSET(objgeom);
   }
   else if(type == "CAP"){
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
      PM_GET_PNT(objgeom, 0, x0, y0, z0);
      PM_GET_PNT(objgeom, 0, x1, y1, z1);
      PM_FREE_PNTSET(objgeom);
   }
   /*获取套管的数据*/
   else if(type == "SLEEVE"){
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
      PM_GET_PNT(objgeom, 0, x0, y0, z0);
      part_id = PM_GET_OBJDATA(pipe, nth_part, MMT_TAG_PARTID);
      catalog_des = DM_PARTID_DATA(part_id,"DE");
      /* 处理IHC公司的套管标注问题 */
      if(catalog_des == "C315HD-ST52-Rev.0 Outer SLEEVE (HEAVY)"){
         PM_GET_PNT(objgeom, 0, x1, y1, z1);
         length = 1.0 * DM_PARTID_NAMED_DIM(part_id, "Lout");
         para_z = 1.0 * DM_PARTID_NAMED_DIM(part_id, "z");
         if(nth_part == 1){
            offset = length / 2;
         }
         else{
            offset = length / 2 + para_z;
         }
         if(nth_part == 1){
            normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 1, "fnr"));
            normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 1, "fns"));
         }
         else{
            normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fnr"));
            normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fns"));
         }
         dx = COS(normal_s)*COS(normal_r);
         dy = COS(normal_s)*SIN(normal_r);
         dz = SIN(normal_s);
         x1 = x0 + dx * offset;
         y1 = y0 + dy * offset;
         z1 = z0 + dz * offset;
      }
      else if(catalog_des == "C315H-ST52-Rev.0 Inner SLEEVE (HEAVY)"){
         PM_GET_PNT(objgeom, 0, x1, y1, z1);
         length = 1.0 * DM_PARTID_NAMED_DIM(part_id, "z");
         if(nth_part == 1){
            offset = - length;
         }
         else{
            offset = 0;
         }
         if(nth_part == 1){
            normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 1, "fnr"));
            normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 1, "fns"));
         }
         else{
            normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fnr"));
            normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fns"));
         }
         dx = COS(normal_s)*COS(normal_r);
         dy = COS(normal_s)*SIN(normal_r);
         dz = SIN(normal_s);
         x1 = x0 + dx * offset;
         y1 = y0 + dy * offset;
         z1 = z0 + dz * offset;
      }
      else if(catalog_des == "C315HP-ST52-Rev.0 Outer SLEEVE (HEAVY)"){
         PM_GET_PNT(objgeom, 0, x1, y1, z1);
         length = 1.0 * DM_PARTID_NAMED_DIM(part_id, "Lout");
         para_z = 1.0 * DM_PARTID_NAMED_DIM(part_id, "z");
         if(nth_part == 1){
            offset = length / 2;
         }
         else{
            offset = length / 2 + para_z;
         }
         if(nth_part == 1){
            normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 1, "fnr"));
            normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 1, "fns"));
         }
         else{
            normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fnr"));
            normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fns"));
         }
         dx = COS(normal_s)*COS(normal_r);
         dy = COS(normal_s)*SIN(normal_r);
         dz = SIN(normal_s);
         x1 = x0 + dx * offset;
         y1 = y0 + dy * offset;
         z1 = z0 + dz * offset;
      }
      else if(catalog_des == "C300NL-ST52-Rev.0 Single SLEEVE (NORMAL) L=120"){
         PM_GET_PNT(objgeom, 0, x1, y1, z1);
         length = 1.0 * DM_PARTID_NAMED_DIM(part_id, "L");
         para_z = 1.0 * DM_PARTID_NAMED_DIM(part_id, "z");
         offset = length / 2  +  para_z / 2;
         if(nth_part == 1){
            normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fnr"));
            normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fns"));
         }
         else{
            normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fnr"));
            normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fns"));
         }
         dx = COS(normal_s)*COS(normal_r);
         dy = COS(normal_s)*SIN(normal_r);
         dz = SIN(normal_s);
         x1 = x0 + dx * offset;
         y1 = y0 + dy * offset;
         z1 = z0 + dz * offset;
      }
      else if(catalog_des == "C360-ST52-Rev.0 SLEEVE with holes"){
         PM_GET_PNT(objgeom, 0, x1, y1, z1);
         length = 1.0 * DM_PARTID_NAMED_DIM(part_id, "L");
         para_z = 1.0 * DM_PARTID_NAMED_DIM(part_id, "z");
         offset = length / 2  +  para_z / 2;
         /*
         if(nth_part == 1){
            normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 1, "fnr"));
            normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 1, "fns"));
         }
         else{
            normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fnr"));
            normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fns"));
         }
         */
         normal_r = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fnr"));
         normal_s = String_To_Float(PM_GET_CONPNT_DATA(pipe, 2, "fns"));
         dx = COS(normal_s)*COS(normal_r);
         dy = COS(normal_s)*SIN(normal_r);
         dz = SIN(normal_s);
         x1 = x0 + dx * offset;
         y1 = y0 + dy * offset;
         z1 = z0 + dz * offset;
      }
      /*一般套管*/
      else{
         PM_GET_PNT(objgeom, 0, x1, y1, z1);
      }
      PM_FREE_PNTSET(objgeom);
   }
   else{
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
      PM_GET_PNT(objgeom, 0, x0, y0, z0);
      PM_GET_PNT(objgeom, 0, x1, y1, z1);
      PM_FREE_PNTSET(objgeom);
   }
   return(0);
}

insert_branch_parts(spool_parts,part_number,pipe,node,branch_number)
{
   node_id = 0;
   branch = PM_GET_CONNECTED_OBJECT(pipe, node, node_id);
   branch_part_number = PM_NR_PARTS_IN_PIPE(branch);
   if(branch_part_number == -1){
      branch_part_number = 1;
   }
   if(node_id == 1){
      /*循环处理pipe中的零件*/
      for(k=0;k<branch_part_number;k=k+1;){
         put_2darray(spool_parts,part_number,0,branch_number);
         put_2darray(spool_parts,part_number,1,branch);
         part_sequence = k+1;
         part_obj_id = PM_GET_OBJDATA(branch,part_sequence,MMT_TAG_OBJID);
         part_handle = PM_FIND_BY_OBJID(part_obj_id);
         put_2darray(spool_parts,part_number,2,part_handle);
         put_2darray(spool_parts,part_number,3,part_sequence);
         comp_type = Get_Component_Type(part_handle);
         if(ISSTRING(comp_type)){
            put_2darray(spool_parts,part_number,4,comp_type);
         }
         else{
            put_2darray(spool_parts,part_number,4,"OTHER");
         }
         put_2darray(spool_parts,part_number,5,10000);

         /*获取零件零件编号标注及尺寸标注的坐标*/
         x0=0;y0=0;z0=0;x1=0;y1=0;z1=0;
         get_part_coordinate(branch,part_sequence,comp_type,x0,y0,z0,x1,y1,z1);
         put_2darray(spool_parts,part_number,6,x0);
         put_2darray(spool_parts,part_number,7,y0);
         put_2darray(spool_parts,part_number,8,z0);
         put_2darray(spool_parts,part_number,9,x1);
         put_2darray(spool_parts,part_number,10,y1);
         put_2darray(spool_parts,part_number,11,z1);
         put_2darray(spool_parts,part_number,12,10000);
         put_2darray(spool_parts,part_number,13,10000);
         put_2darray(spool_parts,part_number,14,10000);
         put_2darray(spool_parts,part_number,15,10000);
         put_2darray(spool_parts,part_number,16,10000);

         part_number = part_number + 1;
      }
   }
   else{
      /*循环处理pipe中的零件*/
      for(k=branch_part_number-1;k>=0;k=k-1;){
         put_2darray(spool_parts,part_number,0,branch_number);
         put_2darray(spool_parts,part_number,1,branch);
         part_sequence = k+1;
         part_obj_id = PM_GET_OBJDATA(branch,part_sequence,MMT_TAG_OBJID);
         part_handle = PM_FIND_BY_OBJID(part_obj_id);
         put_2darray(spool_parts,part_number,2,part_handle);
         put_2darray(spool_parts,part_number,3,part_sequence);
         comp_type = Get_Component_Type(part_handle);
         if(ISSTRING(comp_type)){
            put_2darray(spool_parts,part_number,4,comp_type);
         }
         else{
            put_2darray(spool_parts,part_number,4,"OTHER");
         }
         put_2darray(spool_parts,part_number,5,10000);

         /*获取零件零件编号标注及尺寸标注的坐标*/
         x0=0;y0=0;z0=0;x1=0;y1=0;z1=0;
         get_part_coordinate(branch,part_sequence,comp_type,x0,y0,z0,x1,y1,z1);
         put_2darray(spool_parts,part_number,6,x0);
         put_2darray(spool_parts,part_number,7,y0);
         put_2darray(spool_parts,part_number,8,z0);
         put_2darray(spool_parts,part_number,9,x1);
         put_2darray(spool_parts,part_number,10,y1);
         put_2darray(spool_parts,part_number,11,z1);
         put_2darray(spool_parts,part_number,12,10000);
         put_2darray(spool_parts,part_number,13,10000);
         put_2darray(spool_parts,part_number,14,10000);
         put_2darray(spool_parts,part_number,15,10000);
         put_2darray(spool_parts,part_number,16,10000);

         part_number = part_number + 1;
      }
   }
   return(0);
}

/*在支管根部位置插入虚拟部件（支管根部在直管段上）
**spool_parts     2d_array    用于保存零件信息的二维数组
**part_number     int
**pipe            handle      直管零件所在的pipe的handle
**part_sequence   int         直管零件在所属pipe中的序号
*/
insert_branch_root(spool_parts,part_number,pipe,part_sequence)
{
   /*获取直管段的首末端点*/
   objgeom = PM_CREATE_PNTSET(10);
   x1 = 0; y1 = 0; z1 = 0; x2 = 0; y2 = 0; z2 = 0;
   PM_GET_OBJECT_GEOM(pipe, part_sequence, objgeom);
   PM_GET_PNT(objgeom, 0, x1, y1, z1);
   PM_GET_PNT(objgeom, 1, x2, y2, z2);
   PM_FREE_PNTSET(objgeom);
   conn_number = PM_GET_NR_OF_CONPNTS(pipe);

   /*判断支管位置是否在这个直管上，如果是则将其添加到列表中*/
   root_number=0;
   roots = alloc_2darray(conn_number-2,6);
   for(m=3;m<=conn_number;m=m+1;){
      /*过滤掉套管等管子表面零件*/
      node_id = 0;
      connected_obj = PM_GET_CONNECTED_OBJECT(pipe, m, node_id);
      /*如果连接点连接到其它对象，则有可能是支管*/
      if(!ISINT(connected_obj)){
         /*如果连接点的连接对象是Standard Component,则有可能是套管等表面零件*/
         pipe_part_number = PM_NR_PARTS_IN_PIPE(connected_obj);
         if(pipe_part_number == -1){
            check = is_on_surface(connected_obj);
            if(!check){
               x=0;y=0;z=0;
               get_coordinates_of_branch_start_point(pipe,m,x,y,z);
               distance = 0;
               root = is_root_on_tube(x,y,z,x1,y1,z1,x2,y2,z2,distance);
               if(root){
                  put_2darray(roots,root_number,0,x);
                  put_2darray(roots,root_number,1,y);
                  put_2darray(roots,root_number,2,z);
                  put_2darray(roots,root_number,3,distance);
                  put_2darray(roots,root_number,4,1000);
                  put_2darray(roots,root_number,5,m);
                  root_number = root_number + 1;
               }
            }
         }
         else{
            x=0;y=0;z=0;
            get_coordinates_of_branch_start_point(pipe,m,x,y,z);
            distance = 0;
            root = is_root_on_tube(x,y,z,x1,y1,z1,x2,y2,z2,distance);
            if(root){
               put_2darray(roots,root_number,0,x);
               put_2darray(roots,root_number,1,y);
               put_2darray(roots,root_number,2,z);
               put_2darray(roots,root_number,3,distance);
               put_2darray(roots,root_number,4,1000);
               put_2darray(roots,root_number,5,m);
               root_number = root_number + 1;
            }
         }
      }
   }
   /*如果有多个支管在这个直管上，则根据支管距离直管首端的距离进行排序*/
   if(root_number == 1){
      put_2darray(roots,0,4,0);
   }
   else if(root_number>1){
      sort_root_sequence(roots,root_number);
   }
   /*将支管根部按顺序添加到主管的零件序列中*/
   for(i=0;i<root_number;i=i+1;){
      for(k=0;k<root_number;k=k+1;){
         sequence = get_2darray(roots,k,4);
         if(i == sequence){
            root_conn_number = get_2darray(roots,k,5);
            put_2darray(spool_parts,part_number,0,0);
            put_2darray(spool_parts,part_number,1,pipe);
            put_2darray(spool_parts,part_number,2,"ROOT");
            put_2darray(spool_parts,part_number,3,root_conn_number);
            put_2darray(spool_parts,part_number,4,"ROOT");
            put_2darray(spool_parts,part_number,5,10000);

            /*获取支管根部标注坐标*/
            x = get_2darray(roots,k,0);
            y = get_2darray(roots,k,1);
            z = get_2darray(roots,k,2);
            put_2darray(spool_parts,part_number,6,x);
            put_2darray(spool_parts,part_number,7,y);
            put_2darray(spool_parts,part_number,8,z);

            /*保存支管根部尺寸标注坐标*/
            put_2darray(spool_parts,part_number,9,x);
            put_2darray(spool_parts,part_number,10,y);
            put_2darray(spool_parts,part_number,11,z);
            put_2darray(spool_parts,part_number,12,10000);
            put_2darray(spool_parts,part_number,13,10000);
            put_2darray(spool_parts,part_number,14,10000);
            put_2darray(spool_parts,part_number,15,10000);
            put_2darray(spool_parts,part_number,16,10000);
            part_number = part_number + 1;
         }
      }
   }
}

/*在支管根部位置插入虚拟部件(支管根部在弯头上)
**spool_parts     2d_array    用于保存零件信息的二维数组
**part_number     int
**pipe            handle      直管零件所在的pipe的handle
**part_sequence   int         直管零件在所属pipe中的序号
*/
insert_bend_branch_root(spool_parts,part_number,pipe,part_sequence)
{

   /*获取弯头的首末端点*/
   objgeom = PM_CREATE_PNTSET(10);
   x1 = 0; y1 = 0; z1 = 0; x2 = 0; y2 = 0; z2 = 0;x3 = 0; y3 = 0; z3 = 0;
   PM_GET_OBJECT_GEOM(pipe, part_sequence, objgeom);
   PM_GET_PNT(objgeom, 0, x1, y1, z1);
   PM_GET_PNT(objgeom, 1, x2, y2, z2);
   PM_GET_PNT(objgeom, 2, x3, y3, z3);
   PM_FREE_PNTSET(objgeom);

   if(Debug){
      U_MESSAGE("弯头起始点坐标:X=" + FTOASCII(x1) + ",Y=" + FTOASCII(y1) + ",Z=" + FTOASCII(z1));
      U_MESSAGE("弯头拐点坐标:X=" + FTOASCII(x2) + ",Y=" + FTOASCII(y2)  + ",Z=" + FTOASCII(z2));
      U_MESSAGE("弯头结束点坐标:X=" + FTOASCII(x3) + ",Y=" + FTOASCII(y3)  + ",Z=" + FTOASCII(z3));
   }
   return(0);
   conn_number = PM_GET_NR_OF_CONPNTS(pipe);

   /*判断支管位置是否在这个直管上，如果是则将其添加到列表中*/
   root_number=0;
   roots = alloc_2darray(conn_number-2,6);
   for(m=3;m<=conn_number;m=m+1;){
      /*过滤掉套管等管子表面零件*/
      node_id = 0;
      connected_obj = PM_GET_CONNECTED_OBJECT(pipe, m, node_id);
      /*如果连接点连接到其它对象，则有可能是支管*/
      if(!ISINT(connected_obj)){
         /*如果连接点的连接对象是Standard Component,则有可能是套管等表面零件*/
         pipe_part_number = PM_NR_PARTS_IN_PIPE(connected_obj);
         if(pipe_part_number == -1){
            check = is_on_surface(connected_obj);
            if(!check){
               x=0;y=0;z=0;
               get_coordinates_of_branch_start_point(pipe,m,x,y,z);
               distance = 0;
               root = is_root_on_tube(x,y,z,x1,y1,z1,x2,y2,z2,distance);
               if(root){
                  put_2darray(roots,root_number,0,x);
                  put_2darray(roots,root_number,1,y);
                  put_2darray(roots,root_number,2,z);
                  put_2darray(roots,root_number,3,distance);
                  put_2darray(roots,root_number,4,1000);
                  put_2darray(roots,root_number,5,m);
                  root_number = root_number + 1;
               }
            }
         }
         else{
            x=0;y=0;z=0;
            get_coordinates_of_branch_start_point(pipe,m,x,y,z);
            distance = 0;
            root = is_root_on_tube(x,y,z,x1,y1,z1,x2,y2,z2,distance);
            if(root){
               put_2darray(roots,root_number,0,x);
               put_2darray(roots,root_number,1,y);
               put_2darray(roots,root_number,2,z);
               put_2darray(roots,root_number,3,distance);
               put_2darray(roots,root_number,4,1000);
               put_2darray(roots,root_number,5,m);
               root_number = root_number + 1;
            }
         }
      }
   }
   /*如果有多个支管在这个直管上，则根据支管距离直管首端的距离进行排序*/
   if(root_number == 1){
      put_2darray(roots,0,4,0);
   }
   else if(root_number>1){
      sort_root_sequence(roots,root_number);
   }
   /*将支管根部按顺序添加到主管的零件序列中*/
   for(i=0;i<root_number;i=i+1;){
      for(k=0;k<root_number;k=k+1;){
         sequence = get_2darray(roots,k,4);
         if(i == sequence){
            root_conn_number = get_2darray(roots,k,5);
            put_2darray(spool_parts,part_number,0,0);
            put_2darray(spool_parts,part_number,1,pipe);
            put_2darray(spool_parts,part_number,2,"ROOT");
            put_2darray(spool_parts,part_number,3,root_conn_number);
            put_2darray(spool_parts,part_number,4,"ROOT");
            put_2darray(spool_parts,part_number,5,10000);

            /*获取支管根部标注坐标*/
            x = get_2darray(roots,k,0);
            y = get_2darray(roots,k,1);
            z = get_2darray(roots,k,2);
            put_2darray(spool_parts,part_number,6,x);
            put_2darray(spool_parts,part_number,7,y);
            put_2darray(spool_parts,part_number,8,z);

            /*保存支管根部尺寸标注坐标*/
            put_2darray(spool_parts,part_number,9,x);
            put_2darray(spool_parts,part_number,10,y);
            put_2darray(spool_parts,part_number,11,z);
            put_2darray(spool_parts,part_number,12,10000);
            put_2darray(spool_parts,part_number,13,10000);
            put_2darray(spool_parts,part_number,14,10000);
            put_2darray(spool_parts,part_number,15,10000);
            put_2darray(spool_parts,part_number,16,10000);

            part_number = part_number + 1;
         }
      }
   }
}

/*判断给出的支管连接点的位置是否在这个直管段上
--x,y,z     float    支管根部的坐标
--x1,y1,z1  float    直管首端的坐标
--x2,y2,z2  float    直管末端的坐标
--distance  float    返回支管根部距首端的距离
*/
is_root_on_tube(x,y,z,x1,y1,z1,x2,y2,z2,distance)
{
   distance0 = SQRT((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2));
   distance1 = SQRT((x1-x)*(x1-x)+(y1-y)*(y1-y)+(z1-z)*(z1-z));
   distance2 = SQRT((x2-x)*(x2-x)+(y2-y)*(y2-y)+(z2-z)*(z2-z));
   gap = distance0 - distance1 - distance2;
   if(gap < 1 & gap > -1){
      distance = distance1;
      return(1);
   }
   return(0);
}

insert_mto_lbl_coord(spool_parts,part_number,pipe,part_sequence,comp_type)
{

   return(0);
}

/*根据支管距离直管段首端的距离进行排序*/
sort_root_sequence(roots,root_number)
{
   flag = 1;
   sequence = 0;
   while(flag){
      position = 0;
      min_distance = 10000;
      for(i=0;i<root_number;i=i+1;){
         check = get_2darray(roots,i,4);
         if(check == 1000){
            distance = get_2darray(roots,i,3);
            if(distance < min_distance){
               min_distance = distance;
               position = i;
            }
         }
      }
      put_2darray(roots,position,4,sequence);
      sequence = sequence + 1;
      if(sequence == root_number){
         flag = 0;
      }
   }
   return(0);
}

/*获取管段的弯管信息*/
get_bending_table()
{
   if(Bent_Piece_Number == 0){
      return(0);
   }
   free_2darray(Bending_Table_Head);
   Bending_Table_Head = alloc_2darray(Bent_Piece_Number,3);
   A_FREE(Bending_Action_Number);
   Bending_Action_Number = A_ALLOC(Bent_Piece_Number);
   free_2darray(Bending_Actions);
   Bending_Actions = alloc_2darray(Bent_Piece_Number,12);
   for(i=1;i<=Bent_Piece_Number;i=i+1;){
      part_number = 0;
      parts = A_ALLOC(10);
      parts_type = A_ALLOC(10);
      is_bent = 0;
      for(k=0;k<Spool_Part_Number;k=k+1;){
         piece_number = get_2darray(Spool_Parts,k,12);
         if(i == piece_number){
            if(part_number == 0){
               pipe = get_2darray(Spool_Parts,k,1);
               mto_number = get_2darray(Spool_Parts,k,5);
            }
            nth_part = get_2darray(Spool_Parts,k,3);
            type = get_2darray(Spool_Parts,k,4);
            A_PUT(parts,part_number,nth_part);
            A_PUT(parts_type,part_number,type);
            part_number = part_number + 1;
            is_bent = 1;
         }
      }
      if(is_bent){
         get_piece_bending_table(i,pipe,part_number,parts,parts_type,mto_number);
      }
      A_FREE(parts);
      A_FREE(parts_type);
   }
   return(0);
}


/*获取指定管件的弯管信息
**item_number  int      带弯管的管件piece编号
**pipe         handle   piece所属的pipe
**part_number  int      piece所包含的零件个数
**parts        array    piece所包含的零件在所属的pipe中的序号的列表
**parts_type   array    piece所包含的零件的类型列表
**mto_number   string   piece的零件编号
*/
get_piece_bending_table(item_number,pipe,part_number,parts,parts_type,mto_number)
{
    /*获取对应的弯管机名称,弯模半径*/
    bending_machine = "Unset";
    radius = 0.0;
    action_number = 0;
    for(i=0;i<part_number;i=i+1;){
        nth_part = A_GET(parts,i);
        bending_machine = get_bending_machine_name(pipe,nth_part);
        if(ISSTRING(bending_machine)){
            machine = bending_machine;
        }
        bra = 1.0 * PM_GET_OBJDATA(pipe, nth_part, MMT_TAG_BEND_RADIUS);
        if(bra != 0.0){
            radius = bra;
        }
        /*统计弯管的弯头数量*/
        type = A_GET(parts_type,i);
        if(type == "BEND"){
            action_number = action_number + 1;
        }
    }
    if(radius > Bending_Radius){
        Bending_Radius = radius; 
    }
    radius_str = "";
    S_PRINTF(radius_str,"%d",radius);
    
    /*将弯管表表头信息写入全局数组*/
    put_2darray(Bending_Table_Head,item_number-1,0,mto_number);
    put_2darray(Bending_Table_Head,item_number-1,1,machine);
    put_2darray(Bending_Table_Head,item_number-1,2,radius_str);
    
    /*保存弯管动作的数量到全局变量*/
    A_PUT(Bending_Action_Number,item_number-1,action_number);
    
    /*生成弯管动作数据并保存到全局变量*/
    get_bending_action(item_number,pipe,part_number,parts,parts_type,mto_number,action_number);
    
    return(0);
}

/*获取弯管管件的弯管动作数据
**item_number     int         带弯管的管件piece编号
**pipe            handle      piece所属的pipe
**part_number     int         piece所包含的零件个数
**parts           array       piece所包含的零件在所属的pipe中的序号的列表
**parts_type      array       piece所包含的零件的类型列表
**mto_number      string      piece的零件编号
**action_number   int         弯管的动作个数
*/
get_bending_action(item_number,pipe,part_number,parts,parts_type,mto_number,action_number)
{
   /*获取弯管机相关参数*/
   min_first_length = 0;
   min_last_length = 0;
   min_middle_length = 0;
   for(i=0;i<part_number;i=i+1;){
      type = A_GET(parts_type,i);
      if(type == "BEND"){
         nth_part = A_GET(parts,i);
         min_first_length = get_min_before_first_bending(pipe, nth_part);
         min_last_length = get_min_after_last_bending(pipe, nth_part);
         min_middle_length = get_min_between_bendings(pipe, nth_part);
      }
   }

   /*判断弯管方向*/
   bend_direction = 1;
   first_part_type = A_GET(parts_type,0);
   first_length = 0.0;
   if(first_part_type == "TUBE"){
      nth_part = A_GET(parts,0);
      first_length = get_tube_length(pipe,nth_part);
   }
   last_part_type = A_GET(parts_type,part_number-1);
   last_length = 0.0;
   if(last_part_type == "TUBE"){
      nth_part = A_GET(parts,part_number-1);
      last_length = get_tube_length(pipe,nth_part);
   }
   if(first_length>last_length){
      bend_direction = 0;
      length = first_length;
      last_length = first_length;
      first_length = length;
   }

   /*计算余量*/
   first_extra_length = 0.0;
   last_extra_length = 0.0;
   middle_extra_length = 0.0;
   if(first_length<min_first_length){
      first_extra_length = min_first_length - first_length;
   }
   if(last_length<min_last_length){
      last_extra_length = min_last_length - last_length;
   }
   if(action_number>1){
      for(i=1;i<part_number-1;i=i+1;){
         type = A_GET(parts_type,i);
         if(type == "TUBE"){
            nth_part = A_GET(parts,i);
            tube_length = get_tube_length(pipe,nth_part);
            extra_length = 0.0;
            if(tube_length<min_middle_length){
               extra_length = min_middle_length - tube_length;
               middle_part_number = get_number_in_spool_parts(pipe,nth_part);
               put_2darray(Spool_Parts,middle_part_number,15,extra_length);
            }
            middle_extra_length = middle_extra_length + extra_length;
         }
      }
   }
   /*将弯管余量存入零件表*/
   if(first_extra_length > 0){
      if(bend_direction == 1){
         nth_part = A_GET(parts,0);
      }
      else{
         nth_part = A_GET(parts,part_number-1);
      }
      first_part_number = get_number_in_spool_parts(pipe,nth_part);
      put_2darray(Spool_Parts,first_part_number,14,first_extra_length);
   }
   if(last_extra_length > 0){
      if(bend_direction == 1){
         nth_part = A_GET(parts,part_number-1);
      }
      else{
         nth_part = A_GET(parts,0);
      }
      last_part_number = get_number_in_spool_parts(pipe,nth_part);
      put_2darray(Spool_Parts,last_part_number,16,last_extra_length);
   }


   /*获取只有一个弯头时的弯管动作数据*/
   if(action_number == 1){
      /*获取下料长度*/
      nth_part = A_GET(parts,0);
      cutting_length = get_piece_cutting_length(pipe,nth_part);
      /*计算第一个进给量*/
      feed_length = cutting_length - first_length;
      /*初始化弯管数据*/
      turn_angle = "0.0";
      bend_angle = "0.0";
      /*计算弯管动作数据*/
      for(i=0;i<part_number;i=i+1;){
         type = A_GET(parts_type,i);
         if(type == "BEND"){
            nth_part = A_GET(parts,i);
            bend_angle = PM_GET_OBJDATA(pipe,nth_part,MMT_TAG_CRVANGLE);
            bending_angle = String_To_Float(bend_angle);
            S_PRINTF(bend_angle, "%.1f", bending_angle);
         }
      }
      feed_str = "";
      S_PRINTF(feed_str, "%.1f", feed_length);
      feed_str = "-" + feed_str;
      put_2darray(Bending_Actions,item_number-1,0,feed_str);
      put_2darray(Bending_Actions,item_number-1,1,turn_angle);
      put_2darray(Bending_Actions,item_number-1,2,bend_angle);
   }
   /*获取有多个弯头时的弯管动作数据*/
   else{
      /*获取下料长度*/
      nth_part = A_GET(parts,0);
      cutting_length = get_piece_cutting_length(pipe,nth_part);
      /*计算第一个进给量*/
      feed_length = cutting_length - first_length;
      /*初始化弯管数据*/
      turn_angle = "0.0";
      bend_angle = "0.0";
      /*计算弯管动作数据*/
      /*目前的代码没有考虑两个BEND相连的情况*/
      if(bend_direction){
         action = 0;
         for(i=0;i<part_number;i=i+1;){
            type = A_GET(parts_type,i);
            if(type == "BEND"){
               nth_part = A_GET(parts,i);
               bend_angle = PM_GET_OBJDATA(pipe,nth_part,MMT_TAG_CRVANGLE);
               bending_angle = String_To_Float(bend_angle);
               S_PRINTF(bend_angle, "%.1f", bending_angle);
               /*第一个弯管动作*/
               if(i==0 | i==1){
                  feed_str = "";
                  S_PRINTF(feed_str, "%.1f", feed_length);
                  feed_str = "-" + feed_str;
                  put_2darray(Bending_Actions,item_number-1,3*action + 0,feed_str);
                  put_2darray(Bending_Actions,item_number-1,3*action + 1,turn_angle);
                  put_2darray(Bending_Actions,item_number-1,3*action + 2,bend_angle);
                  action = action + 1;
               }
               else{
                  nth_part = A_GET(parts,i-1);
                  tube_length = get_tube_length(pipe,nth_part);
                  if(tube_length<min_middle_length){
                     pull_length = min_middle_length;
                  }
                  else{
                     pull_length = tube_length;
                  }
                  pull_length_str = "";
                  S_PRINTF(pull_length_str, "%.1f", pull_length);
                  pull_length_str = "+"+pull_length_str;

                  first_bend = A_GET(parts,i-2);
                  second_bend = A_GET(parts,i);
                  turning_angle = get_turning_angle(pipe,first_bend,second_bend);

                  S_PRINTF(turn_angle, "%.1f", turning_angle);

                  put_2darray(Bending_Actions,item_number-1,3*action + 0,pull_length_str);
                  put_2darray(Bending_Actions,item_number-1,3*action + 1,turn_angle);
                  put_2darray(Bending_Actions,item_number-1,3*action + 2,bend_angle);

                  action = action + 1;
               }
            }
         }
      }
      else{
         action = 0;
         for(i=part_number-1;i>=0;i=i-1;){
            type = A_GET(parts_type,i);
            if(type == "BEND"){
               nth_part = A_GET(parts,i);
               bend_angle = PM_GET_OBJDATA(pipe,nth_part,MMT_TAG_CRVANGLE);
               bending_angle = String_To_Float(bend_angle);
               S_PRINTF(bend_angle, "%.1f", bending_angle);
               /*第一个弯管动作*/
               if(i==part_number-1 | i==part_number-2){
                  feed_str = "";
                  S_PRINTF(feed_str, "%.1f", feed_length);
                  feed_str = "-" + feed_str;
                  put_2darray(Bending_Actions,item_number-1,3*action + 0,feed_str);
                  put_2darray(Bending_Actions,item_number-1,3*action + 1,turn_angle);
                  put_2darray(Bending_Actions,item_number-1,3*action + 2,bend_angle);
                  action = action + 1;
               }
               else{
                  nth_part = A_GET(parts,i+1);
                  tube_length = get_tube_length(pipe,nth_part);
                  if(tube_length<min_middle_length){
                     pull_length = min_middle_length;
                  }
                  else{
                     pull_length = tube_length;
                  }
                  pull_length_str = "";
                  S_PRINTF(pull_length_str, "%.1f", pull_length);
                  pull_length_str = "+"+pull_length_str;

                  first_bend = A_GET(parts,i+2);
                  second_bend = A_GET(parts,i);
                  turning_angle = get_turning_angle(pipe,first_bend,second_bend);

                  S_PRINTF(turn_angle, "%.1f", turning_angle);

                  put_2darray(Bending_Actions,item_number-1,3*action + 0,pull_length_str);
                  put_2darray(Bending_Actions,item_number-1,3*action + 1,turn_angle);
                  put_2darray(Bending_Actions,item_number-1,3*action + 2,bend_angle);

                  action = action + 1;
               }
            }
         }
      }
   }
   return(0);
}

get_number_in_spool_parts(pipe,nth_part)
{
   for(i=0;i<Spool_Part_Number;i=i+1;){
      pipe0 = get_2darray(Spool_Parts,i,1);
      nth_part0 = get_2darray(Spool_Parts,i,3);
      if(pipe == pipe0 & nth_part == nth_part0){
         return(i);
      }
   }
   return(0);
}

get_turning_angle_origin(pipe,first_bend,second_bend)
{
   /*正弯*/
   x0=0.0;x1=0.0;x2=0.0;x3=0.0;
   y0=0.0;y1=0.0;y2=0.0;y3=0.0;
   z0=0.0;z1=0.0;z2=0.0;z3=0.0;
   if(second_bend>first_bend){
      /*第一个弯头的拐点坐标*/
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, first_bend, objgeom);
      PM_GET_PNT(objgeom, 1, x1, y1, z1);
      PM_FREE_PNTSET(objgeom);
      /*第二个弯头的拐点坐标*/
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, second_bend, objgeom);
      PM_GET_PNT(objgeom, 1, x2, y2, z2);
      PM_FREE_PNTSET(objgeom);
      /*第一个弯头入口坐标*/
      if(first_bend == 1){
         x0 = PM_GET_CONPNT_DATA(pipe,1,"x");
         y0 = PM_GET_CONPNT_DATA(pipe,1,"y");
         z0 = PM_GET_CONPNT_DATA(pipe,1,"z");
      }
      else
      {
         objgeom = PM_CREATE_PNTSET(10);
         PM_GET_OBJECT_GEOM(pipe, first_bend - 1, objgeom);
         PM_GET_PNT(objgeom, 1, x0, y0, z0);
         PM_FREE_PNTSET(objgeom);
      }
      /*第二个弯头出口坐标*/
      part_number = PM_NR_PARTS_IN_PIPE(pipe);
      if(second_bend == part_number){
         x3 = PM_GET_CONPNT_DATA(pipe,2,"x");
         y3 = PM_GET_CONPNT_DATA(pipe,2,"y");
         z3 = PM_GET_CONPNT_DATA(pipe,2,"z");
      }
      else
      {
         objgeom = PM_CREATE_PNTSET(10);
         PM_GET_OBJECT_GEOM(pipe, second_bend + 1, objgeom);
         PM_GET_PNT(objgeom, 0, x3, y3, z3);
         PM_FREE_PNTSET(objgeom);
      }
   }
   /*反弯*/
   else{
      /*第一个弯头的拐点坐标*/
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, first_bend, objgeom);
      PM_GET_PNT(objgeom, 1, x1, y1, z1);
      PM_FREE_PNTSET(objgeom);
      /*第二个弯头的拐点坐标*/
      objgeom = PM_CREATE_PNTSET(10);
      PM_GET_OBJECT_GEOM(pipe, second_bend, objgeom);
      PM_GET_PNT(objgeom, 1, x2, y2, z2);
      PM_FREE_PNTSET(objgeom);
      /*第一个弯头入口坐标*/
      part_number = PM_NR_PARTS_IN_PIPE(pipe);
      if(first_bend == part_number){
         x0 = PM_GET_CONPNT_DATA(pipe,2,"x");
         y0 = PM_GET_CONPNT_DATA(pipe,2,"y");
         z0 = PM_GET_CONPNT_DATA(pipe,2,"z");
      }
      else
      {
         objgeom = PM_CREATE_PNTSET(10);
         PM_GET_OBJECT_GEOM(pipe, first_bend + 1, objgeom);
         PM_GET_PNT(objgeom, 2, x0, y0, z0);
         PM_FREE_PNTSET(objgeom);
      }
      /*第二个弯头出口坐标*/
      if(second_bend == 1){
         x3 = PM_GET_CONPNT_DATA(pipe,1,"x");
         y3 = PM_GET_CONPNT_DATA(pipe,1,"y");
         z3 = PM_GET_CONPNT_DATA(pipe,1,"z");
      }
      else
      {
         objgeom = PM_CREATE_PNTSET(10);
         PM_GET_OBJECT_GEOM(pipe, second_bend - 1, objgeom);
         PM_GET_PNT(objgeom, 1, x3, y3, z3);
         PM_FREE_PNTSET(objgeom);
      }
   }
   angle = calculate_rotation(x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3);
   return(angle);
}

get_turning_angle(pipe,first_bend,second_bend)
{ 
	/*正弯*/
	x0=0.0;x1=0.0;x2=0.0;x3=0.0;
	y0=0.0;y1=0.0;y2=0.0;y3=0.0;
	z0=0.0;z1=0.0;z2=0.0;z3=0.0;
	if(second_bend>first_bend){
		/*第一个弯头的拐点坐标*/
		objgeom = PM_CREATE_PNTSET(10);
		PM_GET_OBJECT_GEOM(pipe, first_bend, objgeom);
		PM_GET_PNT(objgeom, 1, x1, y1, z1);
		/*第一个弯头入口坐标*/
		PM_GET_PNT(objgeom, 0, x0, y0, z0);		
		PM_FREE_PNTSET(objgeom); 
		/*第二个弯头的拐点坐标*/
		objgeom = PM_CREATE_PNTSET(10);
		PM_GET_OBJECT_GEOM(pipe, second_bend, objgeom);
		PM_GET_PNT(objgeom, 1, x2, y2, z2);
		/*第二个弯头出口坐标*/
		PM_GET_PNT(objgeom, 2, x3, y3, z3);
		PM_FREE_PNTSET(objgeom);
	}
	/*反弯*/
	else{
		/*第一个弯头的拐点坐标*/
		objgeom = PM_CREATE_PNTSET(10);
		PM_GET_OBJECT_GEOM(pipe, first_bend, objgeom);
		PM_GET_PNT(objgeom, 1, x1, y1, z1);
		/*第一个弯头入口坐标*/ 
		PM_GET_PNT(objgeom, 2, x0, y0, z0);		
		PM_FREE_PNTSET(objgeom); 
		/*第二个弯头的拐点坐标*/
		objgeom = PM_CREATE_PNTSET(10);
		PM_GET_OBJECT_GEOM(pipe, second_bend, objgeom);
		PM_GET_PNT(objgeom, 1, x2, y2, z2);
		/*第二个弯头出口坐标*/ 
		PM_GET_PNT(objgeom, 0, x3, y3, z3);
		PM_FREE_PNTSET(objgeom);
	}
	angle = calculate_rotation(x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3);
	return(angle);
}

/*获取直管段的长度*/
get_tube_length(pipe,nth_part)
{
   objgeom = PM_CREATE_PNTSET(10);
   PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
   xx1=0;yy1=0;zz1=0;xx2=0;yy2=0;zz2=0;
   PM_GET_PNT(objgeom, 0, xx1, yy1, zz1);
   PM_GET_PNT(objgeom, 1, xx2, yy2, zz2);
   PM_FREE_PNTSET(objgeom);
   dx=(xx1-xx2);
   dy=(yy1-yy2);
   dz=(zz1-zz2);
   return(VEC_UNITV(dx, dy, dz));
}
/*Rainbow格式的弯管表*/
draw_bending_table_rainbow()
{
   if(Bent_Piece_Number == 0){
      return(0);
   }
	style_name = "";
	drafting_style = GetFirstDraftingStyle(style_name);
   dw = PM_START_PAGE_ANNOTATION(style_name);
   DW_ACTIVATEVIEW(dw);

   InitDrawingSettings();

	DW_COLOR(Bending_Table_Line_Colour);
	DW_LTYPE(Bending_Table_Line_Type,Bending_Table_Pattern_Length);

	/*绘制横线*/
	lows = 0;
	for(i=0;i<Bent_Piece_Number;i=i+1;){
	   lows = lows + 1;
	   low_number = A_GET(Bending_Action_Number,i);
	   lows = lows + low_number;
	}
	line_number = lows + 1;
   for(i=0;i<line_number;i=i+1;){
      x1 = Bending_Table_Orign_X;
      x2 = Bending_Table_Orign_X + Bending_Table_W;
      y1 = Bending_Table_Orign_Y + i * Bending_Table_H;
      y2 = y1;
      DW_POLY(x1,y1,x2,y2);
   }
	/*绘制竖线*/
	h = (line_number - 1) * Bending_Table_H;
   x1 = Bending_Table_Orign_X;
   y1 = Bending_Table_Orign_Y;
   x2 = x1;
   y2 = y1 + h;
   DW_POLY(x1,y1,x2,y2);
   x1 = x1 + Bending_Table_Column1_W;
   y1 = Bending_Table_Orign_Y;
   x2 = x1;
   y2 = y1 + h;
   DW_POLY(x1,y1,x2,y2);
   x1 = x1 + Bending_Table_Column2_W;
   y1 = Bending_Table_Orign_Y;
   x2 = x1;
   y2 = y1 + h;
   DW_POLY(x1,y1,x2,y2);
   x1 = x1 + Bending_Table_Column3_W;
   y1 = Bending_Table_Orign_Y;
   x2 = x1;
   y2 = y1 + h;
   DW_POLY(x1,y1,x2,y2);


   /*写弯管表内容*/
	DW_TATTR(0.0,0.0,4);
	total_low = 0;
   for(i=0;i<Bent_Piece_Number;i=i+1;){

      mto_number = "件号:" + get_2darray(Bending_Table_Head,i,0);
      bending_machine = get_2darray(Bending_Table_Head,i,1);
      bending_radius = "弯模R=" + get_2darray(Bending_Table_Head,i,2);

      x = Bending_Table_Orign_X + 1;
      y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
      DW_TEXT(x, y, mto_number);

      x = x + Bending_Table_Column1_W;
      y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
      DW_TEXT(x, y, bending_machine);

      x = x + Bending_Table_Column2_W;
      y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
      DW_TEXT(x, y, bending_radius);

      total_low = total_low + 1;

      action_number = A_GET(Bending_Action_Number,i);
      for(k=0;k<action_number;k=k+1;){

         feed = get_2darray(Bending_Actions,i,3*k);
         turn_angle = get_2darray(Bending_Actions,i,3*k+1);
         bend_angle = get_2darray(Bending_Actions,i,3*k+2);

         x = Bending_Table_Orign_X + 1;
         y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
         DW_TEXT(x, y, feed);

         x = x + Bending_Table_Column1_W;
         y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
         DW_TEXT(x, y, turn_angle);

         x = x + Bending_Table_Column2_W;
         y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
         DW_TEXT(x, y, bend_angle);

         total_low = total_low + 1;
      }
   }

   PM_TERMINATE_PAGE_ANNOTATION(1);

   return(0);
}

/*一般用途的弯管表*/
draw_bending_table()
{
    if(Bent_Piece_Number == 0){
        return(0);
    }
	style_name = "";
	drafting_style = GetFirstDraftingStyle(style_name);
    dw = PM_START_PAGE_ANNOTATION(style_name);
    DW_ACTIVATEVIEW(dw);

    InitDrawingSettings();

	DW_COLOR(Bending_Table_Line_Colour);
	DW_LTYPE(Bending_Table_Line_Type,Bending_Table_Pattern_Length);

	/*将弯管表放在连接管号表的上方*/
	Bending_Table_Orign_Y = Connection_Table_Orign_Y + Connection_Table_H * (Connection_Label_Number + 2);

	/*绘制横线*/
	lows = 2;
	for(i=0;i<Bent_Piece_Number;i=i+1;){
	   lows = lows + 1;
	   low_number = A_GET(Bending_Action_Number,i);
	   lows = lows + low_number;
	}
	line_number = lows + 1;
	if(Bending_Table_Direction == "Down" ){
	   for(i=0;i<line_number;i=i+1;){
	      x1 = Bending_Table_Orign_X;
	      x2 = Bending_Table_Orign_X + Bending_Table_W;
	      y1 = Bending_Table_Orign_Y - i * Bending_Table_H;
	      y2 = y1;
	      DW_POLY(x1,y1,x2,y2);
	   }
   }
   else{
	   for(i=0;i<line_number;i=i+1;){
	      x1 = Bending_Table_Orign_X;
	      x2 = Bending_Table_Orign_X + Bending_Table_W;
	      y1 = Bending_Table_Orign_Y + i * Bending_Table_H;
	      y2 = y1;
	      DW_POLY(x1,y1,x2,y2);
	   }
   }
	/*绘制竖线*/
	h1 = (line_number - 1) * Bending_Table_H;
	h2 = (line_number - 2)* Bending_Table_H;
	if(Bending_Table_Direction == "Down" ){
	   x1 = Bending_Table_Orign_X;
	   y1 = Bending_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 - h1;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Bending_Table_Column1_W;
	   y1 = Bending_Table_Orign_Y - Bending_Table_H;
	   x2 = x1;
	   y2 = y1 - h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Bending_Table_Column2_W;
	   y1 = Bending_Table_Orign_Y - Bending_Table_H;
	   x2 = x1;
	   y2 = y1 - h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Bending_Table_Column3_W;
	   y1 = Bending_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 - h1;
	   DW_POLY(x1,y1,x2,y2);
   }
   else{
	   x1 = Bending_Table_Orign_X;
	   y1 = Bending_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 + h1;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Bending_Table_Column1_W;
	   y1 = Bending_Table_Orign_Y + Bending_Table_H;
	   x2 = x1;
	   y2 = y1 + h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Bending_Table_Column2_W;
	   y1 = Bending_Table_Orign_Y + Bending_Table_H;
	   x2 = x1;
	   y2 = y1 + h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Bending_Table_Column3_W;
	   y1 = Bending_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 + h1;
	   DW_POLY(x1,y1,x2,y2);
   }

   /*写标题*/
   DW_COLOR(Bending_Table_Text_Colour);
	DW_TSIZE(Bending_Table_Text_Height);
	DW_TATTR(0.0,0.0,5);
	if(Bending_Table_Direction == "Down" ){
      x = Bending_Table_Orign_X + Bending_Table_W / 2;
      y = Bending_Table_Orign_Y - Bending_Table_H / 2;
      text = "弯管表";
      DW_TEXT(x, y, text);

      x = Bending_Table_Orign_X + Bending_Table_Column1_W / 2;
      y = Bending_Table_Orign_Y - Bending_Table_H * 1.5;
      text = "+拉/-送";
      DW_TEXT(x, y, text);

      x = x + Bending_Table_Column1_W / 2 + Bending_Table_Column2_W / 2;
      y = Bending_Table_Orign_Y - Bending_Table_H * 1.5;
      text = "转角";
      DW_TEXT(x, y, text);

      x = x + Bending_Table_Column2_W / 2 + Bending_Table_Column3_W / 2;
      y = Bending_Table_Orign_Y - Bending_Table_H * 1.5;
      text = "弯角";
      DW_TEXT(x, y, text);
   }
   else{
      x = Bending_Table_Orign_X + Bending_Table_W / 2;
      y = Bending_Table_Orign_Y + Bending_Table_H / 2;
      text = "弯管表";
      DW_TEXT(x, y, text);

      x = Bending_Table_Orign_X + Bending_Table_Column1_W / 2;
      y = Bending_Table_Orign_Y + Bending_Table_H * 1.5;
      text = "+拉/-送";
      DW_TEXT(x, y, text);

      x = x + Bending_Table_Column1_W / 2 + Bending_Table_Column2_W / 2;
      y = Bending_Table_Orign_Y + Bending_Table_H * 1.5;
      text = "转角";
      DW_TEXT(x, y, text);

      x = x + Bending_Table_Column2_W / 2 + Bending_Table_Column3_W / 2;
      y = Bending_Table_Orign_Y + Bending_Table_H * 1.5;
      text = "弯角";
      DW_TEXT(x, y, text);
   }
   /*写弯管表内容*/
	DW_TATTR(0.0,0.0,4);
	total_low = 2;
   for(i=0;i<Bent_Piece_Number;i=i+1;){

	   if(Bending_Table_Direction == "Down" ){

	      mto_number = "件号:" + get_2darray(Bending_Table_Head,i,0);
	      bending_machine = get_2darray(Bending_Table_Head,i,1);
	      bending_radius = "弯模R=" + get_2darray(Bending_Table_Head,i,2);

         x = Bending_Table_Orign_X + 1;
         y = Bending_Table_Orign_Y - Bending_Table_H * (total_low + 0.5);
         DW_TEXT(x, y, mto_number);

         x = x + Bending_Table_Column1_W;
         y = Bending_Table_Orign_Y - Bending_Table_H * (total_low + 0.5);
         DW_TEXT(x, y, bending_machine);

         x = x + Bending_Table_Column2_W;
         y = Bending_Table_Orign_Y - Bending_Table_H * (total_low + 0.5);
         DW_TEXT(x, y, bending_radius);

         total_low = total_low + 1;

         action_number = A_GET(Bending_Action_Number,i);
         for(k=0;k<action_number;k=k+1;){

            feed = get_2darray(Bending_Actions,i,3*k);
            turn_angle = get_2darray(Bending_Actions,i,3*k+1);
            bend_angle = get_2darray(Bending_Actions,i,3*k+2);

            x = Bending_Table_Orign_X + 1;
            y = Bending_Table_Orign_Y - Bending_Table_H * (total_low + 0.5);
            DW_TEXT(x, y, feed);

            x = x + Bending_Table_Column1_W;
            y = Bending_Table_Orign_Y - Bending_Table_H * (total_low + 0.5);
            DW_TEXT(x, y, turn_angle);

            x = x + Bending_Table_Column2_W;
            y = Bending_Table_Orign_Y - Bending_Table_H * (total_low + 0.5);
            DW_TEXT(x, y, bend_angle);

            total_low = total_low + 1;
         }
	   }
	   else{
	      mto_number = "件号:" + get_2darray(Bending_Table_Head,i,0);
	      bending_machine = get_2darray(Bending_Table_Head,i,1);
	      bending_radius = "弯模R=" + get_2darray(Bending_Table_Head,i,2);

         x = Bending_Table_Orign_X + 1;
         y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
         DW_TEXT(x, y, mto_number);

         x = x + Bending_Table_Column1_W;
         y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
         DW_TEXT(x, y, bending_machine);

         x = x + Bending_Table_Column2_W;
         y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
         DW_TEXT(x, y, bending_radius);

         total_low = total_low + 1;

         action_number = A_GET(Bending_Action_Number,i);
         for(k=0;k<action_number;k=k+1;){

            feed = get_2darray(Bending_Actions,i,3*k);
            turn_angle = get_2darray(Bending_Actions,i,3*k+1);
            bend_angle = get_2darray(Bending_Actions,i,3*k+2);

            x = Bending_Table_Orign_X + 1;
            y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
            DW_TEXT(x, y, feed);

            x = x + Bending_Table_Column1_W;
            y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
            DW_TEXT(x, y, turn_angle);

            x = x + Bending_Table_Column2_W;
            y = Bending_Table_Orign_Y + Bending_Table_H * (total_low + 0.5);
            DW_TEXT(x, y, bend_angle);

            total_low = total_low + 1;
         }
	   }
   }

   PM_TERMINATE_PAGE_ANNOTATION(1);

   return(0);
}

/*获取零件的装配信息*/
/*零件装配信息的规则根据TRIBON系统的定义来确定，目前只考虑下列零件类型的装配信息
Flanges        法兰相对于参考面的转角
Branch Pieces  支管的夹角及旋转角
Elbows
Tee-Pieces
Cut
Split
*TRIBON系统中的部分零件类型的装配信息暂不考虑
Mitre
Thread
Insert
End Point Distance

*/
get_assembly_table()
{
   assembly_table = alloc_2darray(Spool_Part_Number,5);
   assembly_label_table = alloc_2darray(Spool_Part_Number,4);
   assembly_num = 0;
   for(i=0;i<Spool_Part_Number;i=i+1;){
      ass_part_type = get_2darray(Spool_Parts,i,4);
      /*法兰装配信息
      --对于主管上的法兰，优先寻找离法兰最近的弯头(包括机械弯)，如果不存在弯头，则寻找离法兰最近的三通，支管作为参考对象，
      --如果这些都不存在，则以另一端的法兰为参考对象，如果另外一端不存在法兰，则不需要装配信息
      --如果中间存在多联复板，如何处理？？？
      --对于支管上的法兰，TRIBON中只定义了支管为直管的装配情况，对于支管为直管的法兰，总是以支管与主管中心线
      --形成的平面为参考面，对于带弯的支管末端的法兰，暂时也以支管与主管中心线的平面为参考面，如果有特殊的要求，
      --可以根据客户的需要修改相关的计算方法.
      --法兰的转角目前没有根据法兰螺栓个数进行优化，如果客户有这需要，可以增进这样的算法。
      */
      /*法兰装配信息*/
      if(ass_part_type == "FLANGE"){
         ref_part_number = find_reference_part(i);
         if(ref_part_number != -1){
            get_flange_assembly_info(i,ref_part_number,assembly_table,assembly_num,assembly_label_table);
         }
      }
      /*支管装配信息*/
      else if(ass_part_type == "ROOT"){
         ref_part_number = find_reference_part(i);
         if(ref_part_number != -1){
            type = get_2darray(Spool_Parts,ref_part_number,4);
            if(type == "TUBE"){
               get_branch_assembly_info(i,ref_part_number,assembly_table,assembly_num,assembly_label_table);
            }
         }
      }
      /*支管装配信息*/
      else if(ass_part_type == "TEE"){
         ref_part_number = find_reference_part(i);
         if(ref_part_number != -1){
            get_tee_assembly_info(i,ref_part_number,assembly_table,assembly_num,assembly_label_table);
         }
      }
      /*弯头装配信息*/
      else if(ass_part_type == "ELBOW"){
         ref_part_number = find_reference_part(i);
         if(ref_part_number != -1){
            get_branch_assembly_info(i,ref_part_number,assembly_table,assembly_num,assembly_label_table);
         }
      }
      /*管材装配信息 - 首尾余量，中间割驳*/
      else if(ass_part_type == "TUBE"){
         ref_part_number = find_reference_part(i);
         if(ref_part_number != -1){
            get_piece_assembly_info(i,ref_part_number,assembly_table,assembly_num,assembly_label_table);
         }
      }
   }

	/*保存装配数量到全局变量*/
	Assembly_Number = assembly_num;
	Assembly_Label_Number = assembly_num;
	/*初始化装配表标注信息全局数组*/
	free_2darray(Assembly_Table);
    free_2darray(Assembly_Label_Table);
    Assembly_Table = alloc_2darray(Assembly_Number,5);
    Assembly_Label_Table = alloc_2darray(Assembly_Number,4);

    /*将装配表信息从临时数组拷贝到全局数组*/
	for (n = 0; n < Assembly_Number; n = n + 1;){
	    for(m = 0; m < 5; m = m + 1){
	        info = get_2darray(assembly_table,n,m);
	        put_2darray(Assembly_Table, n, m, info);
	    }
	}

    /*将装配表标注信息从临时数组拷贝到全局数组*/
	for (n = 0; n < Assembly_Number; n = n + 1;){
	    for(m = 0; m < 4; m = m + 1){
	        info = get_2darray(assembly_label_table,n,m);
	        put_2darray(Assembly_Label_Table, n, m, info);
	    }
	}

	/*释放临时数组的资源*/
	free_2darray(assembly_table);
	free_2darray(assembly_label_table);

   return(0);
}

/*获取支管的装配信息
**计算支管的夹角及转角时，首先查找可以参考的BEND或者ELBOW，如果找不到，则查找其它支管(ROOT或TEE)，如果也找不到，则查找最近的法兰；
--ass_part_number       ROOT在Spool_Parts中的序号
--ref_part_number       参考对象在Spool_Parts中的序号（连接到ROOT的支管零件）
--assembly_table        保存装配信息的数组
--assembly_num          装配顺序号
--assembly_label_table  保存装配标注信息的数组
*/
get_branch_assembly_info(ass_part_number,ref_part_number,assembly_table,assembly_num,assembly_label_table)
{
   /*获取开支管的直管中心线*/
   x0=0;y0=0;z0=0;x1=0;y1=0;z1=0;
   flag = 1;
   tube_part = 0;
   part_number = ass_part_number - 1;
   while(flag){
      part_type = get_2darray(Spool_Parts,part_number,4);
      if(part_type == "TUBE"){
         pipe = get_2darray(Spool_Parts,part_number,1);
         nth_part = get_2darray(Spool_Parts,part_number,3);
         tube_part = part_number;
         flag = 0;
      }
      part_number = part_number - 1;
   }
   objgeom = PM_CREATE_PNTSET(10);
   PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
   PM_GET_PNT(objgeom, 0, x0, y0, z0);
   PM_GET_PNT(objgeom, 1, x1, y1, z1);
   PM_FREE_PNTSET(objgeom);

   /*获取支管中心线*/
   x2=0;y2=0;z2=0;x3=0;y3=0;z3=0;
   pipe = get_2darray(Spool_Parts,ref_part_number,1);
   nth_part = get_2darray(Spool_Parts,ref_part_number,3);
   objgeom = PM_CREATE_PNTSET(10);
   PM_GET_OBJECT_GEOM(pipe, nth_part, objgeom);
   PM_GET_PNT(objgeom, 0, x2, y2, z2);
   PM_GET_PNT(objgeom, 1, x3, y3, z3);
   PM_FREE_PNTSET(objgeom);

   inclination_angle = calculate_inclination(x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3);
   incl = "";
   S_PRINTF(incl, "%.1f", inclination_angle);

   /*获取参考面对象*/
   root_ref_part = get_root_reference_part(ass_part_number);

   /*如果支管找不到参考对象*/
   if(root_ref_part == -1){
      part_no = get_2darray(Spool_Parts,ref_part_number,5);
      put_2darray(assembly_table,assembly_num,0,part_no);
      put_2darray(assembly_table,assembly_num,1,"0.0");
      put_2darray(assembly_table,assembly_num,2,incl);
      put_2darray(assembly_table,assembly_num,3,"0.0");

      /*装配参考信息*/
      info = get_2darray(Spool_Parts,ass_part_number,5);
      ref_info = "B0";
      put_2darray(assembly_table,assembly_num,4,ref_info);

      /*装配标注信息*/
      ref_label = ref_info;
      x=0;y=0;z=0;
      put_2darray(assembly_label_table,assembly_num,0,ref_label);
      x = get_2darray(Spool_Parts,tube_part,9);
      y = get_2darray(Spool_Parts,tube_part,10);
      z = get_2darray(Spool_Parts,tube_part,11);
      put_2darray(assembly_label_table,assembly_num,1,x);
      put_2darray(assembly_label_table,assembly_num,2,y);
      put_2darray(assembly_label_table,assembly_num,3,z);

      /*装配数*/
      assembly_num = assembly_num + 1;
   }
   else{
      /*计算支管转角*/
      turn_angle = calculate_branch_turn_angle(ass_part_number,ref_part_number,root_ref_part);
      turn = "";
      S_PRINTF(turn, "%.1f", turn_angle);

      /*装配信息*/
      part_no = get_2darray(Spool_Parts,ref_part_number,5);
      put_2darray(assembly_table,assembly_num,0,part_no);
      put_2darray(assembly_table,assembly_num,1,"0.0");
      put_2darray(assembly_table,assembly_num,2,incl);
      put_2darray(assembly_table,assembly_num,3,turn);

      ref_part_no = get_2darray(Spool_Parts,root_ref_part,5);
      branch_no = get_2darray(Spool_Parts,ref_part_number,0);
      ref_info = "";
      ref_part_type = get_2darray(Spool_Parts,root_ref_part,4);
      if(ref_part_type == "BEND"){
         info = get_2darray(Spool_Parts,ref_part_number,13);
         if(ISSTRING(info)){
            ref_info = "BS" + ITOASCII(branch_no) + ":P" + ref_part_no + info;
         }
         else{
            ref_info =  "BS" + ITOASCII(branch_no) + ":BP" + ref_part_no;
         }
      }
      else if(ref_part_type == "ELBOW"){
         ref_info = "BS" + ITOASCII(branch_no) + ":E" + ref_part_no;
      }
      else if(ref_part_type == "ROOT" | ref_part_type == "TEE"){
         ref_no = get_2darray(Spool_Parts,root_ref_part,0);
         ref_info = "BS" + ITOASCII(branch_no) + ":BS" + ITOASCII(ref_part_no);
      }
      else if(ref_part_type == "FLANGE"){
         ref_info = "BS" + ITOASCII(branch_no) + ":F" + ref_part_no;
      }
      put_2darray(assembly_table,assembly_num,4,ref_info);

      /*装配标注信息*/
      ref_label = "";
      x=0;y=0;z=0;
      if(ref_part_type == "BEND"){
         info = get_2darray(Spool_Parts,root_ref_part,13);
         if(ISSTRING(info)){
            ref_label =  info + "P" + ref_part_no;
         }
         else{
            ref_label =  "BP" + ref_part_no;
         }
      }
      else if(ref_part_type == "ELBOW"){
         ref_label = "E" + ref_part_no;
      }
      else if(ref_part_type == "ROOT" | ref_part_type == "TEE"){
         ref_no = get_2darray(Spool_Parts,ref_part_number,0);
         ref_label =  "BS" + ITOASCII(ref_no);
      }
      put_2darray(assembly_label_table,assembly_num,0,ref_label);
      x = get_2darray(Spool_Parts,root_ref_part,9);
      y = get_2darray(Spool_Parts,root_ref_part,10);
      z = get_2darray(Spool_Parts,root_ref_part,11);
      put_2darray(assembly_label_table,assembly_num,1,x);
      put_2darray(assembly_label_table,assembly_num,2,y);
      put_2darray(assembly_label_table,assembly_num,3,z);

      /*装配数*/
      assembly_num = assembly_num + 1;
   }
   return(0);
}

/*计算支管相对于参考对象的转角
--ass_part_number    int      支管根部零件ROOT在Spool_Parts中的序号
--ref_part_number    int      与主管相连接的支管零件在Spool_Parts中的序号
--root_ref_part      int      支管装配参考零件在Spool_Parts中的序号
*/
calculate_branch_turn_angle(ass_part_number,ref_part_number,root_ref_part)
{
   x0=0;y0=0;z0=0;
   x1=0;y1=0;z1=0;
   x2=0;y2=0;z2=0;
   x3=0;y3=0;z3=0;
   type = get_2darray(Spool_Parts,root_ref_part,4);
   if(type == "BEND" | type == "ELBOW" | type == "TEE"){
      if(root_ref_part < ass_part_number){
         x0 = get_2darray(Spool_Parts,root_ref_part-1,9);
         y0 = get_2darray(Spool_Parts,root_ref_part-1,10);
         z0 = get_2darray(Spool_Parts,root_ref_part-1,11);
         x1 = get_2darray(Spool_Parts,root_ref_part,9);
         y1 = get_2darray(Spool_Parts,root_ref_part,10);
         z1 = get_2darray(Spool_Parts,root_ref_part,11);
      }
      else{
         x0 = get_2darray(Spool_Parts,root_ref_part+1,9);
         y0 = get_2darray(Spool_Parts,root_ref_part+1,10);
         z0 = get_2darray(Spool_Parts,root_ref_part+1,11);
         x1 = get_2darray(Spool_Parts,root_ref_part,9);
         y1 = get_2darray(Spool_Parts,root_ref_part,10);
         z1 = get_2darray(Spool_Parts,root_ref_part,11);
      }
   }
   else if(type == "ROOT"){
      branch_part = get_branch_connected_part(ass_part_number);
      x0 = get_2darray(Spool_Parts,branch_part,6);
      y0 = get_2darray(Spool_Parts,branch_part,7);
      z0 = get_2darray(Spool_Parts,branch_part,8);
      x1 = get_2darray(Spool_Parts,root_ref_part,9);
      y1 = get_2darray(Spool_Parts,root_ref_part,10);
      z1 = get_2darray(Spool_Parts,root_ref_part,11);
   }
   else if(type == "FLANGE"){
      /*法兰端面连接点坐标 - 直接使用其标注点坐标*/
      x1 = get_2darray(Spool_Parts,root_ref_part,9);
      y1 = get_2darray(Spool_Parts,root_ref_part,10);
      z1 = get_2darray(Spool_Parts,root_ref_part,11);
      /*判断法兰的方向是否垂直于XY平面，如果是则法兰转角的理论线方向为Y方向，否则为Z方向*/
      pipe = get_2darray(Spool_Parts,root_ref_part,1);
      nth_part = get_2darray(Spool_Parts,root_ref_part,3);
      slope_angle = PM_GET_OBJDATA(pipe,nth_part,MMT_TAG_AXIS_SLP_ANGLE);
      if(slope_angle == "90" | slope_angle == "-90"){
         x0 = x1;
         y0 = y1 + 1000;
         z0 = z1;
      }
      else{
         x0 = x1;
         y0 = y1;
         z0 = z1 + 1000;
      }
   }
   x2 = get_2darray(Spool_Parts,ass_part_number,9);
   y2 = get_2darray(Spool_Parts,ass_part_number,10);
   z2 = get_2darray(Spool_Parts,ass_part_number,11);
   x3 = get_2darray(Spool_Parts,ref_part_number,6);
   y3 = get_2darray(Spool_Parts,ref_part_number,7);
   z3 = get_2darray(Spool_Parts,ref_part_number,8);
   angle = calculate_rotation(x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3);
   return(angle);
}

/*查找计算支管转角的参考零件
**首先查找可以参考的BEND或者ELBOW，如果找不到，则查找其它支管(ROOT或TEE)，如果也找不到，则查找最近的法兰；
--ass_part_number       ROOT在Spool_Parts中的序号
*/
get_root_reference_part(ass_part_number)
{
   bend = 0;
   elbow = 0;
   root = 0;
   tee = 0;
   flange = 0;
   /*向后查找*/
   flag = 1;
   part_number = ass_part_number + 1;
   while(flag){
      branch_number = get_2darray(Spool_Parts,part_number,0);
      if(branch_number !=0){
         flag = 0;
      }
      else{
         type = get_2darray(Spool_Parts,part_number,4);
         if(type == "BEND" & bend == 0){
            bend = part_number;
         }
         else if(type == "ELBOW" & elbow == 0){
            elbow = part_number;
         }
         else if(type == "ROOT" & root == 0){
            root = part_number;
         }
         else if(type == "TEE" & tee == 0){
            tee = part_number;
         }
         else if(type == "FLANGE" & tee == 0){
            flange = part_number;
         }
      }
      part_number = part_number + 1;
   }
   /*向前查找*/
   flag = 1;
   part_number = ass_part_number - 1;
   while(flag){
      if(part_number < 0){
         flag = 0;
      }
      else{
         type = get_2darray(Spool_Parts,part_number,4);
         if(type == "BEND" & bend == 0){
            bend = part_number;
         }
         else if(type == "ELBOW" & elbow == 0){
            elbow = part_number;
         }
         else if(type == "ROOT" & root == 0){
            root = part_number;
         }
         else if(type == "TEE" & tee == 0){
            tee = part_number;
         }
         else if(type == "FLANGE" & tee == 0){
            flange = part_number;
         }
      }
      part_number = part_number - 1;
   }
   /*根据参考对象的优先顺序返回查找结果*/
   if (bend != 0){
      return(bend);
   }
   else if(elbow != 0){
      return(elbow);
   }
   else if(root != 0){
      return(root);
   }
   else if(tee != 0){
      return(tee);
   }
   else if(flange != 0){
      return(flange);
   }
   else{
      return(-1);
   }
   return(-1);
}

/*计算支管与主管的夹角
--x0,y0,z0,x1,y1,z1     float    开支管的直段首末端点坐标
--x2,y2,z2,x3,y3,z3     float    连接到主管的支管直段首末端点坐标
*/
calculate_inclination(x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3)
{
   dx1 = x1-x0;
   dy1 = y1-y0;
   dz1 = z1-z0;
   dx2 = x3-x2;
   dy2 = y3-y2;
   dz2 = z3-z2;
   angle = PiGetAngle(dx1, dy1, dz1, dx2, dy2, dz2);
   if(angle>90){
      angle = 180 - angle;
   }
   return(angle);
}

/*
*/
get_piece_assembly_info(ass_part_number,ref_part_number,assembly_table,assembly_num,assembly_label_table)
{
   return(0);
}

get_tee_assembly_info(ass_part_number,ref_part_number,assembly_table,assembly_num,assembly_label_table)
{
   return(0);
}

/*获取法兰的装配信息
--ass_part_number       法兰在Spool_Parts中的序号
--ref_part_number       参考对象在Spool_Parts中的序号
--assembly_table        保存装配信息的数组
--assembly_num          装配顺序号
--assembly_label_table  保存装配标注信息的数组
*/
get_flange_assembly_info(ass_part_number,ref_part_number,assembly_table,assembly_num,assembly_label_table)
{
   ass_part_sequence = get_2darray(Spool_Parts,ass_part_number,3);
   ass_part_pipe = get_2darray(Spool_Parts,ass_part_number,1);
   ass_part_branch = get_2darray(Spool_Parts,ass_part_number,0);
   ref_part_type = get_2darray(Spool_Parts,ref_part_number,4);
   ref_part_pipe = get_2darray(Spool_Parts,ref_part_number,1);
   ref_part_sequence = get_2darray(Spool_Parts,ref_part_number,3);
   /*法兰端面连接点坐标 - 直接使用其标注点坐标*/
   x1 = get_2darray(Spool_Parts,ass_part_number,9);
   y1 = get_2darray(Spool_Parts,ass_part_number,10);
   z1 = get_2darray(Spool_Parts,ass_part_number,11);
   /*判断法兰的方向是否垂直于XY平面，如果是则法兰转角的理论线方向为Y方向，否则为Z方向*/
   ass_part_slope_angle = PM_GET_OBJDATA(ass_part_pipe,ass_part_sequence,MMT_TAG_AXIS_SLP_ANGLE);
   if(ass_part_slope_angle == "90" | ass_part_slope_angle == "-90"){
      x0 = x1;
      y0 = y1 + 1000;
      z0 = z1;
   }
   else{
      x0 = x1;
      y0 = y1;
      z0 = z1 + 1000;
   }
   /*参考零件中心点坐标：弯头拐点坐标，三通中心线交点，支管与主管交点坐标*/
   x2 = get_2darray(Spool_Parts,ref_part_number,9);
   y2 = get_2darray(Spool_Parts,ref_part_number,10);
   z2 = get_2darray(Spool_Parts,ref_part_number,11);
   /*参考零件相对装配零件的反方向出口坐标*/
   x3=0;y3=0;z3=0;

   if(ref_part_type == "BEND" | ref_part_type == "ELBOW"){
      /*主管首端法兰*/
      if(ass_part_number == 0){
         x3 = get_2darray(Spool_Parts,ref_part_number + 1,9);
         y3 = get_2darray(Spool_Parts,ref_part_number + 1,10);
         z3 = get_2darray(Spool_Parts,ref_part_number + 1,11);
      }
      /*主管末端法兰*/
      else if(ass_part_branch == 0){
         x3 = get_2darray(Spool_Parts,ref_part_number - 1,9);
         y3 = get_2darray(Spool_Parts,ref_part_number - 1,10);
         z3 = get_2darray(Spool_Parts,ref_part_number - 1,11);
      }
      /*支管法兰*/
      else{
         x3 = get_2darray(Spool_Parts,ref_part_number - 1,9);
         y3 = get_2darray(Spool_Parts,ref_part_number - 1,10);
         z3 = get_2darray(Spool_Parts,ref_part_number - 1,11);
      }
   }
   else if(ref_part_type == "ROOT"){
      /*主管首端法兰*/
      if(ass_part_number == 0){
         node_id = get_2darray(Spool_Parts,ref_part_number,3);
         connected_node_id = 0;
         connected_obj = PM_GET_CONNECTED_OBJECT(ass_part_pipe,node_id,connected_node_id);
         branch_first_part = get_branch_first_part(connected_obj);
         x3 = get_2darray(Spool_Parts,branch_first_part,6);
         y3 = get_2darray(Spool_Parts,branch_first_part,7);
         z3 = get_2darray(Spool_Parts,branch_first_part,8);
      }
      /*主管末端法兰*/
      else if(ass_part_branch == 0){
         node_id = get_2darray(Spool_Parts,ref_part_number,3);
         connected_node_id = 0;
         connected_obj = PM_GET_CONNECTED_OBJECT(ass_part_pipe,node_id,connected_node_id);
         branch_first_part = get_branch_first_part(connected_obj);
         x3 = get_2darray(Spool_Parts,branch_first_part,6);
         y3 = get_2darray(Spool_Parts,branch_first_part,7);
         z3 = get_2darray(Spool_Parts,branch_first_part,8);
      }
      /*支管法兰*/
      else{
         x3 = get_2darray(Spool_Parts,ref_part_number - 1,9);
         y3 = get_2darray(Spool_Parts,ref_part_number - 1,10);
         z3 = get_2darray(Spool_Parts,ref_part_number - 1,11);
      }
   }
   else if(ref_part_type == "TEE"){
      /*主管首端法兰*/
      if(ass_part_number == 0){
         x3 = String_To_Float(PM_GET_CONPNT_DATA(ref_part_pipe,3,"x"));
         y3 = String_To_Float(PM_GET_CONPNT_DATA(ref_part_pipe,3,"y"));
         z3 = String_To_Float(PM_GET_CONPNT_DATA(ref_part_pipe,3,"z"));
      }
      /*主管末端法兰*/
      else if(ass_part_branch == 0){
         x3 = String_To_Float(PM_GET_CONPNT_DATA(ref_part_pipe,3,"x"));
         y3 = String_To_Float(PM_GET_CONPNT_DATA(ref_part_pipe,3,"y"));
         z3 = String_To_Float(PM_GET_CONPNT_DATA(ref_part_pipe,3,"z"));
      }
      /*支管法兰*/
      else{
         x3 = String_To_Float(PM_GET_CONPNT_DATA(ref_part_pipe,2,"x"));
         y3 = String_To_Float(PM_GET_CONPNT_DATA(ref_part_pipe,2,"y"));
         z3 = String_To_Float(PM_GET_CONPNT_DATA(ref_part_pipe,2,"z"));
      }
   }
   else if(ref_part_type == "FLANGE"){
      ref_part_slope_angle = PM_GET_OBJDATA(ref_part_pipe,ref_part_sequence,MMT_TAG_AXIS_SLP_ANGLE);
      if(ref_part_slope_angle == "90" | ref_part_slope_angle == "-90"){
         x3 = x2;
         y3 = y2 + 1000;
         z3 = z2;
      }
      else{
         x3 = x2;
         y3 = y2;
         z3 = z2 + 1000;
      }
   }
   /*计算法兰转角*/
   rotate_angle = calculate_rotation(x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3);
   recalculate_flange_rotate_angle(rotate_angle,ass_part_number);
   rotate = "";
   S_PRINTF(rotate, "%.1f", rotate_angle);
   part_no = get_2darray(Spool_Parts,ass_part_number,5);
   put_2darray(assembly_table,assembly_num,0,part_no);
   put_2darray(assembly_table,assembly_num,1,rotate);
   put_2darray(assembly_table,assembly_num,2,"0.0");
   put_2darray(assembly_table,assembly_num,3,"0.0");

   /*装配信息*/
   ref_part_no = get_2darray(Spool_Parts,ref_part_number,5);
   ref_info = "";
   if(ref_part_type == "BEND"){
      info = get_2darray(Spool_Parts,ref_part_number,13);
      if(ISSTRING(info)){
         ref_info =  info + "P" + ref_part_no + ":     :";
      }
      else{
         ref_info =  "BP" + ref_part_no + ":     :";
      }
   }
   else if(ref_part_type == "ELBOW"){
      ref_info =  "E" + ref_part_no + ":     :";
   }
   else if(ref_part_type == "ROOT" | ref_part_type == "TEE"){
      ref_no = get_2darray(Spool_Parts,ass_part_number,0);
      ref_info =  "BS" + ITOASCII(ref_no) + ":     :";
   }
   put_2darray(assembly_table,assembly_num,4,ref_info);

   /*装配标注信息*/
   ref_label = "";
   x=0;y=0;z=0;
   if(ref_part_type == "BEND"){
      info = get_2darray(Spool_Parts,ref_part_number,13);
      if(ISSTRING(info)){
         ref_label =  info + "P" + ref_part_no;
      }
      else{
         ref_label =  "BP" + ref_part_no;
      }
   }
   else if(ref_part_type == "ELBOW"){
      ref_label = "E" + ref_part_no;
   }
   else if(ref_part_type == "ROOT" | ref_part_type == "TEE"){
      ref_no = get_2darray(Spool_Parts,ass_part_number,0);
      ref_label =  "BS" + ITOASCII(ref_no);
   }
   put_2darray(assembly_label_table,assembly_num,0,ref_label);
   x = get_2darray(Spool_Parts,ref_part_number,9);
   y = get_2darray(Spool_Parts,ref_part_number,10);
   z = get_2darray(Spool_Parts,ref_part_number,11);
   put_2darray(assembly_label_table,assembly_num,1,x);
   put_2darray(assembly_label_table,assembly_num,2,y);
   put_2darray(assembly_label_table,assembly_num,3,z);

   /*装配数*/
   assembly_num = assembly_num + 1;
}

/*根据法兰螺栓孔个数优化转角数值*/
recalculate_flange_rotate_angle(rotate_angle,ass_part_number)
{
   if(rotate_angle == -90){
      rotate_angle = 90;
   }
   if(rotate_angle == 180 | rotate_angle == -180){
      rotate_angle = 0;
   }
   bolt_number = get_flange_bolt_number(ass_part_number);
   if(bolt_number !=0 ){
      angle = 360.0 / bolt_number;
      flag = 1;
      while(flag){
         rotate_angle = rotate_angle - angle;
         if(rotate_angle < angle){
            flag = 0;
         }
      }
   }
   return(0);
}

/*获取法兰的螺栓个数
--暂时还想不到抽取这个数据的办法
*/
get_flange_bolt_number(ass_part_number)
{
   return(0);
}

/*获取支管连接到根部的零件
--pipe_handle     handle      支管的handle
*/
get_branch_first_part(pipe_handle)
{
   for(i=0;i<Spool_Part_Number;i=i+1;){
      pipe = get_2darray(Spool_Parts,i,1);
      if(pipe == pipe_handle){
         return(i);
      }
   }
}

/*获取支管连接到根部的零件
--root_part     int      支管根部零件ROOT在Spool_Parts中的序号
*/
get_branch_connected_part(root_part)
{
   pipe = get_2darray(Spool_Parts,root_part,1);
   node_id = get_2darray(Spool_Parts,root_part,3);
   connected_node_id = 0;
   connected_obj = PM_GET_CONNECTED_OBJECT(pipe,node_id,connected_node_id);
   branch_first_part = get_branch_first_part(connected_obj);
   return(branch_first_part);
}

/*查找零件的装配参考对象
**ass_part_number    int      零件在Spool_Parts中的序号
*/
find_reference_part(ass_part_number)
{
   ass_part_type = get_2darray(Spool_Parts,ass_part_number,4);
   /*零件为法兰*/
   if(ass_part_type == "FLANGE"){
      ass_part_branch = get_2darray(Spool_Parts,ass_part_number,0);
      /*主管首端法兰*/
      if(ass_part_number == 0){
         loop_flag = 1;
         part_number = 1;
         bend_elbow = 0;
         root_tee = 0;
         flange = 0;
         while(loop_flag){
            type = get_2darray(Spool_Parts,part_number,4);
            branch = get_2darray(Spool_Parts,part_number,0);
            if((type == "BEND" | type == "ELBOW") & bend_elbow == 0){
               bend_elbow = part_number;
            }
            else if((type == "ROOT" | type == "TEE") & root_tee == 0){
               root_tee = part_number;
            }
            else if(type == "FLANGE" & flange == 0){
               flange = part_number;
            }
            part_number = part_number + 1;
            /*如果已经找遍整个管段的零件，则结束查找*/
            if(part_number >= Spool_Part_Number){
               loop_flag = 0;
            }
            /*如果已经查找完主管零件，结束查找*/
            if(branch != ass_part_branch){
               loop_flag = 0;
            }
         }
         /*按参考对象的优先级顺序返回参考零件的编号*/
         if(bend_elbow != 0){
            return(bend_elbow);
         }
         else if(root_tee != 0){
            return(root_tee);
         }
         else if(flange != 0){
            return(flange);
         }
         else{
            return(-1);
         }
      }
      /*主管末端法兰*/
      else if(ass_part_branch == 0){
         loop_flag = 1;
         part_number = ass_part_number - 1;
         bend_elbow = 0;
         root_tee = 0;
         flange = 0;
         while(loop_flag){
            type = get_2darray(Spool_Parts,part_number,4);
            if((type == "BEND" | type == "ELBOW") & bend_elbow == 0){
               bend_elbow = part_number;
            }
            else if((type == "ROOT" | type == "TEE") & root_tee == 0){
               root_tee = part_number;
            }
            else if(type == "FLANGE" & flange == 0){
               flange = part_number;
            }
            part_number = part_number - 1;
            /*如果已经找遍整个主管的零件，则结束查找*/
            if(part_number < 0){
               loop_flag = 0;
            }
         }
         /*按参考对象的优先级顺序返回参考零件的编号*/
         if(bend_elbow != 0){
            return(bend_elbow);
         }
         else if(root_tee != 0){
            return(root_tee);
         }
         else if(flange != 0){
            return(flange);
         }
         else{
            return(-1);
         }
      }
      /*支管法兰*/
      else{
         loop_flag = 1;
         part_number = ass_part_number - 1;
         bend_elbow = 0;
         while(loop_flag){
            type = get_2darray(Spool_Parts,part_number,4);
            branch_number = get_2darray(Spool_Parts,part_number,0);
            if((type == "BEND" | type == "ELBOW") & bend_elbow == 0){
               bend_elbow = part_number;
            }
            part_number = part_number - 1;
            /*如果已经找遍整个支管的零件，则结束查找*/
            if(branch_number != ass_part_branch){
               loop_flag = 0;
            }
         }
         /*如果存在弯头，则返回其零件编号*/
         if(bend_elbow != 0){
            return(bend_elbow);
         }
         /*查找对应的ROOT或者TEE*/
         else{
            root_tee = get_root_part(ass_part_number);
            return(root_tee);
         }
      }
   }
   /*查找支管连接到支管根部的零件*/
   else if(ass_part_type == "ROOT"){
      node_id = get_2darray(Spool_Parts,ass_part_number,3);
      pipe0 = get_2darray(Spool_Parts,ass_part_number,1);
      connected_node_id = 0;
      branch_pipe = PM_GET_CONNECTED_OBJECT(pipe0,node_id,connected_node_id);
      for(i=0;i<Spool_Part_Number;i=i+1;){
         pipe = get_2darray(Spool_Parts,i,1);
         if(branch_pipe == pipe){
            return(i);
         }
      }
   }
   return(-1);
}

/*获取零件所在的支管与主管的连接零件,ROOT或者TEE
**ass_part_number    int   支管上的装配件（通常是法兰）在Spool_Parts中的序号
*/
get_root_part(ass_part_number)
{
   branch_pipe = get_2darray(Spool_Parts,ass_part_number,1);
   sequence2 = get_2darray(Spool_Parts,ass_part_number,3);
   sequence1 = get_2darray(Spool_Parts,ass_part_number-1,3);
   node_id = 0;
   if(sequence2 > sequence1){
      main_pipe = PM_GET_CONNECTED_OBJECT(branch_pipe, 1, node_id);
   }
   else{
      main_pipe = PM_GET_CONNECTED_OBJECT(branch_pipe, 2, node_id);
   }
   parts_number = PM_NR_PARTS_IN_PIPE(main_pipe);
   /*如果支管连接到TEE上*/
   if(parts_number == -1){
      for(i=0;i<Spool_Part_Number;i=i+1;){
         part_handle = get_2darray(Spool_Parts,i,1);
         if(main_pipe == part_handle){
            ref_part_number = i;
            return(ref_part_number);
         }
      }
   }
   else{
      for(i=0;i<Spool_Part_Number;i=i+1;){
         pipe_handle = get_2darray(Spool_Parts,i,1);
         type = get_2darray(Spool_Parts,i,4);
         id = get_2darray(Spool_Parts,i,3);
         if(main_pipe == pipe_handle & type == "ROOT" & id == node_id){
            ref_part_number = i;
            return(ref_part_number);
         }
      }
   }
   return(0);
}

draw_assembly_table()
{
    if(Assembly_Number == 0){
        return(0);
    }
	style_name = "";
	drafting_style = GetFirstDraftingStyle(style_name);
    dw = PM_START_PAGE_ANNOTATION(style_name);
    DW_ACTIVATEVIEW(dw);

    InitDrawingSettings();

	DW_COLOR(Assembly_Table_Line_Colour);
	DW_LTYPE(Assembly_Table_Line_Type,Assembly_Table_Pattern_Length);

	/*绘制横线*/
	line_number = Assembly_Number + 3;
	if(Assembly_Table_Direction == "Down" ){
	    for(i=0;i<line_number;i=i+1;){
	        x1 = Assembly_Table_Orign_X;
	        x2 = Assembly_Table_Orign_X + Assembly_Table_W;
	        y1 = Assembly_Table_Orign_Y - i * Assembly_Table_H;
	        y2 = y1;
	        DW_POLY(x1,y1,x2,y2);
	    }
    }
    else{
	    for(i=0;i<line_number;i=i+1;){
	        x1 = Assembly_Table_Orign_X;
	        x2 = Assembly_Table_Orign_X + Assembly_Table_W;
	        y1 = Assembly_Table_Orign_Y + i * Assembly_Table_H;
	        y2 = y1;
	        DW_POLY(x1,y1,x2,y2);
	    }
    }
	/*绘制竖线*/
	line_number = Assembly_Number + 2;
	h1 = line_number * Assembly_Table_H;
	h2 = (line_number - 1)* Assembly_Table_H;
	if(Assembly_Table_Direction == "Down" ){
	    x1 = Assembly_Table_Orign_X;
	    y1 = Assembly_Table_Orign_Y;
	    x2 = x1;
	    y2 = y1 - h1;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Assembly_Table_Column1_W;
	    y1 = Assembly_Table_Orign_Y - Assembly_Table_H;
	    x2 = x1;
	    y2 = y1 - h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Assembly_Table_Column2_W;
	    y1 = Assembly_Table_Orign_Y - Assembly_Table_H;
	    x2 = x1;
	    y2 = y1 - h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Assembly_Table_Column3_W;
	    y1 = Assembly_Table_Orign_Y - Assembly_Table_H;
	    x2 = x1;
	    y2 = y1 - h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Assembly_Table_Column4_W;
	    y1 = Assembly_Table_Orign_Y - Assembly_Table_H;
	    x2 = x1;
	    y2 = y1 - h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Assembly_Table_Column5_W;
	    y1 = Assembly_Table_Orign_Y;
	    x2 = x1;
	    y2 = y1 - h1;
	    DW_POLY(x1,y1,x2,y2);
    }
    else{
	    x1 = Assembly_Table_Orign_X;
	    y1 = Assembly_Table_Orign_Y;
	    x2 = x1;
	    y2 = y1 + h1;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Assembly_Table_Column1_W;
	    y1 = Assembly_Table_Orign_Y + Assembly_Table_H;
	    x2 = x1;
	    y2 = y1 + h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Assembly_Table_Column2_W;
	    y1 = Assembly_Table_Orign_Y + Assembly_Table_H;
	    x2 = x1;
	    y2 = y1 + h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Assembly_Table_Column3_W;
	    y1 = Assembly_Table_Orign_Y + Assembly_Table_H;
	    x2 = x1;
	    y2 = y1 + h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Assembly_Table_Column4_W;
	    y1 = Assembly_Table_Orign_Y + Assembly_Table_H;
	    x2 = x1;
	    y2 = y1 + h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Assembly_Table_Column5_W;
	    y1 = Assembly_Table_Orign_Y;
	    x2 = x1;
	    y2 = y1 + h1;
	    DW_POLY(x1,y1,x2,y2);
    }
    /*写标题*/
    DW_COLOR(Assembly_Table_Text_Colour);
	DW_TSIZE(Assembly_Table_Text_Height);
	DW_TATTR(0.0,0.0,5);
	if(Assembly_Table_Direction == "Down" ){
        x = Assembly_Table_Orign_X + Assembly_Table_W / 2;
        y = Assembly_Table_Orign_Y - Assembly_Table_H / 2;
        text = "装配信息";
        DW_TEXT(x, y, text);
        
        x = Assembly_Table_Orign_X + Assembly_Table_Column1_W / 2;
        y = Assembly_Table_Orign_Y - Assembly_Table_H * 1.5;
        text = "零件号";
        DW_TEXT(x, y, text);
        
        x = x + Assembly_Table_Column1_W / 2 + Assembly_Table_Column2_W / 2;
        y = Assembly_Table_Orign_Y - Assembly_Table_H * 1.5;
        text = "法兰转角";
        DW_TEXT(x, y, text);
        
        x = x + Assembly_Table_Column2_W / 2 + Assembly_Table_Column3_W / 2;
        y = Assembly_Table_Orign_Y - Assembly_Table_H * 1.5;
        text = "支管夹角";
        DW_TEXT(x, y, text);
        
        x = x + Assembly_Table_Column3_W / 2 + Assembly_Table_Column4_W / 2;
        y = Assembly_Table_Orign_Y - Assembly_Table_H * 1.5;
        text = "支管转角";
        DW_TEXT(x, y, text);
        
        x = x + Assembly_Table_Column4_W / 2 + Assembly_Table_Column5_W / 2;
        y = Assembly_Table_Orign_Y - Assembly_Table_H * 1.5;
        text = "参考信息";
        DW_TEXT(x, y, text);
    }
    else{
        x = Assembly_Table_Orign_X + Assembly_Table_W / 2;
        y = Assembly_Table_Orign_Y + Assembly_Table_H / 2;
        text = "装配信息";
        DW_TEXT(x, y, text);
        
        x = Assembly_Table_Orign_X + Assembly_Table_Column1_W / 2;
        y = Assembly_Table_Orign_Y + Assembly_Table_H * 1.5;
        text = "零件号";
        DW_TEXT(x, y, text);
        
        x = x + Assembly_Table_Column1_W / 2 + Assembly_Table_Column2_W / 2;
        y = Assembly_Table_Orign_Y + Assembly_Table_H * 1.5;
        text = "法兰转角";
        DW_TEXT(x, y, text);
        
        x = x + Assembly_Table_Column2_W / 2 + Assembly_Table_Column3_W / 2;
        y = Assembly_Table_Orign_Y + Assembly_Table_H * 1.5;
        text = "支管夹角";
        DW_TEXT(x, y, text);
        
        x = x + Assembly_Table_Column3_W / 2 + Assembly_Table_Column4_W / 2;
        y = Assembly_Table_Orign_Y + Assembly_Table_H * 1.5;
        text = "支管转角";
        DW_TEXT(x, y, text);
        
        x = x + Assembly_Table_Column4_W / 2 + Assembly_Table_Column5_W / 2;
        y = Assembly_Table_Orign_Y + Assembly_Table_H * 1.5;
        text = "参考信息";
        DW_TEXT(x, y, text);
    }
    /*写连接表内容*/
	DW_TATTR(0.0,0.0,4);
    for(i=0;i<Assembly_Number;i=i+1;){
	    if(Assembly_Table_Direction == "Down" ){
            x = Assembly_Table_Orign_X + 1;
            y = Assembly_Table_Orign_Y - Assembly_Table_H * (i + 2.5);
            text = get_2darray(Assembly_Table,i,0);
            DW_TEXT(x, y, text);
            
            x = x + Assembly_Table_Column1_W;
            y = Assembly_Table_Orign_Y - Assembly_Table_H * (i + 2.5);
            text = get_2darray(Assembly_Table,i,1);
            DW_TEXT(x, y, text);
            
            x = x + Assembly_Table_Column2_W;
            y = Assembly_Table_Orign_Y - Assembly_Table_H * (i + 2.5);
            text = get_2darray(Assembly_Table,i,2);
            DW_TEXT(x, y, text);
            
            x = x + Assembly_Table_Column3_W;
            y = Assembly_Table_Orign_Y - Assembly_Table_H * (i + 2.5);
            text = get_2darray(Assembly_Table,i,3);
            DW_TEXT(x, y, text);
            
            x = x + Assembly_Table_Column4_W;
            y = Assembly_Table_Orign_Y - Assembly_Table_H * (i + 2.5);
            text = get_2darray(Assembly_Table,i,4);
            DW_TEXT(x, y, text);
	    }
	    else{
            x = Assembly_Table_Orign_X + 1;
            y = Assembly_Table_Orign_Y + Assembly_Table_H * (i + 2.5);
            text = get_2darray(Assembly_Table,i,0);
            DW_TEXT(x, y, text);
            
            x = x + Assembly_Table_Column1_W;
            y = Assembly_Table_Orign_Y + Assembly_Table_H * (i + 2.5);
            text = get_2darray(Assembly_Table,i,1);
            DW_TEXT(x, y, text);
            
            x = x + Assembly_Table_Column2_W;
            y = Assembly_Table_Orign_Y + Assembly_Table_H * (i + 2.5);
            text = get_2darray(Assembly_Table,i,2);
            DW_TEXT(x, y, text);
            
            x = x + Assembly_Table_Column3_W;
            y = Assembly_Table_Orign_Y + Assembly_Table_H * (i + 2.5);
            text = get_2darray(Assembly_Table,i,3);
            DW_TEXT(x, y, text);
            
            x = x + Assembly_Table_Column4_W;
            y = Assembly_Table_Orign_Y + Assembly_Table_H * (i + 2.5);
            text = get_2darray(Assembly_Table,i,4);
            DW_TEXT(x, y, text);
	    }
    }

    PM_TERMINATE_PAGE_ANNOTATION(1);
}

/*获取管段校管信息及连接信息*/
/*校管表内容
1 - node number      节点位置，只写管端编号
2 - x_offset         节点相对于第一个管端端点的x坐标偏移量
3 - y_offset         节点相对于第一个管端端点的y坐标偏移量
4 - z_offset         节点相对于第一个管端端点的z坐标偏移量
*/
/*连接表内容
1 - node number      节点位置，只写管端编号
2 - x                节点x坐标(绝对坐标)
3 - y                节点y坐标(绝对坐标)
4 - z                节点z坐标(绝对坐标)
5 - connected object 连接对象
*/
/*连接点标注信息
1 - node number      节点位置，只写管端编号
2 - x                节点x坐标(绝对坐标)
3 - y                节点y坐标(绝对坐标)
4 - z                节点z坐标(绝对坐标)
*/
get_check_table_and_connection_table()
{
   if(Debug){
      U_MESSAGE("*****************开始计算校管表及连接表数据***********************");
   }

   /*定义用于临时保存零件信息的数组*/
   check_table = alloc_2darray(Max_Spool_Parts_Number,4);
   connection_table = alloc_2darray(Max_Spool_Parts_Number,5);
   connection_label_table = alloc_2darray(Max_Spool_Parts_Number,4);
   check_node_number = 0;
   connection_node_number = 0;
   /*初始化相关变量*/
   float x0,y0,z0;
   x0=0;y0=0;z0=0;
   /*处理管段只有一个零件的情况*/
   if(Spool_Part_Number == 1){
      pipe = get_2darray(Spool_Parts,0,1);
      x = ""; y = ""; z = "";
      x = PM_GET_CONPNT_DATA(pipe,1,"x");
      y = PM_GET_CONPNT_DATA(pipe,1,"y");
      z = PM_GET_CONPNT_DATA(pipe,1,"z");
      x0=String_To_Float(x);
      y0=String_To_Float(y);
      z0=String_To_Float(z);
      /*保存校管坐标*/
      node_name = "C" + ITOASCII(connection_node_number + 1);
      put_2darray(check_table,check_node_number,0,node_name);
      put_2darray(check_table,check_node_number,1,"0");
      put_2darray(check_table,check_node_number,2,"0");
      put_2darray(check_table,check_node_number,3,"0");
      /*保存管端编号及其标注坐标*/
      put_2darray(connection_label_table,connection_node_number,0,node_name);
      put_2darray(connection_label_table,connection_node_number,1,x0);
      put_2darray(connection_label_table,connection_node_number,2,y0);
      put_2darray(connection_label_table,connection_node_number,3,z0);
      /*保存管端信息表*/
      x_ref="";y_ref="";z_ref="";
      get_connection_ref(x0, y0, z0, x_ref, y_ref, z_ref);
      connect_name = get_connection_name(pipe,1);
      put_2darray(connection_table,connection_node_number,0,node_name);
      put_2darray(connection_table,connection_node_number,1,x_ref);
      put_2darray(connection_table,connection_node_number,2,y_ref);
      put_2darray(connection_table,connection_node_number,3,z_ref);
      put_2darray(connection_table,connection_node_number,4,connect_name);
      check_node_number = check_node_number + 1;
      connection_node_number = connection_node_number + 1;

      x = PM_GET_CONPNT_DATA(pipe,2,"x");
      y = PM_GET_CONPNT_DATA(pipe,2,"y");
      z = PM_GET_CONPNT_DATA(pipe,2,"z");
      x1=String_To_Float(x);
      y1=String_To_Float(y);
      z1=String_To_Float(z);

      x_offset = x1 - x0;
      y_offset = y1 - y0;
      z_offset = z1 - z0;

      off_x = "";
      S_PRINTF(off_x, "%d", x_offset);
      off_y = "";
      S_PRINTF(off_y, "%d", y_offset);
      off_z = "";
      S_PRINTF(off_z, "%d", z_offset);

      /*保存校管坐标*/
      node_name = "C" + ITOASCII(connection_node_number+1);
      put_2darray(check_table,check_node_number,0,node_name);
      put_2darray(check_table,check_node_number,1,off_x);
      put_2darray(check_table,check_node_number,2,off_y);
      put_2darray(check_table,check_node_number,3,off_z);
      /*保存管端编号及其标注坐标*/
      put_2darray(connection_label_table,connection_node_number,0,node_name);
      put_2darray(connection_label_table,connection_node_number,1,x1);
      put_2darray(connection_label_table,connection_node_number,2,y1);
      put_2darray(connection_label_table,connection_node_number,3,z1);
      /*保存管端信息表*/
      get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
      connect_name = get_connection_name(pipe,2);
      put_2darray(connection_table,connection_node_number,0,node_name);
      put_2darray(connection_table,connection_node_number,1,x_ref);
      put_2darray(connection_table,connection_node_number,2,y_ref);
      put_2darray(connection_table,connection_node_number,3,z_ref);
      put_2darray(connection_table,connection_node_number,4,connect_name);

      check_node_number = check_node_number + 1;
      connection_node_number = connection_node_number + 1;

   }
   else{
      /*初始化基点坐标*/
      comp_type = get_2darray(Spool_Parts,0,4);
      nth_part = get_2darray(Spool_Parts,0,3);
      pipe = get_2darray(Spool_Parts,0,1);
      /*第一个零件为直管段*/
      if(comp_type == "TUBE"){
         if(nth_part == 1){
            x0 = get_2darray(Spool_Parts,0,6);
            y0 = get_2darray(Spool_Parts,0,7);
            z0 = get_2darray(Spool_Parts,0,8);
         }
         else{
            x0 = get_2darray(Spool_Parts,0,9);
            y0 = get_2darray(Spool_Parts,0,10);
            z0 = get_2darray(Spool_Parts,0,11);
         }
      }
      /*第一个零件为三通*/
      else if(comp_type == "TEE"){
         x0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"x"));
         y0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"y"));
         z0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"z"));
      }
      else{
         x0 = get_2darray(Spool_Parts,0,9);
         y0 = get_2darray(Spool_Parts,0,10);
         z0 = get_2darray(Spool_Parts,0,11);
      }
      /*保存校管坐标*/
      node_name = "C" + ITOASCII(connection_node_number + 1);
      put_2darray(check_table,check_node_number,0,node_name);
      put_2darray(check_table,check_node_number,1,"0");
      put_2darray(check_table,check_node_number,2,"0");
      put_2darray(check_table,check_node_number,3,"0");
      /*保存管端编号及其标注坐标*/
      put_2darray(connection_label_table,connection_node_number,0,node_name);
      put_2darray(connection_label_table,connection_node_number,1,x0);
      put_2darray(connection_label_table,connection_node_number,2,y0);
      put_2darray(connection_label_table,connection_node_number,3,z0);
      /*保存管端信息表*/
      x_ref="";y_ref="";z_ref="";
      get_connection_ref(x0, y0, z0, x_ref, y_ref, z_ref);
      if(nth_part == 1){
         connect_name = get_connection_name(pipe,1);
      }
      else{
         connect_name = get_connection_name(pipe,2);
      }
      put_2darray(connection_table,connection_node_number,0,node_name);
      put_2darray(connection_table,connection_node_number,1,x_ref);
      put_2darray(connection_table,connection_node_number,2,y_ref);
      put_2darray(connection_table,connection_node_number,3,z_ref);
      put_2darray(connection_table,connection_node_number,4,connect_name);

      check_node_number = check_node_number + 1;
      connection_node_number = connection_node_number + 1;

      /*遍历第一个零件之后的所有零件*/
      for(i=1;i<Spool_Part_Number;i=i+1;){
         branch_prev = get_2darray(Spool_Parts,i-1,0);
         branch = get_2darray(Spool_Parts,i,0);
         if(i<Spool_Part_Number-1){
            branch_next = get_2darray(Spool_Parts,i+1,0);
         }
         else{
            branch_next = 999;
         }
         comp_type = get_2darray(Spool_Parts,i,4);
         nth_part = get_2darray(Spool_Parts,i,3);
         pipe = get_2darray(Spool_Parts,i,1);
         pipe_part_number = PM_NR_PARTS_IN_PIPE(pipe);
         /*处理管段端点*/
         if(branch != branch_next){
            if(comp_type == "TUBE"){
               /*只有一个直管段的支管*/
               if( pipe_part_number == 1 ){
                  x1 = get_2darray(Spool_Parts,i,9);
                  y1 = get_2darray(Spool_Parts,i,10);
                  z1 = get_2darray(Spool_Parts,i,11);
                  x_offset = x1 - x0;
                  y_offset = y1 - y0;
                  z_offset = z1 - z0;
                  off_x = "";
                  S_PRINTF(off_x, "%d", x_offset);
                  off_y = "";
                  S_PRINTF(off_y, "%d", y_offset);
                  off_z = "";
                  S_PRINTF(off_z, "%d", z_offset);
                  node_name = "C" + ITOASCII(connection_node_number+1);
                  put_2darray(check_table,check_node_number,0,node_name);
                  put_2darray(check_table,check_node_number,1,off_x);
                  put_2darray(check_table,check_node_number,2,off_y);
                  put_2darray(check_table,check_node_number,3,off_z);
                  /*保存管端编号及其标注坐标*/
                  put_2darray(connection_label_table,connection_node_number,0,node_name);
                  put_2darray(connection_label_table,connection_node_number,1,x1);
                  put_2darray(connection_label_table,connection_node_number,2,y1);
                  put_2darray(connection_label_table,connection_node_number,3,z1);
                  /*保存管端信息表*/
                  get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
                  connect_name = get_connection_name(pipe,2);
                  put_2darray(connection_table,connection_node_number,0,node_name);
                  put_2darray(connection_table,connection_node_number,1,x_ref);
                  put_2darray(connection_table,connection_node_number,2,y_ref);
                  put_2darray(connection_table,connection_node_number,3,z_ref);
                  put_2darray(connection_table,connection_node_number,4,connect_name);

                  check_node_number = check_node_number + 1;
                  connection_node_number = connection_node_number + 1;
               }
               /*支管的最后一个直管段*/
               else{
                  /*管子零件顺序为逆序（支管末端到支管根部或者从主管末端到主管首端）*/
                  if(nth_part == 1){
                     x1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"x"));
                     y1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"y"));
                     z1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"z"));
                     x_offset = x1 - x0;
                     y_offset = y1 - y0;
                     z_offset = z1 - z0;
                     off_x = "";
                     S_PRINTF(off_x, "%d", x_offset);
                     off_y = "";
                     S_PRINTF(off_y, "%d", y_offset);
                     off_z = "";
                     S_PRINTF(off_z, "%d", z_offset);
                     node_name = "C" + ITOASCII(connection_node_number+1);
                     put_2darray(check_table,check_node_number,0,node_name);
                     put_2darray(check_table,check_node_number,1,off_x);
                     put_2darray(check_table,check_node_number,2,off_y);
                     put_2darray(check_table,check_node_number,3,off_z);
                     /*保存管端编号及其标注坐标*/
                     put_2darray(connection_label_table,connection_node_number,0,node_name);
                     put_2darray(connection_label_table,connection_node_number,1,x1);
                     put_2darray(connection_label_table,connection_node_number,2,y1);
                     put_2darray(connection_label_table,connection_node_number,3,z1);
                     /*保存管端信息表*/
                     get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
                     connect_name = get_connection_name(pipe,1);
                     put_2darray(connection_table,connection_node_number,0,node_name);
                     put_2darray(connection_table,connection_node_number,1,x_ref);
                     put_2darray(connection_table,connection_node_number,2,y_ref);
                     put_2darray(connection_table,connection_node_number,3,z_ref);
                     put_2darray(connection_table,connection_node_number,4,connect_name);

                     check_node_number = check_node_number + 1;
                     connection_node_number = connection_node_number + 1;
                  }
                  /*管子零件顺序为顺序（支管根部到支管末端或主管首端到主管末端）*/
                  else{
                     x1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"x"));
                     y1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"y"));
                     z1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"z"));
                     x_offset = x1 - x0;
                     y_offset = y1 - y0;
                     z_offset = z1 - z0;
                     off_x = "";
                     S_PRINTF(off_x, "%d", x_offset);
                     off_y = "";
                     S_PRINTF(off_y, "%d", y_offset);
                     off_z = "";
                     S_PRINTF(off_z, "%d", z_offset);
                     node_name = "C" + ITOASCII(connection_node_number+1);
                     put_2darray(check_table,check_node_number,0,node_name);
                     put_2darray(check_table,check_node_number,1,off_x);
                     put_2darray(check_table,check_node_number,2,off_y);
                     put_2darray(check_table,check_node_number,3,off_z);
                     /*保存管端编号及其标注坐标*/
                     put_2darray(connection_label_table,connection_node_number,0,node_name);
                     put_2darray(connection_label_table,connection_node_number,1,x1);
                     put_2darray(connection_label_table,connection_node_number,2,y1);
                     put_2darray(connection_label_table,connection_node_number,3,z1);
                     /*保存管端信息表*/
                     get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
                     connect_name = get_connection_name(pipe,2);
                     put_2darray(connection_table,connection_node_number,0,node_name);
                     put_2darray(connection_table,connection_node_number,1,x_ref);
                     put_2darray(connection_table,connection_node_number,2,y_ref);
                     put_2darray(connection_table,connection_node_number,3,z_ref);
                     put_2darray(connection_table,connection_node_number,4,connect_name);

                     check_node_number = check_node_number + 1;
                     connection_node_number = connection_node_number + 1;
                  }
               }
            }
            /*最后一个零件为支管根部或者套管，复板等SETON零件*/
            else if(comp_type == "ROOT" | comp_type == "PENETRATION" | comp_type == "DoublePlate" | comp_type == "HOLE"){
               tube_number = find_tube_on(i);
               pipe = get_2darray(Spool_Parts,tube_number,1);
               nth_part = get_2darray(Spool_Parts,tube_number,3);
               pipe_part_number = PM_NR_PARTS_IN_PIPE(pipe);
               if(pipe_part_number == 1){
                  x1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"x"));
                  y1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"y"));
                  z1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"z"));
                  x_offset = x1 - x0;
                  y_offset = y1 - y0;
                  z_offset = z1 - z0;
                  off_x = "";
                  S_PRINTF(off_x, "%d", x_offset);
                  off_y = "";
                  S_PRINTF(off_y, "%d", y_offset);
                  off_z = "";
                  S_PRINTF(off_z, "%d", z_offset);
                  node_name = "C" + ITOASCII(connection_node_number+1);
                  put_2darray(check_table,check_node_number,0,node_name);
                  put_2darray(check_table,check_node_number,1,off_x);
                  put_2darray(check_table,check_node_number,2,off_y);
                  put_2darray(check_table,check_node_number,3,off_z);
                  /*保存管端编号及其标注坐标*/
                  put_2darray(connection_label_table,connection_node_number,0,node_name);
                  put_2darray(connection_label_table,connection_node_number,1,x1);
                  put_2darray(connection_label_table,connection_node_number,2,y1);
                  put_2darray(connection_label_table,connection_node_number,3,z1);
                  /*保存管端信息表*/
                  get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
                  connect_name = get_connection_name(pipe,2);
                  put_2darray(connection_table,connection_node_number,0,node_name);
                  put_2darray(connection_table,connection_node_number,1,x_ref);
                  put_2darray(connection_table,connection_node_number,2,y_ref);
                  put_2darray(connection_table,connection_node_number,3,z_ref);
                  put_2darray(connection_table,connection_node_number,4,connect_name);

                  check_node_number = check_node_number + 1;
                  connection_node_number = connection_node_number + 1;
               }
               /*管子零件顺序为逆序*/
               else if(pipe_part_number > 1 & nth_part == 1){
                  x1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"x"));
                  y1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"y"));
                  z1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"z"));
                  x_offset = x1 - x0;
                  y_offset = y1 - y0;
                  z_offset = z1 - z0;
                  off_x = "";
                  S_PRINTF(off_x, "%d", x_offset);
                  off_y = "";
                  S_PRINTF(off_y, "%d", y_offset);
                  off_z = "";
                  S_PRINTF(off_z, "%d", z_offset);
                  node_name = "C" + ITOASCII(connection_node_number+1);
                  put_2darray(check_table,check_node_number,0,node_name);
                  put_2darray(check_table,check_node_number,1,off_x);
                  put_2darray(check_table,check_node_number,2,off_y);
                  put_2darray(check_table,check_node_number,3,off_z);
                  /*保存管端编号及其标注坐标*/
                  put_2darray(connection_label_table,connection_node_number,0,node_name);
                  put_2darray(connection_label_table,connection_node_number,1,x1);
                  put_2darray(connection_label_table,connection_node_number,2,y1);
                  put_2darray(connection_label_table,connection_node_number,3,z1);
                  /*保存管端信息表*/
                  get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
                  connect_name = get_connection_name(pipe,1);
                  put_2darray(connection_table,connection_node_number,0,node_name);
                  put_2darray(connection_table,connection_node_number,1,x_ref);
                  put_2darray(connection_table,connection_node_number,2,y_ref);
                  put_2darray(connection_table,connection_node_number,3,z_ref);
                  put_2darray(connection_table,connection_node_number,4,connect_name);

                  check_node_number = check_node_number + 1;
                  connection_node_number = connection_node_number + 1;
               }
               /*管子零件顺序为顺序*/
               else{
                  x1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"x"));
                  y1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"y"));
                  z1 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"z"));
                  x_offset = x1 - x0;
                  y_offset = y1 - y0;
                  z_offset = z1 - z0;
                  off_x = "";
                  S_PRINTF(off_x, "%d", x_offset);
                  off_y = "";
                  S_PRINTF(off_y, "%d", y_offset);
                  off_z = "";
                  S_PRINTF(off_z, "%d", z_offset);
                  node_name = "C" + ITOASCII(connection_node_number+1);
                  put_2darray(check_table,check_node_number,0,node_name);
                  put_2darray(check_table,check_node_number,1,off_x);
                  put_2darray(check_table,check_node_number,2,off_y);
                  put_2darray(check_table,check_node_number,3,off_z);
                  /*保存管端编号及其标注坐标*/
                  put_2darray(connection_label_table,connection_node_number,0,node_name);
                  put_2darray(connection_label_table,connection_node_number,1,x1);
                  put_2darray(connection_label_table,connection_node_number,2,y1);
                  put_2darray(connection_label_table,connection_node_number,3,z1);
                  /*保存管端信息表*/
                  get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
                  connect_name = get_connection_name(pipe,2);
                  put_2darray(connection_table,connection_node_number,0,node_name);
                  put_2darray(connection_table,connection_node_number,1,x_ref);
                  put_2darray(connection_table,connection_node_number,2,y_ref);
                  put_2darray(connection_table,connection_node_number,3,z_ref);
                  put_2darray(connection_table,connection_node_number,4,connect_name);

                  check_node_number = check_node_number + 1;
                  connection_node_number = connection_node_number + 1;
               }
            }
            /*管端套管的连接点不在端面，所以必须单独处理*/
            else if(comp_type == "SLEEVE"){
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               x_offset = x1 - x0;
               y_offset = y1 - y0;
               z_offset = z1 - z0;
               off_x = "";
               S_PRINTF(off_x, "%d", x_offset);
               off_y = "";
               S_PRINTF(off_y, "%d", y_offset);
               off_z = "";
               S_PRINTF(off_z, "%d", z_offset);
               node_name = "C" + ITOASCII(connection_node_number+1);
               put_2darray(check_table,check_node_number,0,node_name);
               put_2darray(check_table,check_node_number,1,off_x);
               put_2darray(check_table,check_node_number,2,off_y);
               put_2darray(check_table,check_node_number,3,off_z);
               /*保存管端编号及其标注坐标*/
               put_2darray(connection_label_table,connection_node_number,0,node_name);
               put_2darray(connection_label_table,connection_node_number,1,x1);
               put_2darray(connection_label_table,connection_node_number,2,y1);
               put_2darray(connection_label_table,connection_node_number,3,z1);
               /*保存管端信息表*/
               get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
               if(nth_part == 1){
                  connect_name = get_connection_name(pipe,1);
               }
               else{
                  connect_name = get_connection_name(pipe,2);
               }
               put_2darray(connection_table,connection_node_number,0,node_name);
               put_2darray(connection_table,connection_node_number,1,x_ref);
               put_2darray(connection_table,connection_node_number,2,y_ref);
               put_2darray(connection_table,connection_node_number,3,z_ref);
               put_2darray(connection_table,connection_node_number,4,connect_name);

               check_node_number = check_node_number + 1;
               connection_node_number = connection_node_number + 1;
            }
            /*管端为其它类型的零件*/
            else{
               /*所在分支只有一个零件*/
               if(pipe_part_number == 1){
                  x1 = get_2darray(Spool_Parts,i,9);
                  y1 = get_2darray(Spool_Parts,i,10);
                  z1 = get_2darray(Spool_Parts,i,11);
                  x_offset = x1 - x0;
                  y_offset = y1 - y0;
                  z_offset = z1 - z0;
                  off_x = "";
                  S_PRINTF(off_x, "%d", x_offset);
                  off_y = "";
                  S_PRINTF(off_y, "%d", y_offset);
                  off_z = "";
                  S_PRINTF(off_z, "%d", z_offset);
                  node_name = "C" + ITOASCII(connection_node_number+1);
                  put_2darray(check_table,check_node_number,0,node_name);
                  put_2darray(check_table,check_node_number,1,off_x);
                  put_2darray(check_table,check_node_number,2,off_y);
                  put_2darray(check_table,check_node_number,3,off_z);
                  /*保存管端编号及其标注坐标*/
                  put_2darray(connection_label_table,connection_node_number,0,node_name);
                  put_2darray(connection_label_table,connection_node_number,1,x1);
                  put_2darray(connection_label_table,connection_node_number,2,y1);
                  put_2darray(connection_label_table,connection_node_number,3,z1);
                  /*保存管端信息表*/
                  get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
                  connect_name = get_connection_name(pipe,2);
                  put_2darray(connection_table,connection_node_number,0,node_name);
                  put_2darray(connection_table,connection_node_number,1,x_ref);
                  put_2darray(connection_table,connection_node_number,2,y_ref);
                  put_2darray(connection_table,connection_node_number,3,z_ref);
                  put_2darray(connection_table,connection_node_number,4,connect_name);

                  check_node_number = check_node_number + 1;
                  connection_node_number = connection_node_number + 1;
               }
               else{
                  x1 = get_2darray(Spool_Parts,i,9);
                  y1 = get_2darray(Spool_Parts,i,10);
                  z1 = get_2darray(Spool_Parts,i,11);
                  x_offset = x1 - x0;
                  y_offset = y1 - y0;
                  z_offset = z1 - z0;
                  off_x = "";
                  S_PRINTF(off_x, "%d", x_offset);
                  off_y = "";
                  S_PRINTF(off_y, "%d", y_offset);
                  off_z = "";
                  S_PRINTF(off_z, "%d", z_offset);
                  node_name = "C" + ITOASCII(connection_node_number+1);
                  put_2darray(check_table,check_node_number,0,node_name);
                  put_2darray(check_table,check_node_number,1,off_x);
                  put_2darray(check_table,check_node_number,2,off_y);
                  put_2darray(check_table,check_node_number,3,off_z);
                  /*保存管端编号及其标注坐标*/
                  put_2darray(connection_label_table,connection_node_number,0,node_name);
                  put_2darray(connection_label_table,connection_node_number,1,x1);
                  put_2darray(connection_label_table,connection_node_number,2,y1);
                  put_2darray(connection_label_table,connection_node_number,3,z1);
                  /*保存管端信息表*/
                  get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
                  if(nth_part == 1){
                     connect_name = get_connection_name(pipe,1);
                  }
                  else{
                     connect_name = get_connection_name(pipe,2);
                  }
                  put_2darray(connection_table,connection_node_number,0,node_name);
                  put_2darray(connection_table,connection_node_number,1,x_ref);
                  put_2darray(connection_table,connection_node_number,2,y_ref);
                  put_2darray(connection_table,connection_node_number,3,z_ref);
                  put_2darray(connection_table,connection_node_number,4,connect_name);

                  check_node_number = check_node_number + 1;
                  connection_node_number = connection_node_number + 1;
               }
            }
         }
         /*处理支管根部*/
         else if(branch != branch_prev){
            root_number = find_root(branch);
            x1 = get_2darray(Spool_Parts,root_number,9);
            y1 = get_2darray(Spool_Parts,root_number,10);
            z1 = get_2darray(Spool_Parts,root_number,11);
            x_offset = x1 - x0;
            y_offset = y1 - y0;
            z_offset = z1 - z0;
            off_x = "";
            S_PRINTF(off_x, "%d", x_offset);
            off_y = "";
            S_PRINTF(off_y, "%d", y_offset);
            off_z = "";
            S_PRINTF(off_z, "%d", z_offset);
            put_2darray(check_table,check_node_number,0,"");
            put_2darray(check_table,check_node_number,1,off_x);
            put_2darray(check_table,check_node_number,2,off_y);
            put_2darray(check_table,check_node_number,3,off_z);

            check_node_number = check_node_number + 1;
         }
         /*处理管段中间节点*/
         else{
            if(comp_type == "BEND" | comp_type == "ELBOW"){
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               x_offset = x1 - x0;
               y_offset = y1 - y0;
               z_offset = z1 - z0;
               off_x = "";
               S_PRINTF(off_x, "%d", x_offset);
               off_y = "";
               S_PRINTF(off_y, "%d", y_offset);
               off_z = "";
               S_PRINTF(off_z, "%d", z_offset);
               put_2darray(check_table,check_node_number,0,"");
               put_2darray(check_table,check_node_number,1,off_x);
               put_2darray(check_table,check_node_number,2,off_y);
               put_2darray(check_table,check_node_number,3,off_z);

               check_node_number = check_node_number + 1;
            }
         }
      }
   }

   /*将校管表存入全局变量*/
   Check_Node_Number = check_node_number;
   free_2darray(Check_Node_Table);
   Check_Node_Table = alloc_2darray(Check_Node_Number,4);
   for(i=0;i<Check_Node_Number;i=i+1;){
      node_label = get_2darray(check_table,i,0);
      node_x = get_2darray(check_table,i,1);
      node_y = get_2darray(check_table,i,2);
      node_z = get_2darray(check_table,i,3);
      put_2darray(Check_Node_Table,i,0,node_label);
      put_2darray(Check_Node_Table,i,1,node_x);
      put_2darray(Check_Node_Table,i,2,node_y);
      put_2darray(Check_Node_Table,i,3,node_z);
   }
   free_2darray(check_table);

   if(Debug){
      U_MESSAGE("*************校管表数据*****************");
      for(i=0;i<Check_Node_Number;i=i+1){
         mess = get_2darray(Check_Node_Table,i,0) + ";" + get_2darray(Check_Node_Table,i,1) + ";" + get_2darray(Check_Node_Table,i,2)+ ";" + get_2darray(Check_Node_Table,i,3);
         U_MESSAGE(mess);
      }
   }

   /*将管端编号标注信息存入全局变量*/
   Connection_Label_Number = connection_node_number;
   free_2darray(Connection_Label_Table);
   Connection_Label_Table = alloc_2darray(Connection_Label_Number,4);
   for(i=0;i<Connection_Label_Number;i=i+1;){
      node_label = get_2darray(connection_label_table,i,0);
      node_x = get_2darray(connection_label_table,i,1);
      node_y = get_2darray(connection_label_table,i,2);
      node_z = get_2darray(connection_label_table,i,3);
      put_2darray(Connection_Label_Table,i,0,node_label);
      put_2darray(Connection_Label_Table,i,1,node_x);
      put_2darray(Connection_Label_Table,i,2,node_y);
      put_2darray(Connection_Label_Table,i,3,node_z);
   }
   free_2darray(connection_label_table);

   if(Debug){
      U_MESSAGE("******************管端编号标注信息*******************");
      for(i=0;i<Connection_Label_Number;i=i+1;){
         mess = get_2darray(Connection_Label_Table,i,0) + ";" + FTOASCII(get_2darray(Connection_Label_Table,i,1)) + ";" + FTOASCII(get_2darray(Connection_Label_Table,i,2)) + ";" + FTOASCII(get_2darray(Connection_Label_Table,i,3));
         U_MESSAGE(mess);
      }
   }

   /*将管端坐标及连接信息存入全局变量*/
   free_2darray(Connection_Table);
   Connection_Table = alloc_2darray(Connection_Label_Number,5);
   for(i=0;i<Connection_Label_Number;i=i+1;){
      node_label = get_2darray(connection_table,i,0);
      node_x = get_2darray(connection_table,i,1);
      node_y = get_2darray(connection_table,i,2);
      node_z = get_2darray(connection_table,i,3);
      conn_name = get_2darray(connection_table,i,4);
      put_2darray(Connection_Table,i,0,node_label);
      put_2darray(Connection_Table,i,1,node_x);
      put_2darray(Connection_Table,i,2,node_y);
      put_2darray(Connection_Table,i,3,node_z);
      put_2darray(Connection_Table,i,4,conn_name);
   }
   free_2darray(connection_table);

   if(Debug){
      U_MESSAGE("******************管端连接表信息*******************");
      for(i=0;i<Connection_Label_Number;i=i+1;){
         mess = get_2darray(Connection_Table,i,0) + ";" + get_2darray(Connection_Table,i,1) + ";" + get_2darray(Connection_Table,i,2) + ";" + get_2darray(Connection_Table,i,3);
         U_MESSAGE(mess);
      }
   }

   if(Debug){
      U_MESSAGE("**************管端连接表信息结束*******************");
   }

   return(0);
}


get_check_table_and_connection_table_v0()
{
   /*定义用于临时保存零件信息的数组*/
   check_table = alloc_2darray(Max_Spool_Parts_Number,4);
   connection_table = alloc_2darray(Max_Spool_Parts_Number,5);
   connection_label_table = alloc_2darray(Max_Spool_Parts_Number,4);
   check_node_number = 0;
   connection_node_number = 0;
   /*初始化相关变量*/
   int x0,y0,z0;
   x0=0;y0=0;z0=0;

   /*获取主管信息*/
   /*如果主管只有一个pipe*/
   if(Main_Branch_Pipe_Number == 1){
      main_pipe = get_2darray(Spool_Branch,0,0);
      /*获取主管首点坐标*/
      x0 = PM_GET_CONPNT_DATA(main_pipe,1,"x");
      y0 = PM_GET_CONPNT_DATA(main_pipe,1,"y");
      z0 = PM_GET_CONPNT_DATA(main_pipe,1,"z");
      /*保存校管坐标*/
      put_2darray(check_table,check_node_number,0,"C1");
      put_2darray(check_table,check_node_number,1,"0");
      put_2darray(check_table,check_node_number,2,"0");
      put_2darray(check_table,check_node_number,3,"0");
      /*保存管端编号及其标注坐标*/
      put_2darray(connection_label_table,connection_node_number,0,"C1");
      put_2darray(connection_label_table,connection_node_number,1,ITOASCII(x0));
      put_2darray(connection_label_table,connection_node_number,2,ITOASCII(y0));
      put_2darray(connection_label_table,connection_node_number,3,ITOASCII(z0));
      /*保存管端信息表*/
      x_ref="";y_ref="";z_ref="";
      get_connection_ref(x0, y0, z0, x_ref, y_ref, z_ref);
      connect_name = get_connection_name(main_pipe,1);
      put_2darray(connection_table,connection_node_number,0,"C1");
      put_2darray(connection_table,connection_node_number,1,x_ref);
      put_2darray(connection_table,connection_node_number,2,y_ref);
      put_2darray(connection_table,connection_node_number,3,z_ref);
      put_2darray(connection_table,connection_node_number,4,connect_name);
      /*如果存在拐点，将其添加到校管表*/
      add_check_corner_point(main_pipe,check_node_number,x0,y0,z0,check_table,1);

      /*获取主管末端点*/
      int x1; int y1;int z1;
      x1 = PM_GET_CONPNT_DATA(main_pipe,2,"x");
      y1 = PM_GET_CONPNT_DATA(main_pipe,2,"y");
      z1 = PM_GET_CONPNT_DATA(main_pipe,2,"z");
      x_offset = x1 - x0;
      y_offset = y1 - y0;
      z_offset = z1 - z0;
      check_node_number = check_node_number + 1;
      put_2darray(check_table,check_node_number,0,"C2");
      put_2darray(check_table,check_node_number,1,ITOASCII(x_offset));
      put_2darray(check_table,check_node_number,2,ITOASCII(y_offset));
      put_2darray(check_table,check_node_number,3,ITOASCII(z_offset));
      /*保存管端编号及其标注坐标*/
      connection_node_number = connection_node_number + 1;
      put_2darray(connection_label_table,connection_node_number,0,"C2");
      put_2darray(connection_label_table,connection_node_number,1,ITOASCII(x1));
      put_2darray(connection_label_table,connection_node_number,2,ITOASCII(y1));
      put_2darray(connection_label_table,connection_node_number,3,ITOASCII(z1));
      /*保存管端信息表*/
      get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
      connect_name = get_connection_name(main_pipe,2);
      put_2darray(connection_table,connection_node_number,0,"C2");
      put_2darray(connection_table,connection_node_number,1,x_ref);
      put_2darray(connection_table,connection_node_number,2,y_ref);
      put_2darray(connection_table,connection_node_number,3,z_ref);
      put_2darray(connection_table,connection_node_number,4,connect_name);
   }
   /*主管有多个pipe*/
   else{
      /*从第一个pipe获取首节点坐标*/
      main_pipe = get_2darray(Spool_Branch,0,0);
      /*获取主管首点坐标*/
      node_id = 0;
      connected_obj = PM_GET_CONNECTED_OBJECT(main_pipe,1,node_id);
      direction = 1;
      /*节点1有连接对象*/
      if(!ISINT(connected_obj)){
         /*如果节点1的连接对象不属于本管段，则节点1为首端点*/
         if(!belong_to_spool(connected_obj)){
            x0 = PM_GET_CONPNT_DATA(main_pipe,1,"x");
            y0 = PM_GET_CONPNT_DATA(main_pipe,1,"y");
            z0 = PM_GET_CONPNT_DATA(main_pipe,1,"z");
         }
         else{
            x0 = PM_GET_CONPNT_DATA(main_pipe,2,"x");
            y0 = PM_GET_CONPNT_DATA(main_pipe,2,"y");
            z0 = PM_GET_CONPNT_DATA(main_pipe,2,"z");
            direction = 0;
         }
      }
      /*节点1没有连接对象，则节点1为首端点*/
      else{
         x0 = PM_GET_CONPNT_DATA(main_pipe,1,"x");
         y0 = PM_GET_CONPNT_DATA(main_pipe,1,"y");
         z0 = PM_GET_CONPNT_DATA(main_pipe,1,"z");
      }
      /*保存校管坐标*/
      put_2darray(check_table,check_node_number,0,"C1");
      put_2darray(check_table,check_node_number,1,"0");
      put_2darray(check_table,check_node_number,2,"0");
      put_2darray(check_table,check_node_number,3,"0");
      /*保存管端编号及其标注坐标*/
      put_2darray(connection_label_table,connection_node_number,0,"C1");
      put_2darray(connection_label_table,connection_node_number,1,ITOASCII(x0));
      put_2darray(connection_label_table,connection_node_number,2,ITOASCII(y0));
      put_2darray(connection_label_table,connection_node_number,3,ITOASCII(z0));
      /*保存管端信息表*/
      x_ref="";y_ref="";z_ref="";
      get_connection_ref(x0, y0, z0, x_ref, y_ref, z_ref);
      if(direction == 1){
         connect_name = get_connection_name(main_pipe,1);
      }
      else{
         connect_name = get_connection_name(main_pipe,2);
      }
      put_2darray(connection_table,connection_node_number,0,"C1");
      put_2darray(connection_table,connection_node_number,1,x_ref);
      put_2darray(connection_table,connection_node_number,2,y_ref);
      put_2darray(connection_table,connection_node_number,3,z_ref);
      put_2darray(connection_table,connection_node_number,4,connect_name);
      /*查找主管第一个pipe的拐点校管坐标*/
      add_check_corner_point(main_pipe,check_node_number,x0,y0,z0,check_table,direction);

       /*主管中间pipe拐点校管坐标*/
      for(j=1;j<Main_Branch_Pipe_Number-1;j=j+1){
         main_pipe = get_2darray(Spool_Branch,0,j);
         add_check_corner_point(main_pipe,check_node_number,x0,y0,z0,check_table,1);
      }

      /*主管末端节点信息*/
      main_pipe = get_2darray(Spool_Branch,0,Main_Branch_Pipe_Number-1);
      node_id = 0;
      connected_obj = PM_GET_CONNECTED_OBJECT(main_pipe,1,node_id);
      direction = 1;
      /*节点1有连接对象*/
      if(!ISINT(connected_obj)){
         /*如果节点1的连接对象不属于本管段，则节点1为末端点*/
         if(!belong_to_spool(connected_obj)){
            x1 = PM_GET_CONPNT_DATA(main_pipe,1,"x");
            y1 = PM_GET_CONPNT_DATA(main_pipe,1,"y");
            z1 = PM_GET_CONPNT_DATA(main_pipe,1,"z");
            direction = 0;
         }
         else{
            x1 = PM_GET_CONPNT_DATA(main_pipe,2,"x");
            y1 = PM_GET_CONPNT_DATA(main_pipe,2,"y");
            z1 = PM_GET_CONPNT_DATA(main_pipe,2,"z");
         }
      }
      /*节点1没有连接对象，则节点1为末端点*/
      else{
         x1 = PM_GET_CONPNT_DATA(main_pipe,1,"x");
         y1 = PM_GET_CONPNT_DATA(main_pipe,1,"y");
         z1 = PM_GET_CONPNT_DATA(main_pipe,1,"z");
         direction = 0;
      }

      /*查找并添加主管最后一个pipe的拐点*/
      add_check_corner_point(main_pipe,check_node_number,x0,y0,z0,check_table,direction);
      /*计算并保存节点校管坐标*/
      x_offset = x1 - x0;
      y_offset = y1 - y0;
      z_offset = z1 - z0;
      check_node_number = check_node_number + 1;
      put_2darray(check_table,check_node_number,0,"C2");
      put_2darray(check_table,check_node_number,1,ITOASCII(x_offset));
      put_2darray(check_table,check_node_number,2,ITOASCII(y_offset));
      put_2darray(check_table,check_node_number,3,ITOASCII(z_offset));
      /*保存管端编号及其标注坐标*/
      connection_node_number = connection_node_number + 1;
      put_2darray(connection_label_table,connection_node_number,0,"C2");
      put_2darray(connection_label_table,connection_node_number,1,ITOASCII(x1));
      put_2darray(connection_label_table,connection_node_number,2,ITOASCII(y1));
      put_2darray(connection_label_table,connection_node_number,3,ITOASCII(z1));
      /*保存管端信息表*/
      get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
      if(direction == 1){
         connect_name = get_connection_name(main_pipe,1);
      }
      else{
         connect_name = get_connection_name(main_pipe,2);
      }
      put_2darray(connection_table,connection_node_number,0,"C2");
      put_2darray(connection_table,connection_node_number,1,x_ref);
      put_2darray(connection_table,connection_node_number,2,y_ref);
      put_2darray(connection_table,connection_node_number,3,z_ref);
      put_2darray(connection_table,connection_node_number,4,connect_name);
   }

   /*如果管段有支管,将支管信息添加到相关数组*/
   if(Spool_Branch_Number>1){
      for(k=1;k<Spool_Branch_Number;k=k+1;){
         branch_pipe = get_2darray(Spool_Branch,k,0);
         /*获取支管与主管的连接点*/
         connected_id = 1;
         node_id = 0;
         connected_obj = PM_GET_CONNECTED_OBJECT(branch_pipe, 1, node_id);
         if(ISINT(connected_obj) | !belong_to_spool(connected_obj)){
            connected_obj = PM_GET_CONNECTED_OBJECT(branch_pipe, 2, node_id);
            connected_id = 2;
         }
         x=0.0;y=0.0;z=0.0;
         get_coordinates_of_branch_start_point(connected_obj, node_id,x,y,z);
         x_offset = x - x0;
         y_offset = y - y0;
         z_offset = z - z0;

         check_node_number = check_node_number + 1;
         put_2darray(check_table,check_node_number,0,"");
         put_2darray(check_table,check_node_number,1,ITOASCII(x_offset));
         put_2darray(check_table,check_node_number,2,ITOASCII(y_offset));
         put_2darray(check_table,check_node_number,3,ITOASCII(z_offset));
         /*如果连接点1连接到主管，则按照零件顺序查找校管节点，否则反向查找*/
         if(connected_id == 1){
            add_check_corner_point(branch_pipe,check_node_number,x0,y0,z0,check_table,1);
            /*支管末端节点信息*/
            x1 = PM_GET_CONPNT_DATA(branch_pipe,2,"x");
            y1 = PM_GET_CONPNT_DATA(branch_pipe,2,"y");
            z1 = PM_GET_CONPNT_DATA(branch_pipe,2,"z");
            x_offset = x1 - x0;
            y_offset = y1 - y0;
            z_offset = z1 - z0;
            node_name = "C" + ITOASCII(k+2);
            check_node_number = check_node_number + 1;
            put_2darray(check_table,check_node_number,0,node_name);
            put_2darray(check_table,check_node_number,1,ITOASCII(x_offset));
            put_2darray(check_table,check_node_number,2,ITOASCII(y_offset));
            put_2darray(check_table,check_node_number,3,ITOASCII(z_offset));
            /*保存管端编号及其标注坐标*/
            connection_node_number = connection_node_number + 1;
            put_2darray(connection_label_table,connection_node_number,0,node_name);
            put_2darray(connection_label_table,connection_node_number,1,ITOASCII(x1));
            put_2darray(connection_label_table,connection_node_number,2,ITOASCII(y1));
            put_2darray(connection_label_table,connection_node_number,3,ITOASCII(z1));
            /*保存管端信息表*/
            x_ref="";y_ref="";z_ref="";
            get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
            connect_name = get_connection_name(branch_pipe,2);
            put_2darray(connection_table,connection_node_number,0,node_name);
            put_2darray(connection_table,connection_node_number,1,x_ref);
            put_2darray(connection_table,connection_node_number,2,y_ref);
            put_2darray(connection_table,connection_node_number,3,z_ref);
            put_2darray(connection_table,connection_node_number,4,connect_name);
         }
         else{
            add_check_corner_point(branch_pipe,check_node_number,x0,y0,z0,check_table,0);
            /*支管末端节点信息*/
            x1 = PM_GET_CONPNT_DATA(branch_pipe,1,"x");
            y1 = PM_GET_CONPNT_DATA(branch_pipe,1,"y");
            z1 = PM_GET_CONPNT_DATA(branch_pipe,1,"z");
            x_offset = x1 - x0;
            y_offset = y1 - y0;
            z_offset = z1 - z0;
            node_name = "C" + ITOASCII(k+2);
            check_node_number = check_node_number + 1;
            put_2darray(check_table,check_node_number,0,node_name);
            put_2darray(check_table,check_node_number,1,ITOASCII(x_offset));
            put_2darray(check_table,check_node_number,2,ITOASCII(y_offset));
            put_2darray(check_table,check_node_number,3,ITOASCII(z_offset));
            /*保存管端编号及其标注坐标*/
            connection_node_number = connection_node_number + 1;
            put_2darray(connection_label_table,connection_node_number,0,node_name);
            put_2darray(connection_label_table,connection_node_number,1,ITOASCII(x1));
            put_2darray(connection_label_table,connection_node_number,2,ITOASCII(y1));
            put_2darray(connection_label_table,connection_node_number,3,ITOASCII(z1));
            /*保存管端信息表*/
            x_ref="";y_ref="";z_ref="";
            get_connection_ref(x1, y1, z1, x_ref, y_ref, z_ref);
            connect_name = get_connection_name(branch_pipe,1);
            put_2darray(connection_table,connection_node_number,0,node_name);
            put_2darray(connection_table,connection_node_number,1,x_ref);
            put_2darray(connection_table,connection_node_number,2,y_ref);
            put_2darray(connection_table,connection_node_number,3,z_ref);
            put_2darray(connection_table,connection_node_number,4,connect_name);
         }
      }
   }

   /*将校管表存入全局变量*/
   Check_Node_Number = check_node_number + 1;
   free_2darray(Check_Node_Table);
   Check_Node_Table = alloc_2darray(Check_Node_Number,4);
   for(i=0;i<Check_Node_Number;i=i+1;){
      node_label = get_2darray(check_table,i,0);
      node_x = get_2darray(check_table,i,1);
      node_y = get_2darray(check_table,i,2);
      node_z = get_2darray(check_table,i,3);
      put_2darray(Check_Node_Table,i,0,node_label);
      put_2darray(Check_Node_Table,i,1,node_x);
      put_2darray(Check_Node_Table,i,2,node_y);
      put_2darray(Check_Node_Table,i,3,node_z);
   }
   free_2darray(check_table);

   /*将管端编号标注信息存入全局变量*/
   Connection_Label_Number = connection_node_number + 1;
   free_2darray(Connection_Label_Table);
   Connection_Label_Table = alloc_2darray(Connection_Label_Number,4);
   for(i=0;i<Connection_Label_Number;i=i+1;){
      node_label = get_2darray(connection_label_table,i,0);
      node_x = get_2darray(connection_label_table,i,1);
      node_y = get_2darray(connection_label_table,i,2);
      node_z = get_2darray(connection_label_table,i,3);
      put_2darray(Connection_Label_Table,i,0,node_label);
      put_2darray(Connection_Label_Table,i,1,node_x);
      put_2darray(Connection_Label_Table,i,2,node_y);
      put_2darray(Connection_Label_Table,i,3,node_z);
   }
   free_2darray(connection_label_table);

   /*将管端坐标及连接信息存入全局变量*/
   free_2darray(Connection_Table);
   Connection_Table = alloc_2darray(Connection_Label_Number,5);
   for(i=0;i<Connection_Label_Number;i=i+1;){
      node_label = get_2darray(connection_table,i,0);
      node_x = get_2darray(connection_table,i,1);
      node_y = get_2darray(connection_table,i,2);
      node_z = get_2darray(connection_table,i,3);
      conn_name = get_2darray(connection_table,i,4);
      put_2darray(Connection_Table,i,0,node_label);
      put_2darray(Connection_Table,i,1,node_x);
      put_2darray(Connection_Table,i,2,node_y);
      put_2darray(Connection_Table,i,3,node_z);
      put_2darray(Connection_Table,i,4,conn_name);
   }
   free_2darray(connection_table);

   return(0);
}

get_connection_name(obj,node_id)
{
	connected_node_id = 0;
	conn_obj = PM_GET_CONNECTED_OBJECT(obj, node_id, connected_node_id);
	if(ISINT(conn_obj))
		return("");

	type = PM_GET_OBJDATA(conn_obj, 0, MMT_TAG_OBJTYPE);

	/*连接设备*/
	if(type == 1){
	   /*获取设备的ID*/
	   nam = PM_GET_OBJDATA(conn_obj, 0, ".n5");
   	if(ISSTRING(nam)){
   		return("设备:" + nam);
   	}
   	else{
   	   /*获取设备模型的名字*/
   	   nam = PM_GET_OBJDATA(conn_obj, 0, "nam");
      	if(ISSTRING(nam)){
      		return("设备:" + nam);
      	}
      	else{
   	      return("设备:未命名");
   	   }
   	}
	}
	/*连接标准零件*/
	else if(type == 2){
		vpo = PM_GET_OBJDATA(conn_obj, 0, "vpo");
		if(ISSTRING(vpo)){
			return("阀件:" + vpo);
		}
		else {
			ipo = PM_GET_OBJDATA(conn_obj, 0, "ipo");
			if(ISSTRING(ipo)){
				return("仪表:" + ipo);
			}
			else{
			   pli = PM_GET_OBJDATA(conn_obj, 0, "pli");
			   if(ISSTRING(pli)){
			      spn = PM_GET_OBJDATA(conn_obj, 0, "spn");
			      if(ISSTRING(spn)){
			         nam = pli + "-" + spn;
			         return("管段:" + nam);
			      }
			      else{
			         return("管线:" + pli);
			      }
			   }
			   else{
			      return("");
			   }
			}
		}
	}
	/*连接pipe或者pipe part*/
	else if(type == 3 | type == 10){
   	pli = PM_GET_OBJDATA(conn_obj, 0, "pli");
   	if(ISSTRING(pli)){
   		spn = PM_GET_OBJDATA(conn_obj, 0, "spn");
   		if(ISSTRING(spn)){
			   nam = pli + "-" + spn;
			   return("管段:" + nam);
   		}
   		else {
            return("管线:" + pli);
   		}
   	}
   	else{
   	   return("");
   	}
	}
	/*连接其它对象*/
	else{
	   nam = PM_GET_OBJDATA(conn_obj, 0, "nam");
   	if(ISSTRING(nam)){
   		return(nam);
   	}
   	else{
   	   return("");
   	}
   }
   return("");
}

get_connection_ref(int x0, int y0, int z0, string x_ref, string y_ref, string z_ref)
{
   int x_off,y_off,z_off;
   x_off = 0;y_off = 0;z_off = 0;
   GetReferenceCoords(x0, y0, z0, x_ref, x_off, y_ref, y_off, z_ref, z_off);
   if(x_off > 0){
      x_ref = x_ref + "+" + ITOASCII(x_off);
   }
   else if(x_off < 0){
      x_ref = x_ref + ITOASCII(x_off);
   }
   if(y_off > 0){
      y_ref = y_ref + "+" + ITOASCII(y_off);
   }
   else if(y_off < 0){
      y_ref = y_ref + ITOASCII(y_off);
   }
   if(z_off > 0){
      z_ref = z_ref + "+" + ITOASCII(z_off);
   }
   else if(z_off < 0){
      z_ref = z_ref + ITOASCII(z_off);
   }
   return(0);
}

add_check_corner_point(pipe,check_node_number,x0,y0,z0,check_table,direction)
{
   part_number = PM_NR_PARTS_IN_PIPE(pipe);
   /*如果pipe是一个standard component或者一个直管段,则不存在任何中间节点*/
   if(part_number >0){
      if(direction){
         for(i=1;i<=part_number;i=i+1;){
            /*获取零件的id*/
            part_id = PM_GET_OBJDATA(pipe,i, "pid");
            if(ISSTRING(part_id)){
               /*获取零件的几何类型*/
               geo_type = DM_PARTID_DATA(part_id, "GT");
               if(ISSTRING(geo_type)){
                  /*如果零件几何类型为ELBOW，则将其拐点加入到校管表中*/
                  if(geo_type == "2" | geo_type == "6" | geo_type == "11"){
                     check_node_number = check_node_number + 1;
                     objgeom = PM_CREATE_PNTSET(10);
                     int x;int y;int z;
                     x = 0; y = 0; z = 0;
                     PM_GET_OBJECT_GEOM(pipe, i, objgeom);
                     PM_GET_PNT(objgeom, 1, x, y, z);
                     PM_FREE_PNTSET(objgeom);
                     x_offset = x - x0;
                     y_offset = y - y0;
                     z_offset = z - z0;
                     put_2darray(check_table,check_node_number,0,"");
                     put_2darray(check_table,check_node_number,1,ITOASCII(x_offset));
                     put_2darray(check_table,check_node_number,2,ITOASCII(y_offset));
                     put_2darray(check_table,check_node_number,3,ITOASCII(z_offset));
                  }
                  /*如果零件为BEND，则将其拐点加入到校管表中*/
                  else if(geo_type == "1"){
                     mth = PM_GET_OBJDATA(pipe, i, MMT_TAG_METHOD);
                     if(ISSTRING(mth)){
                        if(mth == "$B"){
                           check_node_number = check_node_number + 1;
      	                  objgeom = PM_CREATE_PNTSET(10);
      	                  x = 0; y = 0; z = 0;
      	                  PM_GET_OBJECT_GEOM(pipe, i, objgeom);
      	                  PM_GET_PNT(objgeom, 1, x, y, z);
      	                  PM_FREE_PNTSET(objgeom);
      	                  x_offset = x - x0;
      	                  y_offset = y - y0;
      	                  z_offset = z - z0;
                           put_2darray(check_table,check_node_number,0,"");
                           put_2darray(check_table,check_node_number,1,ITOASCII(x_offset));
                           put_2darray(check_table,check_node_number,2,ITOASCII(y_offset));
                           put_2darray(check_table,check_node_number,3,ITOASCII(z_offset));
                        }
                     }
                  }
               }
            }
         }
      }
      else{
         for(i=part_number;i>=1;i=i-1;){
            /*获取零件的id*/
            part_id = PM_GET_OBJDATA(pipe,i, "pid");
            if(ISSTRING(part_id)){
               /*获取零件的几何类型*/
               geo_type = DM_PARTID_DATA(part_id, "GT");
               if(ISSTRING(geo_type)){
                  /*如果零件几何类型为ELBOW，则将其拐点加入到校管表中*/
                  if(geo_type == "2" | geo_type == "6" | geo_type == "11"){
                     check_node_number = check_node_number + 1;
                     objgeom = PM_CREATE_PNTSET(10);
                     x = 0; y = 0; z = 0;
                     PM_GET_OBJECT_GEOM(pipe, i, objgeom);
                     PM_GET_PNT(objgeom, 1, x, y, z);
                     PM_FREE_PNTSET(objgeom);
                     x_offset = x - x0;
                     y_offset = y - y0;
                     z_offset = z - z0;
                     put_2darray(check_table,check_node_number,0,"");
                     put_2darray(check_table,check_node_number,1,ITOASCII(x_offset));
                     put_2darray(check_table,check_node_number,2,ITOASCII(y_offset));
                     put_2darray(check_table,check_node_number,3,ITOASCII(z_offset));
                  }
                  /*如果零件为BEND，则将其拐点加入到校管表中*/
                  else if(geo_type == "1"){
                     mth = PM_GET_OBJDATA(pipe, i, MMT_TAG_METHOD);
                     if(ISSTRING(mth)){
                        if (mth == "$B") {
                           check_node_number = check_node_number + 1;
      	                  objgeom = PM_CREATE_PNTSET(10);
      	                  x = 0; y = 0; z = 0;
      	                  PM_GET_OBJECT_GEOM(pipe, i, objgeom);
      	                  PM_GET_PNT(objgeom, 1, x, y, z);
      	                  PM_FREE_PNTSET(objgeom);
      	                  x_offset = x - x0;
      	                  y_offset = y - y0;
      	                  z_offset = z - z0;
                           put_2darray(check_table,check_node_number,0,"");
                           put_2darray(check_table,check_node_number,1,ITOASCII(x_offset));
                           put_2darray(check_table,check_node_number,2,ITOASCII(y_offset));
                           put_2darray(check_table,check_node_number,3,ITOASCII(z_offset));
                        }
                     }
                  }
               }
            }
         }
      }
   }
   return(0);
}


add_dim_point(pipe,dim_number,x0,y0,z0,dim_table,offset)
{
   /*获取主管首点坐标*/
   x0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"x"));
   y0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"y"));
   z0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"z"));
   /*获取标注点的偏移量*/
   part_id = PM_GET_OBJDATA(pipe,1, "pid");
   offset_str = DM_PARTID_DATA(part_id, "D21");
   if(offset_str == ""){
      offset_str = DM_PARTID_DATA(part_id, "D01");
   }
   offset0 = String_To_Float(offset_str) / 2;
   if(offset0 > offset){
      offset = offset0;
   }
   /*如果存在弯头或者异径将其添加到尺寸标注表*/
   /*遍历整个pipe的零件，根据零件的类型判断是否需要添加尺寸标注*/
   /*1.如果零件类型为ELBOW或者BEND，则将拐点添加到尺寸标注表中*/
   /*2.如果零件类型为REDUCER，则将其0点添加到尺寸标注表中。？*/
   part_number = PM_NR_PARTS_IN_PIPE(pipe);
   for(i=1;i<=part_number;i=i+1;){
      get_dimension_point(pipe,i,dim_number,x0,y0,z0,dim_table,offset);
   }
   /*获取主管末端点*/
   x = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"x"));
   y = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"y"));
   z = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"z"));
   /*将主管末端添加到标注信息中*/
   put_2darray(dim_table,dim_number,0,x0);
   put_2darray(dim_table,dim_number,1,y0);
   put_2darray(dim_table,dim_number,2,z0);
   put_2darray(dim_table,dim_number,3,x);
   put_2darray(dim_table,dim_number,4,y);
   put_2darray(dim_table,dim_number,5,z);
   /*获取标注点的偏移量*/
   part_id = PM_GET_OBJDATA(pipe,part_number-1, "pid");
   offset_str = DM_PARTID_DATA(part_id, "D21");
   if(offset_str == ""){
      offset_str = DM_PARTID_DATA(part_id, "D01");
   }
   offset0 = String_To_Float(offset_str) / 2;
   if(offset0 > offset){
      offset = offset0;
   }
   put_2darray(dim_table,dim_number,6,offset);
   /*把下一个标注的其实点设为当前点*/
   x0=x;
   y0=y;
   z0=z;
   dim_number = dim_number + 1;
   return(0);
}


add_branch_dim_point(pipe,dim_number,x0,y0,z0,dim_table,offset,direction)
{
   part_number = PM_NR_PARTS_IN_PIPE(pipe);
   /*如果存在弯头或者异径将其添加到尺寸标注表*/
   /*遍历整个pipe的零件，根据零件的类型判断是否需要添加尺寸标注*/
   /*1.如果零件类型为ELBOW或者BEND，则将拐点添加到尺寸标注表中*/
   /*2.如果零件类型为REDUCER，则将其0点添加到尺寸标注表中。？*/
   if(direction){
      for(i=1;i<=part_number;i=i+1;){
         get_dimension_point(pipe,i,dim_number,x0,y0,z0,dim_table,offset);
      }
      /*获取支管末端点*/
      x = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"x"));
      y = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"y"));
      z = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"z"));
      /*将主管末端添加到标注信息中*/
      put_2darray(dim_table,dim_number,0,x0);
      put_2darray(dim_table,dim_number,1,y0);
      put_2darray(dim_table,dim_number,2,z0);
      put_2darray(dim_table,dim_number,3,x);
      put_2darray(dim_table,dim_number,4,y);
      put_2darray(dim_table,dim_number,5,z);
      /*获取标注点的偏移量*/
      part_id = PM_GET_OBJDATA(pipe,part_number, "pid");
      offset_str = DM_PARTID_DATA(part_id, "D21");
      if(offset_str == ""){
      offset_str = DM_PARTID_DATA(part_id, "D01");
      }
      offset0 = String_To_Float(offset_str) / 2;
      if(offset0 > offset){
         offset = offset0;
      }
      put_2darray(dim_table,dim_number,6,offset);
      /*把下一个标注的其实点设为当前点*/
      x0=x;
      y0=y;
      z0=z;
      dim_number = dim_number + 1;
   }
   else{
      for(i=part_number;i>0;i=i-1;){
         get_dimension_point(pipe,i,dim_number,x0,y0,z0,dim_table,offset);
      }
      /*获取支管末端点*/
      x = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"x"));
      y = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"y"));
      z = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"z"));
      /*将支管末端添加到标注信息中*/
      put_2darray(dim_table,dim_number,0,x0);
      put_2darray(dim_table,dim_number,1,y0);
      put_2darray(dim_table,dim_number,2,z0);
      put_2darray(dim_table,dim_number,3,x);
      put_2darray(dim_table,dim_number,4,y);
      put_2darray(dim_table,dim_number,5,z);
      /*获取标注点的偏移量*/
      part_id = PM_GET_OBJDATA(pipe,1, "pid");
      offset_str = DM_PARTID_DATA(part_id, "D21");
      if(offset_str == ""){
         offset_str = DM_PARTID_DATA(part_id, "D01");
      }
      offset0 = String_To_Float(offset_str) / 2;
      if(offset0 > offset){
         offset = offset0;
      }
      put_2darray(dim_table,dim_number,6,offset);
      /*把下一个标注的其实点设为当前点*/
      x0=x;
      y0=y;
      z0=z;
      dim_number = dim_number + 1;
   }
   return(0);
}

get_dimension_point(handle pipe,int i,int dim_number,float x0,float y0,float z0,handle dim_table,float offset)
{
   part_id = PM_GET_OBJDATA(pipe,i, "pid");
   if(ISSTRING(part_id)){
      /*获取零件的几何类型*/
      geo_type = DM_PARTID_DATA(part_id, "GT");
      /*获取零件的类型关键词*/
      key_word = DM_PARTID_DATA(part_id, "KW");

      if(ISSTRING(geo_type)){
         /*如果零件几何类型为ELBOW，则将其拐点加入到标注表中*/
         if((geo_type == "2" | geo_type == "6" | geo_type == "11") & is_elbow(key_word)){
            objgeom = PM_CREATE_PNTSET(10);
            x = 0; y = 0; z = 0;
            PM_GET_OBJECT_GEOM(pipe, i, objgeom);
            PM_GET_PNT(objgeom, 1, x, y, z);
            PM_FREE_PNTSET(objgeom);
            put_2darray(dim_table,dim_number,0,x0);
            put_2darray(dim_table,dim_number,1,y0);
            put_2darray(dim_table,dim_number,2,z0);
            put_2darray(dim_table,dim_number,3,x);
            put_2darray(dim_table,dim_number,4,y);
            put_2darray(dim_table,dim_number,5,z);
            /*获取标注点的偏移量*/
            offset_str = DM_PARTID_DATA(part_id, "D21");
            if(offset_str == ""){
               offset_str = DM_PARTID_DATA(part_id, "D01");
            }
            offset0 = String_To_Float(offset_str) / 2;
            if(offset0 > offset){
               offset = offset0;
            }
            put_2darray(dim_table,dim_number,6,offset);
            /*把下一个标注的其实点设为当前点*/
            x0=x;
            y0=y;
            z0=z;
            dim_number = dim_number + 1;
         }
         /*如果零件为管材，则查找这个管材是否有弯管及开支管*/
         else if(geo_type == "1"){
            mth = PM_GET_OBJDATA(pipe, i, MMT_TAG_METHOD);
            if(ISSTRING(mth)){
               if(mth == "$B"){
                  objgeom = PM_CREATE_PNTSET(10);
                  x = 0; y = 0; z = 0;
                  PM_GET_OBJECT_GEOM(pipe, i, objgeom);
                  PM_GET_PNT(objgeom, 1, x, y, z);
                  PM_FREE_PNTSET(objgeom);
                  put_2darray(dim_table,dim_number,0,x0);
                  put_2darray(dim_table,dim_number,1,y0);
                  put_2darray(dim_table,dim_number,2,z0);
                  put_2darray(dim_table,dim_number,3,x);
                  put_2darray(dim_table,dim_number,4,y);
                  put_2darray(dim_table,dim_number,5,z);
                  /*获取标注点的偏移量*/
                  offset_str = DM_PARTID_DATA(part_id, "D21");
                  if(offset_str == ""){
                     offset_str = DM_PARTID_DATA(part_id, "D01");
                  }
                  offset0 = String_To_Float(offset_str) / 2 ;
                  if(offset0 > offset){
                     offset = offset0;
                  }
                  put_2darray(dim_table,dim_number,6,offset);
                  /*把下一个标注的其实点设为当前点*/
                  x0=x;
                  y0=y;
                  z0=z;
                  dim_number = dim_number + 1;
               }
            }
            /**/
         }
         /*如果零件为异径*/
         else if((geo_type == "4" | geo_type == "5")  & is_reducer(key_word)){
            objgeom = PM_CREATE_PNTSET(10);
            x = 0; y = 0; z = 0;
            PM_GET_OBJECT_GEOM(pipe, i, objgeom);
            PM_GET_PNT(objgeom, 0, x, y, z);
            PM_FREE_PNTSET(objgeom);
            put_2darray(dim_table,dim_number,0,x0);
            put_2darray(dim_table,dim_number,1,y0);
            put_2darray(dim_table,dim_number,2,z0);
            put_2darray(dim_table,dim_number,3,x);
            put_2darray(dim_table,dim_number,4,y);
            put_2darray(dim_table,dim_number,5,z);
            /*获取标注点的偏移量*/
            offset_str = DM_PARTID_DATA(part_id, "D21");
            if(offset_str == ""){
               offset_str = DM_PARTID_DATA(part_id, "D01");
            }
            offset0 = String_To_Float(offset_str) / 2;
            if(offset0 > offset){
               offset = offset0;
            }
            put_2darray(dim_table,dim_number,6,offset);
            /*把下一个标注的其实点设为当前点*/
            x0=x;
            y0=y;
            z0=z;
            dim_number = dim_number + 1;
         }
      }
   }
   return(0);
}

add_standard_part_dim_point(pipe,dim_number,x0,y0,z0,dim_table,offset)
{
   part_id = PM_GET_OBJDATA(pipe,0, "pid");
   if(ISSTRING(part_id)){
      /*获取零件的几何类型*/
      geo_type = DM_PARTID_DATA(part_id, "GT");

      /*如果零件几何类型为TEE，获取相关的标注尺寸*/
      if(ISSTRING(geo_type) & geo_type == "7"){
         x0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"x"));
         y0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"y"));
         z0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,1,"z"));
         x = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"x"));
         y = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"y"));
         z = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"z"));
         put_2darray(dim_table,dim_number,0,x0);
         put_2darray(dim_table,dim_number,1,y0);
         put_2darray(dim_table,dim_number,2,z0);
         put_2darray(dim_table,dim_number,3,x);
         put_2darray(dim_table,dim_number,4,y);
         put_2darray(dim_table,dim_number,5,z);
         /*获取标注点的偏移量*/
         offset_str = DM_PARTID_DATA(part_id, "D21");
         if(offset_str == ""){
            offset_str = DM_PARTID_DATA(part_id, "D01");
         }
         offset0 = String_To_Float(offset_str) / 2;
         if(offset0 > offset){
            offset = offset0;
         }
         put_2darray(dim_table,dim_number,6,offset);
         dim_number = dim_number + 1;

         /*

         x0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"x"));
         y0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"y"));
         z0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,2,"z"));
         x = String_To_Float(PM_GET_CONPNT_DATA(pipe,4,"x"));
         y = String_To_Float(PM_GET_CONPNT_DATA(pipe,4,"y"));
         z = String_To_Float(PM_GET_CONPNT_DATA(pipe,4,"z"));
         put_2darray(dim_table,dim_number,0,x0);
         put_2darray(dim_table,dim_number,1,y0);
         put_2darray(dim_table,dim_number,2,z0);
         put_2darray(dim_table,dim_number,3,x);
         put_2darray(dim_table,dim_number,4,y);
         put_2darray(dim_table,dim_number,5,z);
         */
         /*获取标注点的偏移量*/
         /*
         offset_str = DM_PARTID_DATA(part_id, "D21");
         if(offset_str == ""){
            offset_str = DM_PARTID_DATA(part_id, "D01");
         }
         offset0 = String_To_Float(offset_str) / 2;
         if(offset0 > offset){
            offset = offset0;
         }
         put_2darray(dim_table,dim_number,6,offset);
         dim_number = dim_number + 1;

         x0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,3,"x"));
         y0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,3,"y"));
         z0 = String_To_Float(PM_GET_CONPNT_DATA(pipe,3,"z"));
         x = String_To_Float(PM_GET_CONPNT_DATA(pipe,4,"x"));
         y = String_To_Float(PM_GET_CONPNT_DATA(pipe,4,"y"));
         z = String_To_Float(PM_GET_CONPNT_DATA(pipe,4,"z"));
         put_2darray(dim_table,dim_number,0,x0);
         put_2darray(dim_table,dim_number,1,y0);
         put_2darray(dim_table,dim_number,2,z0);
         put_2darray(dim_table,dim_number,3,x);
         put_2darray(dim_table,dim_number,4,y);
         put_2darray(dim_table,dim_number,5,z);
         */
         /*获取标注点的偏移量*/
         /*
         offset_str = DM_PARTID_DATA(part_id, "D21");
         if(offset_str == ""){
            offset_str = DM_PARTID_DATA(part_id, "D01");
         }
         offset0 = String_To_Float(offset_str) / 2;
         if(offset0 > offset){
            offset = offset0;
         }
         put_2darray(dim_table,dim_number,6,offset);
         dim_number = dim_number + 1;
         */

      }
   }
   return(0);
}

is_elbow(string key_word)
{
   if(key_word == "ELBOW"){
      return(1);
   }
   else if(key_word == "ELBOW BW"){
      return(1);
   }
   else if(key_word == "ELBOW SW"){
      return(1);
   }
   else if(key_word == "ELBOW FLG"){
      return(1);
   }
   else if(key_word == "ELBOW SCF"){
      return(1);
   }
   else if(key_word == "ELBOW STREET SCF/SCM"){
      return(1);
   }
   else if(key_word == "ELBOW*"){
      return(1);
   }
   return(0);
}

is_reducer(string key_word)
{
   if(key_word == "REDUCER*"){
      return(1);
   }
   else if(key_word == "REDUCER"){
      return(1);
   }
   else if(key_word == "CONC*RED*"){
      return(1);
   }
   else if(key_word == "CONC REDUCER BW"){
      return(1);
   }
   else if(key_word == "CONC REDUCER SW"){
      return(1);
   }
   else if(key_word == "CONC REDUCER SCF"){
      return(1);
   }
   else if(key_word == "CONC REDUCER FLG"){
      return(1);
   }
   else if(key_word == "ECC*RED*"){
      return(1);
   }
   else if(key_word == "ECC REDUCER BW"){
      return(1);
   }
   else if(key_word == "ECC REDUCER SW"){
      return(1);
   }
   else if(key_word == "ECC REDUCER SCF"){
      return(1);
   }
   else if(key_word == "ECC REDUCER FLG"){
      return(1);
   }
   return(0);
}

/*获取管段尺寸标注信息*/
/*管段尺寸标注表内容
1 - start_pos_x      起始标注点坐x标
2 - start_pos_y      起始标注点坐x标
3 - start_pos_z      起始标注点坐x标
4 - end_pos_x        末端标注点坐x标
5 - end_pos_y        末端标注点坐x标
6 - end_pos_z        末端标注点坐x标
7 - offset           尺寸标注的最小偏移尺寸
*/
get_dimension_table()
{
   if(Debug){
      U_MESSAGE("*************开始计算尺寸标注点*****************");
   }
   /*定义用于临时保存尺寸标注信息的数组*/
   dim_table = alloc_2darray(100,7);
   dim_number = 0;
   /*处理管段只有一个零件(直管)的情况*/
   if(Spool_Part_Number == 1){
      part_type = get_2darray(Spool_Parts,0,4);
      if(part_type == "TUBE"){
         x0 = get_2darray(Spool_Parts,0,6);
         y0 = get_2darray(Spool_Parts,0,7);
         z0 = get_2darray(Spool_Parts,0,8);
         x1 = get_2darray(Spool_Parts,0,9);
         y1 = get_2darray(Spool_Parts,0,10);
         z1 = get_2darray(Spool_Parts,0,11);
      }
      else{
         pipe = get_2darray(Spool_Parts,0,1);
         x0=0.0;y0=0.0;z0=0.0;x1=0.0;y1=0.0;z1=0.0;
         x = PM_GET_CONPNT_DATA(pipe,1,"x");
         y = PM_GET_CONPNT_DATA(pipe,1,"y");
         z = PM_GET_CONPNT_DATA(pipe,1,"z");
         x0=String_To_Float(x);
         y0=String_To_Float(y);
         z0=String_To_Float(z);
         x = PM_GET_CONPNT_DATA(pipe,2,"x");
         y = PM_GET_CONPNT_DATA(pipe,2,"y");
         z = PM_GET_CONPNT_DATA(pipe,2,"z");
         x1=String_To_Float(x);
         y1=String_To_Float(y);
         z1=String_To_Float(z);
      }
      offset0 = get_dimension_offset(0);
      put_2darray(dim_table,dim_number,0,x0);
      put_2darray(dim_table,dim_number,1,y0);
      put_2darray(dim_table,dim_number,2,z0);
      put_2darray(dim_table,dim_number,3,x1);
      put_2darray(dim_table,dim_number,4,y1);
      put_2darray(dim_table,dim_number,5,z1);
      put_2darray(dim_table,dim_number,6,offset0);
      dim_number = dim_number + 1;
   }
   /*处理其它情况*/
   else{
      /*获取第一个标注点的信息*/
      comp_type = get_2darray(Spool_Parts,0,4);
      /*获取标注点的偏移量*/
      offset = get_dimension_offset(0);
      start_number = 0;
      x0=0.0;y0=0.0;z0=0.0;
      x1=0.0;y1=0.0;z1=0.0;
      if(comp_type == "TUBE"){
         x0 = get_2darray(Spool_Parts,0,6);
         y0 = get_2darray(Spool_Parts,0,7);
         z0 = get_2darray(Spool_Parts,0,8);
      }
      else if(comp_type == "TEE"){
         x0 = get_2darray(Spool_Parts,0,9);
         y0 = get_2darray(Spool_Parts,0,10);
         z0 = get_2darray(Spool_Parts,0,11);
      }
      else if(comp_type == "ELBOW"){
         x0 = get_2darray(Spool_Parts,0,9);
         y0 = get_2darray(Spool_Parts,0,10);
         z0 = get_2darray(Spool_Parts,0,11);
      }
      else if(comp_type == "BEND"){
         x0 = get_2darray(Spool_Parts,0,9);
         y0 = get_2darray(Spool_Parts,0,10);
         z0 = get_2darray(Spool_Parts,0,11);
      }
      else{
         x0 = get_2darray(Spool_Parts,0,9);
         y0 = get_2darray(Spool_Parts,0,10);
         z0 = get_2darray(Spool_Parts,0,11);
      }
      /*遍历第一及最后一个零件之间的所有其它零件*/
      for(i=1;i<Spool_Part_Number-1;i=i+1;){
         branch_prev = get_2darray(Spool_Parts,i-1,0);
         branch = get_2darray(Spool_Parts,i,0);
         branch_next = get_2darray(Spool_Parts,i+1,0);
         comp_type = get_2darray(Spool_Parts,i,4);
         start_number = 0;
         /*前一个零件和下一个零件跟当前零件在同一个branch-也即标注点为中间点*/
         if(branch == branch_next & branch == branch_prev){
            if(comp_type == "BEND" | comp_type == "ELBOW" | comp_type == "PENETRATION" | comp_type == "ROOT" | comp_type == "DoublePlate" | comp_type == "TEE" | comp_type == "REDUCER" | comp_type == "HOLE"){
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               offset0 = get_dimension_offset(i);
               put_2darray(dim_table,dim_number,0,x0);
               put_2darray(dim_table,dim_number,1,y0);
               put_2darray(dim_table,dim_number,2,z0);
               put_2darray(dim_table,dim_number,3,x1);
               put_2darray(dim_table,dim_number,4,y1);
               put_2darray(dim_table,dim_number,5,z1);
               if(offset0 > offset){
                  offset = offset0;
               }
               dim_number = dim_number + 1;
               x0=x1;y0=y1;z0=z1;
            }
         }
         /*零件为主管或者支管的最后一个零件*/
         else if(branch == branch_prev & branch != branch_next){
            if(comp_type == "TUBE"){
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               offset0 = get_dimension_offset(i);
               put_2darray(dim_table,dim_number,0,x0);
               put_2darray(dim_table,dim_number,1,y0);
               put_2darray(dim_table,dim_number,2,z0);
               put_2darray(dim_table,dim_number,3,x1);
               put_2darray(dim_table,dim_number,4,y1);
               put_2darray(dim_table,dim_number,5,z1);
               if(offset0 > offset){
                  offset = offset0;
               }
               dim_number = dim_number + 1;
               x0=x1;y0=y1;z0=z1;
               for(k=start_number;k<dim_number;k=k+1){
                  put_2darray(dim_table,k,6,offset);
               }
            }
            else if(comp_type == "TEE"){
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               offset0 = get_dimension_offset(i);
               put_2darray(dim_table,dim_number,0,x0);
               put_2darray(dim_table,dim_number,1,y0);
               put_2darray(dim_table,dim_number,2,z0);
               put_2darray(dim_table,dim_number,3,x1);
               put_2darray(dim_table,dim_number,4,y1);
               put_2darray(dim_table,dim_number,5,z1);
               if(offset0 > offset){
                  offset = offset0;
               }
               dim_number = dim_number + 1;
               x0=x1;y0=y1;z0=z1;
               for(k=start_number;k<dim_number;k=k+1){
                  put_2darray(dim_table,k,6,offset);
               }
            }
            else if(comp_type == "ELBOW"){
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               offset0 = get_dimension_offset(i);
               put_2darray(dim_table,dim_number,0,x0);
               put_2darray(dim_table,dim_number,1,y0);
               put_2darray(dim_table,dim_number,2,z0);
               put_2darray(dim_table,dim_number,3,x1);
               put_2darray(dim_table,dim_number,4,y1);
               put_2darray(dim_table,dim_number,5,z1);
               if(offset0 > offset){
                  offset = offset0;
               }
               dim_number = dim_number + 1;
               x0=x1;y0=y1;z0=z1;
               for(k=start_number;k<dim_number;k=k+1){
                  put_2darray(dim_table,k,6,offset);
               }
            }
            else if(comp_type == "BEND"){
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               offset0 = get_dimension_offset(i);
               put_2darray(dim_table,dim_number,0,x0);
               put_2darray(dim_table,dim_number,1,y0);
               put_2darray(dim_table,dim_number,2,z0);
               put_2darray(dim_table,dim_number,3,x1);
               put_2darray(dim_table,dim_number,4,y1);
               put_2darray(dim_table,dim_number,5,z1);
               if(offset0 > offset){
                  offset = offset0;
               }
               dim_number = dim_number + 1;
               x0=x1;y0=y1;z0=z1;
               for(k=start_number;k<dim_number;k=k+1){
                  put_2darray(dim_table,k,6,offset);
               }
            }
            else if(comp_type == "ROOT" | comp_type == "DoublePlate" | comp_type == "PENETRATION" | comp_type == "FLANGE" | comp_type == "HOLE"){
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               offset0 = get_dimension_offset(i);
               put_2darray(dim_table,dim_number,0,x0);
               put_2darray(dim_table,dim_number,1,y0);
               put_2darray(dim_table,dim_number,2,z0);
               put_2darray(dim_table,dim_number,3,x1);
               put_2darray(dim_table,dim_number,4,y1);
               put_2darray(dim_table,dim_number,5,z1);
               if(offset0 > offset){
                  offset = offset0;
               }
               dim_number = dim_number + 1;
               x0=x1;y0=y1;z0=z1;
               tube_number = find_tube_on(i);
               x1 = get_2darray(Spool_Parts,tube_number,9);
               y1 = get_2darray(Spool_Parts,tube_number,10);
               z1 = get_2darray(Spool_Parts,tube_number,11);
               put_2darray(dim_table,dim_number,0,x0);
               put_2darray(dim_table,dim_number,1,y0);
               put_2darray(dim_table,dim_number,2,z0);
               put_2darray(dim_table,dim_number,3,x1);
               put_2darray(dim_table,dim_number,4,y1);
               put_2darray(dim_table,dim_number,5,z1);
               offset0 = get_dimension_offset(tube_number);
               dim_number = dim_number + 1;
               for(k=start_number;k<dim_number;k=k+1){
                  put_2darray(dim_table,k,6,offset);
               }
            }
            else{
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               offset0 = get_dimension_offset(i);
               put_2darray(dim_table,dim_number,0,x0);
               put_2darray(dim_table,dim_number,1,y0);
               put_2darray(dim_table,dim_number,2,z0);
               put_2darray(dim_table,dim_number,3,x1);
               put_2darray(dim_table,dim_number,4,y1);
               put_2darray(dim_table,dim_number,5,z1);
               if(offset0 > offset){
                  offset = offset0;
               }
               dim_number = dim_number + 1;
               for(k=start_number;k<dim_number;k=k+1){
                  put_2darray(dim_table,k,6,offset);
               }
            }
         }
         /*支管只有一个零件的情况*/
         else if(branch != branch_prev & branch != branch_next){
            root_number = find_root(branch);
            /*如果支管零件为直管段，则添加标注*/
            if(comp_type == "TUBE"){
               start_number = dim_number;
               x0 = get_2darray(Spool_Parts,root_number,9);
               y0 = get_2darray(Spool_Parts,root_number,10);
               z0 = get_2darray(Spool_Parts,root_number,11);
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               offset = get_dimension_offset(i);
               put_2darray(dim_table,dim_number,0,x0);
               put_2darray(dim_table,dim_number,1,y0);
               put_2darray(dim_table,dim_number,2,z0);
               put_2darray(dim_table,dim_number,3,x1);
               put_2darray(dim_table,dim_number,4,y1);
               put_2darray(dim_table,dim_number,5,z1);
               put_2darray(dim_table,dim_number,6,offset);
               dim_number = dim_number + 1;
            }
            else{
               root_type = get_2darray(Spool_Parts,root_number,4);
               if(root_type == "TEE"){
                  start_number = dim_number;
                  x0 = get_2darray(Spool_Parts,root_number,9);
                  y0 = get_2darray(Spool_Parts,root_number,10);
                  z0 = get_2darray(Spool_Parts,root_number,11);
                  x1 = get_2darray(Spool_Parts,i,9);
                  y1 = get_2darray(Spool_Parts,i,10);
                  z1 = get_2darray(Spool_Parts,i,11);
                  offset = get_dimension_offset(i);
                  put_2darray(dim_table,dim_number,0,x0);
                  put_2darray(dim_table,dim_number,1,y0);
                  put_2darray(dim_table,dim_number,2,z0);
                  put_2darray(dim_table,dim_number,3,x1);
                  put_2darray(dim_table,dim_number,4,y1);
                  put_2darray(dim_table,dim_number,5,z1);
                  put_2darray(dim_table,dim_number,6,offset);
                  dim_number = dim_number + 1;
               }
            }
         }
         /*支管的第一个零件*/
         else if(branch != branch_prev & branch == branch_next){
            start_number = dim_number;
            root_number = find_root(branch);
            x0 = get_2darray(Spool_Parts,root_number,9);
            y0 = get_2darray(Spool_Parts,root_number,10);
            z0 = get_2darray(Spool_Parts,root_number,11);
         }
      }
      /*处理最后一个零件*/
      comp_type = get_2darray(Spool_Parts,Spool_Part_Number-1,4);
      branch = get_2darray(Spool_Parts,Spool_Part_Number-1,0);
      branch_prev = get_2darray(Spool_Parts,Spool_Part_Number-2,0);
      /*获取标注点的偏移量*/
      offset = get_dimension_offset(0);
      if(branch_prev == branch){
         if(comp_type == "TUBE"){
            x1 = get_2darray(Spool_Parts,Spool_Part_Number-1,9);
            y1 = get_2darray(Spool_Parts,Spool_Part_Number-1,10);
            z1 = get_2darray(Spool_Parts,Spool_Part_Number-1,11);
            offset0 = get_dimension_offset(i);
            put_2darray(dim_table,dim_number,0,x0);
            put_2darray(dim_table,dim_number,1,y0);
            put_2darray(dim_table,dim_number,2,z0);
            put_2darray(dim_table,dim_number,3,x1);
            put_2darray(dim_table,dim_number,4,y1);
            put_2darray(dim_table,dim_number,5,z1);
            if(offset0 > offset){
               offset = offset0;
            }
            dim_number = dim_number + 1;
            x0=x1;y0=y1;z0=z1;
            for(k=start_number;k<dim_number;k=k+1){
               put_2darray(dim_table,k,6,offset);
            }
         }
         else if(comp_type == "TEE"){
            x1 = get_2darray(Spool_Parts,Spool_Part_Number-1,9);
            y1 = get_2darray(Spool_Parts,Spool_Part_Number-1,10);
            z1 = get_2darray(Spool_Parts,Spool_Part_Number-1,11);
            offset0 = get_dimension_offset(Spool_Part_Number-1);
            put_2darray(dim_table,dim_number,0,x0);
            put_2darray(dim_table,dim_number,1,y0);
            put_2darray(dim_table,dim_number,2,z0);
            put_2darray(dim_table,dim_number,3,x1);
            put_2darray(dim_table,dim_number,4,y1);
            put_2darray(dim_table,dim_number,5,z1);
            if(offset0 > offset){
               offset = offset0;
            }
            dim_number = dim_number + 1;
            x0=x1;y0=y1;z0=z1;
            for(k=start_number;k<dim_number;k=k+1){
               put_2darray(dim_table,k,6,offset);
            }
         }
         else if(comp_type == "ELBOW"){
            x1 = get_2darray(Spool_Parts,Spool_Part_Number-1,9);
            y1 = get_2darray(Spool_Parts,Spool_Part_Number-1,10);
            z1 = get_2darray(Spool_Parts,Spool_Part_Number-1,11);
            offset0 = get_dimension_offset(Spool_Part_Number-1);
            put_2darray(dim_table,dim_number,0,x0);
            put_2darray(dim_table,dim_number,1,y0);
            put_2darray(dim_table,dim_number,2,z0);
            put_2darray(dim_table,dim_number,3,x1);
            put_2darray(dim_table,dim_number,4,y1);
            put_2darray(dim_table,dim_number,5,z1);
            if(offset0 > offset){
               offset = offset0;
            }
            dim_number = dim_number + 1;
            x0=x1;y0=y1;z0=z1;
            for(k=start_number;k<dim_number;k=k+1){
               put_2darray(dim_table,k,6,offset);
            }
         }
         else if(comp_type == "BEND"){
            x1 = get_2darray(Spool_Parts,Spool_Part_Number-1,9);
            y1 = get_2darray(Spool_Parts,Spool_Part_Number-1,10);
            z1 = get_2darray(Spool_Parts,Spool_Part_Number-1,11);
            offset0 = get_dimension_offset(Spool_Part_Number-1);
            put_2darray(dim_table,dim_number,0,x0);
            put_2darray(dim_table,dim_number,1,y0);
            put_2darray(dim_table,dim_number,2,z0);
            put_2darray(dim_table,dim_number,3,x1);
            put_2darray(dim_table,dim_number,4,y1);
            put_2darray(dim_table,dim_number,5,z1);
            if(offset0 > offset){
               offset = offset0;
            }
            dim_number = dim_number + 1;
            x0=x1;y0=y1;z0=z1;
            for(k=start_number;k<dim_number;k=k+1){
               put_2darray(dim_table,k,6,offset);
            }
         }
         else if(comp_type == "ROOT" | comp_type == "DoublePlate" | comp_type == "PENETRATION"  | comp_type == "HOLE"){
            x1 = get_2darray(Spool_Parts,Spool_Part_Number-1,9);
            y1 = get_2darray(Spool_Parts,Spool_Part_Number-1,10);
            z1 = get_2darray(Spool_Parts,Spool_Part_Number-1,11);
            offset0 = get_dimension_offset(Spool_Part_Number-1);
            put_2darray(dim_table,dim_number,0,x0);
            put_2darray(dim_table,dim_number,1,y0);
            put_2darray(dim_table,dim_number,2,z0);
            put_2darray(dim_table,dim_number,3,x1);
            put_2darray(dim_table,dim_number,4,y1);
            put_2darray(dim_table,dim_number,5,z1);
            if(offset0 > offset){
               offset = offset0;
            }
            dim_number = dim_number + 1;
            x0=x1;y0=y1;z0=z1;
            tube_number = find_tube_on(Spool_Part_Number-1);
            x1 = get_2darray(Spool_Parts,tube_number,9);
            y1 = get_2darray(Spool_Parts,tube_number,10);
            z1 = get_2darray(Spool_Parts,tube_number,11);
            put_2darray(dim_table,dim_number,0,x0);
            put_2darray(dim_table,dim_number,1,y0);
            put_2darray(dim_table,dim_number,2,z0);
            put_2darray(dim_table,dim_number,3,x1);
            put_2darray(dim_table,dim_number,4,y1);
            put_2darray(dim_table,dim_number,5,z1);
            offset0 = get_dimension_offset(tube_number);
            dim_number = dim_number + 1;
            for(k=start_number;k<dim_number;k=k+1){
               put_2darray(dim_table,k,6,offset);
            }
         }
         else{
            x1 = get_2darray(Spool_Parts,Spool_Part_Number-1,9);
            y1 = get_2darray(Spool_Parts,Spool_Part_Number-1,10);
            z1 = get_2darray(Spool_Parts,Spool_Part_Number-1,11);
            offset0 = get_dimension_offset(Spool_Part_Number-1);
            put_2darray(dim_table,dim_number,0,x0);
            put_2darray(dim_table,dim_number,1,y0);
            put_2darray(dim_table,dim_number,2,z0);
            put_2darray(dim_table,dim_number,3,x1);
            put_2darray(dim_table,dim_number,4,y1);
            put_2darray(dim_table,dim_number,5,z1);
            if(offset0 > offset){
               offset = offset0;
            }
            dim_number = dim_number + 1;
            for(k=start_number;k<dim_number;k=k+1){
               put_2darray(dim_table,k,6,offset);
            }
         }
      }
      else{
         root_number = find_root(branch);
         /*如果支管零件为直管段，则添加标注*/
         if(comp_type == "TUBE"){
            start_number = dim_number;
            x0 = get_2darray(Spool_Parts,root_number,9);
            y0 = get_2darray(Spool_Parts,root_number,10);
            z0 = get_2darray(Spool_Parts,root_number,11);
            x1 = get_2darray(Spool_Parts,i,9);
            y1 = get_2darray(Spool_Parts,i,10);
            z1 = get_2darray(Spool_Parts,i,11);
            offset = get_dimension_offset(i);
            put_2darray(dim_table,dim_number,0,x0);
            put_2darray(dim_table,dim_number,1,y0);
            put_2darray(dim_table,dim_number,2,z0);
            put_2darray(dim_table,dim_number,3,x1);
            put_2darray(dim_table,dim_number,4,y1);
            put_2darray(dim_table,dim_number,5,z1);
            put_2darray(dim_table,dim_number,6,offset);
            dim_number = dim_number + 1;
         }
         else{
            root_type = get_2darray(Spool_Parts,root_number,4);
            if(root_type == "TEE"){
               start_number = dim_number;
               x0 = get_2darray(Spool_Parts,root_number,9);
               y0 = get_2darray(Spool_Parts,root_number,10);
               z0 = get_2darray(Spool_Parts,root_number,11);
               x1 = get_2darray(Spool_Parts,i,9);
               y1 = get_2darray(Spool_Parts,i,10);
               z1 = get_2darray(Spool_Parts,i,11);
               offset = get_dimension_offset(i);
               put_2darray(dim_table,dim_number,0,x0);
               put_2darray(dim_table,dim_number,1,y0);
               put_2darray(dim_table,dim_number,2,z0);
               put_2darray(dim_table,dim_number,3,x1);
               put_2darray(dim_table,dim_number,4,y1);
               put_2darray(dim_table,dim_number,5,z1);
               put_2darray(dim_table,dim_number,6,offset);
               dim_number = dim_number + 1;
            }
         }
      }
   }
   /*在命令行显示尺寸标注信息*/
   if(Debug){
      for(i=0;i<dim_number;i=i+1;){
         node0_x = STRINGTERM(FTOASCII(get_2darray(dim_table,i,0)),".");
         node0_y = STRINGTERM(FTOASCII(get_2darray(dim_table,i,1)),".");
         node0_z = STRINGTERM(FTOASCII(get_2darray(dim_table,i,2)),".");
         node1_x = STRINGTERM(FTOASCII(get_2darray(dim_table,i,3)),".");
         node1_y = STRINGTERM(FTOASCII(get_2darray(dim_table,i,4)),".");
         node1_z = STRINGTERM(FTOASCII(get_2darray(dim_table,i,5)),".");
         offset =  STRINGTERM(FTOASCII(get_2darray(dim_table,i,6)),".");
         mess = ITOASCII(i) + ":  x1=" + node0_x + ",y1=" + node0_y + ",z1=" + node0_z + ";x2=" + node1_x + ",y2=" + node1_y + ",z2=" + node1_z;
         U_MESSAGE(mess);
      }
   }
   /*将尺寸标注信息存入全局变量*/
   Dim_Number = dim_number;
   free_2darray(Dim_Table);
   Dim_Table = alloc_2darray(Dim_Number,7);
   for(i=0;i<Dim_Number;i=i+1;){
      node0_x = get_2darray(dim_table,i,0);
      node0_y = get_2darray(dim_table,i,1);
      node0_z = get_2darray(dim_table,i,2);
      node1_x = get_2darray(dim_table,i,3);
      node1_y = get_2darray(dim_table,i,4);
      node1_z = get_2darray(dim_table,i,5);
      offset =  get_2darray(dim_table,i,6);

      put_2darray(Dim_Table,i,0,node0_x);
      put_2darray(Dim_Table,i,1,node0_y);
      put_2darray(Dim_Table,i,2,node0_z);
      put_2darray(Dim_Table,i,3,node1_x);
      put_2darray(Dim_Table,i,4,node1_y);
      put_2darray(Dim_Table,i,5,node1_z);
      put_2darray(Dim_Table,i,6,offset);
   }
   free_2darray(dim_table);
   if(Debug){
      U_MESSAGE("****************尺寸标注点计算结束**********************");
   }
   return(0);
}

/*查找复板或者中间套管所在的直管零件编号*/
find_tube_on(part_number)
{
   for(i=part_number-1;i>=0;i=i-1;){
      comp_type = get_2darray(Spool_Parts,i,4);
      if(comp_type == "TUBE"){
         return(i);
      }
   }
   return(0);
}

/*查找支管在主管上的根部零件*/
find_root(branch)
{
   find = 0;
   for(i=1;i<Spool_Part_Number;i=i+1;){
      comp_type = get_2darray(Spool_Parts,i,4);
      if(comp_type == "TEE" | comp_type == "ROOT"){
         find = find + 1;
         if(find == branch){
            return(i);
         }
      }
   }
}

/*获取零件的标注偏移量
--首先查找零件尺寸表中的第一个Dia类型的值
--如果找不到Dia类型的值，则找第一个NS类型的值
--可以进一步优化吗？？？
*/
get_dimension_offset(part_number)
{
   pipe = get_2darray(Spool_Parts,part_number,1);
   /*零件为一般的管子零件*/
   if(!ISINT(pipe)){
      nth_part = get_2darray(Spool_Parts,part_number,3);
      part_id = PM_GET_OBJDATA(pipe,1, "pid");
      offset_str = DM_PARTID_DATA(part_id, "D21");
      if(offset_str == ""){
         offset_str = DM_PARTID_DATA(part_id, "D01");
      }
      offset = String_To_Float(offset_str) / 2;
      return(offset);
   }
   /*零件为复板之类的零件*/
   else{
      type = get_2darray(Spool_Parts,part_number,4);
      if(type == "DoublePlate"){
         part_handle = get_2darray(Spool_Parts,part_number,2);
         width_s = PM_GET_OBJDATA(part_handle,0,MMT_TAG_PLATE_MINWIDTH);
         height_s = PM_GET_OBJDATA(part_handle,0,MMT_TAG_PLATE_MINHEIGHT);
         width = String_To_Float(width_s);
         height = String_To_Float(height_s);
         S_PRINTF(width_s, "%d", width);
         S_PRINTF(height_s, "%d", height);
         width = String_To_Int(width_s);
         height = String_To_Int(height_s);
         /*当个的复板*/
         if(width == height){
            return(height/2);
         }
         /*多联复板*/
         else{
            return(height/2);
         }
      }
   }
   return(0);
}

/*获取支管的根部坐标
--part_number     int      支管中连接到支管根部或者三通的第一个零件的序号
--x0,y0,z0        float    用于返回支管根部的坐标（如果是TEE，则获取TEE的中心点坐标）
*/
get_root_position(part_number,x0,y0,z0)
{
   pipe = get_2darray(Spool_Parts,part_number,1);
   nth_part0 = get_2darray(Spool_Parts,part_number,3);
   nth_part1 = get_2darray(Spool_Parts,part_number+1,3);
   /*对于牙座一类的零件，支管中只有一个零件*/
   branch0 = get_2darray(Spool_Parts,part_number,0);
   branch1 = get_2darray(Spool_Parts,part_number+1,0);
   node_id = 0;
   if(branch1 == branch0){
      if(nth_part1 > nth_part0){
         main_pipe = PM_GET_CONNECTED_OBJECT(pipe, 1, node_id);
      }
      else{
         main_pipe = PM_GET_CONNECTED_OBJECT(pipe, 2, node_id);
      }
   }
   else{
      main_pipe = PM_GET_CONNECTED_OBJECT(pipe, 1, node_id);
   }
   type = PM_GET_OBJDATA(main_pipe,0,MMT_TAG_OBJTYPE);
   /*如果支管连接到TEE上*/
   if(type == "2"){
      for(i=0;i<Spool_Part_Number;i=i+1;){
         part_handle = get_2darray(Spool_Parts,i,1);
         if(main_pipe == part_handle){
            root_part_number = i;
         }
      }
   }
   else if(type == "3"){
      for(i=0;i<Spool_Part_Number;i=i+1;){
         pipe_handle = get_2darray(Spool_Parts,i,1);
         type = get_2darray(Spool_Parts,i,4);
         id = get_2darray(Spool_Parts,i,3);
         if(main_pipe == pipe_handle & type == "ROOT" & id == node_id){
            root_part_number = i;
         }
      }
   }
   x0 = get_2darray(Spool_Parts,root_part_number,9);
   y0 = get_2darray(Spool_Parts,root_part_number,10);
   z0 = get_2darray(Spool_Parts,root_part_number,11);
   return(0);
}

/*获取零件的描述信息*/
/*type参数暂时不用，将来可能用于区分不同类型的零件需要不同的描述信息*/
get_part_description(pipe,nth_part,type)
{
	part_id = PM_GET_OBJDATA(pipe,nth_part,MMT_TAG_PARTID);
	chinese_description = DM_PARTID_DATA(part_id,"CHN");
	default_description = DM_PARTID_DATA(part_id,"DE");
	size_description = DM_PARTID_DATA(part_id,"DD");
	description = "";
	if(chinese_description != ""){
		description = chinese_description + " " + size_description;
	}
	else{
		description = default_description + " " + size_description;
	}
	/*description = TRANS(description,"\u00F8","D");*/

	/*添加预制弯头的角度*/
	if(type == "ELBOW"){
		degree = String_To_Float(PM_GET_OBJDATA(pipe,nth_part,MMT_TAG_CRVANGLE));
		degree_s = "";
		S_PRINTF(degree_s, "%.0f", degree);
		description = description + " " + degree_s + "度";
	}
   
	/*党章辉要求添加标准号及材料 - 20191115*/
	std = DM_PARTID_DATA(part_id,"ST");
	if(ISSTRING(std)){
		description = description + " " + std;
	}
	material = DM_PARTID_DATA(part_id,"MC");
	if(ISSTRING(material)){
		description = description + " " + material;
	}
	return(description);
}

draw_mto_table()
{
   if(Mto_Number == 0){
      return(0);
   }
	style_name = "";
	drafting_style = GetFirstDraftingStyle(style_name);
   dw = PM_START_PAGE_ANNOTATION(style_name);
   DW_ACTIVATEVIEW(dw);

   InitDrawingSettings();

	DW_COLOR(Mto_Table_Line_Colour);
	DW_LTYPE(Mto_Table_Line_Type,Mto_Table_Pattern_Length);

	/*绘制横线*/
	line_number = Mto_Number + 3;
	if(Mto_Table_Direction == "Down" ){
	   for(i=0;i<line_number;i=i+1;){
	      x1 = Mto_Table_Orign_X;
	      x2 = Mto_Table_Orign_X + Mto_Table_W;
	      y1 = Mto_Table_Orign_Y - i * Mto_Table_H;
	      y2 = y1;
	      DW_POLY(x1,y1,x2,y2);
	   }
   }
   else{
	   for(i=0;i<line_number;i=i+1;){
	      x1 = Mto_Table_Orign_X;
	      x2 = Mto_Table_Orign_X + Mto_Table_W;
	      y1 = Mto_Table_Orign_Y + i * Mto_Table_H;
	      y2 = y1;
	      DW_POLY(x1,y1,x2,y2);
	   }
   }
	/*绘制竖线*/
	line_number = Mto_Number + 2;
	h1 = line_number * Mto_Table_H;
	h2 = (line_number - 1)* Mto_Table_H;
	if(Mto_Table_Direction == "Down" ){
	   x1 = Mto_Table_Orign_X;
	   y1 = Mto_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 - h1;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Mto_Table_Column1_W;
	   y1 = Mto_Table_Orign_Y - Mto_Table_H;
	   x2 = x1;
	   y2 = y1 - h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Mto_Table_Column2_W;
	   y1 = Mto_Table_Orign_Y - Mto_Table_H;
	   x2 = x1;
	   y2 = y1 - h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Mto_Table_Column3_W;
	   y1 = Mto_Table_Orign_Y - Mto_Table_H;
	   x2 = x1;
	   y2 = y1 - h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Mto_Table_Column4_W;
	   y1 = Mto_Table_Orign_Y - Mto_Table_H;
	   x2 = x1;
	   y2 = y1 - h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Mto_Table_Column5_W;
	   y1 = Mto_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 - h1;
	   DW_POLY(x1,y1,x2,y2);
   }
   else{
	   x1 = Mto_Table_Orign_X;
	   y1 = Mto_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 + h1;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Mto_Table_Column1_W;
	   y1 = Mto_Table_Orign_Y + Mto_Table_H;
	   x2 = x1;
	   y2 = y1 + h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Mto_Table_Column2_W;
	   y1 = Mto_Table_Orign_Y + Mto_Table_H;
	   x2 = x1;
	   y2 = y1 + h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Mto_Table_Column3_W;
	   y1 = Mto_Table_Orign_Y + Mto_Table_H;
	   x2 = x1;
	   y2 = y1 + h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Mto_Table_Column4_W;
	   y1 = Mto_Table_Orign_Y + Mto_Table_H;
	   x2 = x1;
	   y2 = y1 + h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Mto_Table_Column5_W;
	   y1 = Mto_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 + h1;
	   DW_POLY(x1,y1,x2,y2);
   }
   /*写标题*/
   DW_COLOR(Mto_Table_Text_Colour);
	DW_TSIZE(Mto_Table_Text_Height);
	DW_TATTR(0.0,0.0,5);
	if(Mto_Table_Direction == "Down" ){
      x = Mto_Table_Orign_X + Mto_Table_W / 2;
      y = Mto_Table_Orign_Y - Mto_Table_H / 2;
      text = "材料表";
      DW_TEXT(x, y, text);

      x = Mto_Table_Orign_X + Mto_Table_Column1_W / 2;
      y = Mto_Table_Orign_Y - Mto_Table_H * 1.5;
      text = "序号";
      DW_TEXT(x, y, text);

      x = x + Mto_Table_Column1_W / 2 + Mto_Table_Column2_W / 2;
      y = Mto_Table_Orign_Y - Mto_Table_H * 1.5;
      text = "长度/数量";
      DW_TEXT(x, y, text);

      x = x + Mto_Table_Column2_W / 2 + Mto_Table_Column3_W / 2;
      y = Mto_Table_Orign_Y - Mto_Table_H * 1.5;
      text = "单位";
      DW_TEXT(x, y, text);

      x = x + Mto_Table_Column3_W / 2 + Mto_Table_Column4_W / 2;
      y = Mto_Table_Orign_Y - Mto_Table_H * 1.5;
      text = "材料描述";
      DW_TEXT(x, y, text);

      x = x + Mto_Table_Column4_W / 2 + Mto_Table_Column5_W / 2;
      y = Mto_Table_Orign_Y - Mto_Table_H * 1.5;
      text = "下料长度";
      DW_TEXT(x, y, text);
   }
   else{
      x = Mto_Table_Orign_X + Mto_Table_W / 2;
      y = Mto_Table_Orign_Y + Mto_Table_H / 2;
      text = "材料表";
      DW_TEXT(x, y, text);

      x = Mto_Table_Orign_X + Mto_Table_Column1_W / 2;
      y = Mto_Table_Orign_Y + Mto_Table_H * 1.5;
      text = "序号";
      DW_TEXT(x, y, text);

      x = x + Mto_Table_Column1_W / 2 + Mto_Table_Column2_W / 2;
      y = Mto_Table_Orign_Y + Mto_Table_H * 1.5;
      text = "长度/数量";
      DW_TEXT(x, y, text);

      x = x + Mto_Table_Column2_W / 2 + Mto_Table_Column3_W / 2;
      y = Mto_Table_Orign_Y + Mto_Table_H * 1.5;
      text = "单位";
      DW_TEXT(x, y, text);

      x = x + Mto_Table_Column3_W / 2 + Mto_Table_Column4_W / 2;
      y = Mto_Table_Orign_Y + Mto_Table_H * 1.5;
      text = "材料描述";
      DW_TEXT(x, y, text);

      x = x + Mto_Table_Column4_W / 2 + Mto_Table_Column5_W / 2;
      y = Mto_Table_Orign_Y + Mto_Table_H * 1.5;
      text = "下料长度";
      DW_TEXT(x, y, text);
   }
   /*写材料表内容*/
	DW_TATTR(0.0,0.0,4);
   for(i=0;i<Mto_Number;i=i+1;){
	   if(Mto_Table_Direction == "Down" ){
         x = Mto_Table_Orign_X + 1;
         y = Mto_Table_Orign_Y - Mto_Table_H * (i + 2.5);
         text = get_2darray(Mto_Table,i,0);
         DW_TEXT(x, y, text);

         x = x + Mto_Table_Column1_W;
         y = Mto_Table_Orign_Y - Mto_Table_H * (i + 2.5);
         text = get_2darray(Mto_Table,i,1);
         DW_TEXT(x, y, text);

         x = x + Mto_Table_Column2_W;
         y = Mto_Table_Orign_Y - Mto_Table_H * (i + 2.5);
         text = get_2darray(Mto_Table,i,2);
         DW_TEXT(x, y, text);

         x = x + Mto_Table_Column3_W;
         y = Mto_Table_Orign_Y - Mto_Table_H * (i + 2.5);
         text = get_2darray(Mto_Table,i,3);
         DW_TEXT(x, y, text);

         x = x + Mto_Table_Column4_W;
         y = Mto_Table_Orign_Y - Mto_Table_H * (i + 2.5);
         text = get_2darray(Mto_Table,i,4);
         DW_TEXT(x, y, text);
	   }
	   else{
         x = Mto_Table_Orign_X + 1;
         y = Mto_Table_Orign_Y - Mto_Table_H * (i + 2.5);
         text = get_2darray(Mto_Table,i,0);
         DW_TEXT(x, y, text);

         x = x + Mto_Table_Column1_W;
         y = Mto_Table_Orign_Y - Mto_Table_H * (i + 2.5);
         text = get_2darray(Mto_Table,i,1);
         DW_TEXT(x, y, text);

         x = x + Mto_Table_Column2_W;
         y = Mto_Table_Orign_Y - Mto_Table_H * (i + 2.5);
         text = get_2darray(Mto_Table,i,2);
         DW_TEXT(x, y, text);

         x = x + Mto_Table_Column3_W;
         y = Mto_Table_Orign_Y - Mto_Table_H * (i + 2.5);
         text = get_2darray(Mto_Table,i,3);
         DW_TEXT(x, y, text);

         x = x + Mto_Table_Column4_W;
         y = Mto_Table_Orign_Y - Mto_Table_H * (i + 2.5);
         text = get_2darray(Mto_Table,i,4);
         DW_TEXT(x, y, text);
	   }
   }

   PM_TERMINATE_PAGE_ANNOTATION(1);
}

draw_dimension()
{
    if(Debug){
        U_MESSAGE("**************开始标注尺寸***************");
    }
    /*开始标注*/
    style_name = "";
    drafting_style = GetFirstDraftingStyle(style_name);
    dw = PM_START_PAGE_ANNOTATION(style_name);
    DW_ACTIVATEVIEW(dw);
    InitDrawingSettings();

    for(i=0;i<Dim_Number;i=i+1;){
        /*计算标注尺寸值*/
        x0 = get_2darray(Dim_Table,i,0);
        y0 = get_2darray(Dim_Table,i,1);
        z0 = get_2darray(Dim_Table,i,2);
        x1 = get_2darray(Dim_Table,i,3);
        y1 = get_2darray(Dim_Table,i,4);
        z1 = get_2darray(Dim_Table,i,5);
        offset = get_2darray(Dim_Table,i,6);
        x=x1-x0;y=y1-y0;z=z1-z0;
        dim_value = SQRT(x*x+y*y+z*z);
        for(j=0;j<3;j=j+1;){
            view = A_GET(View_Handles,j);
            draw_view_dim(j,view,x0,y0,z0,x1,y1,z1,dim_value,offset);
        }
    }

   /*结束标注*/
   PM_TERMINATE_PAGE_ANNOTATION(1);
   return(0);

}

/*Add dimension to VIEW*/
draw_view_dim(int i,handle view_h,float x0,float y0,float z0,float x1,float y1,float z1,float value, float offset)
{
   /*将坐标拷贝到本地变量，否则影响下一个视图的标注*/
   u0=x0;v0=y0;w0=z0;u1=x1;v1=y1;w1=z1;

   /*将三维坐标转换成对应的平面坐标*/
   if(i==0){
      Translate_3D_To_2D(view_h,View_Scale,View1_X,View1_Y,u0,v0,w0);
      Translate_3D_To_2D(view_h,View_Scale,View1_X,View1_Y,u1,v1,w1);
   }
   else if(i==1){
      Translate_3D_To_2D(view_h,View_Scale,View2_X,View2_Y,u0,v0,w0);
      Translate_3D_To_2D(view_h,View_Scale,View2_X,View2_Y,u1,v1,w1);
   }
   else if(i==2){
      Translate_3D_To_2D(view_h,View_Scale,View3_X,View3_Y,u0,v0,w0);
      Translate_3D_To_2D(view_h,View_Scale,View3_X,View3_Y,u1,v1,w1);
   }

   /*如果零件尺寸在视图上的投影长度过小，则忽略这个标注*/
   distance = SQRT((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1));
   if(distance<1){
      return(0);
   }

	if(ActivateDeActivate2D(view_h, 1) < 0){
		msg = "无法启动尺寸标注";
		U_MESSAGEBOX(msg, U_MB_ERROR, U_MB_OK, U_OK);
		return(-1);
	}

   /*将坐标拷贝到本地变量，否则影响下一个视图的标注*/
   u0=x0;v0=y0;w0=z0;u1=x1;v1=y1;w1=z1;

	PM_VIEW_TRANSFORMATION(view_h,1,u0,v0,w0);
	PM_VIEW_TRANSFORMATION(view_h,1,u1,v1,w1);

   /*计算标注值*/
   dim_text = "";
   S_PRINTF(dim_text,"%d",value);

   add_2p_dimension(view_h, 7, u0, v0, w0, u1, v1, w1, 2, offset, 2.5, 2, 2, 1, dim_text, 4);

   return(0);
}

/*Rainbow管端连接表*/
draw_connection_table_rainbow()
{
	style_name = "";
	drafting_style = GetFirstDraftingStyle(style_name);
    dw = PM_START_PAGE_ANNOTATION(style_name);
    DW_ACTIVATEVIEW(dw);

    InitDrawingSettings();

	DW_COLOR(Connection_Table_Text_Colour);
	DW_LTYPE(Connection_Table_Line_Type,Connection_Table_Pattern_Length);
    /*写连接表内容*/
	DW_TATTR(0.0,0.0,4);

	text = get_2darray(Connection_Table,0,1);
	x = 108;
	y = 34.5;
	DW_TEXT(x, y, text);

	text = get_2darray(Connection_Table,0,2);
	x = 128;
	y = 34.5;
	DW_TEXT(x, y, text);

	text = get_2darray(Connection_Table,0,3);
	x = 145.5;
	y = 34.5;
	DW_TEXT(x, y, text);

	text = get_2darray(Connection_Table,0,4);
	x = 167;
	y = 34.5;
	DW_TEXT(x, y, text);

	text = get_2darray(Connection_Table,1,1);
	x = 108;
	y = 29.5;
	DW_TEXT(x, y, text);

	text = get_2darray(Connection_Table,1,2);
	x = 128;
	y = 29.5;
	DW_TEXT(x, y, text);

	text = get_2darray(Connection_Table,1,3);
	x = 145.5;
	y = 29.5;
	DW_TEXT(x, y, text);

	text = get_2darray(Connection_Table,1,4);
	x = 167;
	y = 29.5;
	DW_TEXT(x, y, text);

   PM_TERMINATE_PAGE_ANNOTATION(1);
}

/*一般用途的管端连接表*/
draw_connection_table()
{
	style_name = "";
	drafting_style = GetFirstDraftingStyle(style_name);
    dw = PM_START_PAGE_ANNOTATION(style_name);
    DW_ACTIVATEVIEW(dw);

    InitDrawingSettings();

	DW_COLOR(Connection_Table_Line_Colour);
	DW_LTYPE(Connection_Table_Line_Type,Connection_Table_Pattern_Length);

	/*绘制横线*/
	line_number = Connection_Label_Number + 3;
	if(Connection_Table_Direction == "Down" ){
        for(i=0;i<line_number;i=i+1;){
            x1 = Connection_Table_Orign_X;
	        x2 = Connection_Table_Orign_X + Connection_Table_W;
	        y1 = Connection_Table_Orign_Y - i * Connection_Table_H;
	        y2 = y1;
	        DW_POLY(x1,y1,x2,y2);
	    }
    }
    else{
	    for(i=0;i<line_number;i=i+1;){
	        x1 = Connection_Table_Orign_X;
	        x2 = Connection_Table_Orign_X + Connection_Table_W;
	        y1 = Connection_Table_Orign_Y + i * Connection_Table_H;
	        y2 = y1;
	        DW_POLY(x1,y1,x2,y2);
	    }
    }
	/*绘制竖线*/
	line_number = Connection_Label_Number + 2;
	h1 = line_number * Connection_Table_H;
	h2 = (line_number - 1)* Connection_Table_H;
	if(Connection_Table_Direction == "Down" ){
	    x1 = Connection_Table_Orign_X;
	    y1 = Connection_Table_Orign_Y;
	    x2 = x1;
	    y2 = y1 - h1;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Connection_Table_Column1_W;
	    y1 = Connection_Table_Orign_Y - Connection_Table_H;
	    x2 = x1;
	    y2 = y1 - h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Connection_Table_Column2_W;
	    y1 = Connection_Table_Orign_Y - Connection_Table_H;
	    x2 = x1;
	    y2 = y1 - h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Connection_Table_Column3_W;
	    y1 = Connection_Table_Orign_Y - Connection_Table_H;
	    x2 = x1;
	    y2 = y1 - h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Connection_Table_Column4_W;
	    y1 = Connection_Table_Orign_Y - Connection_Table_H;
	    x2 = x1;
	    y2 = y1 - h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Connection_Table_Column5_W;
	    y1 = Connection_Table_Orign_Y;
	    x2 = x1;
	    y2 = y1 - h1;
	    DW_POLY(x1,y1,x2,y2);
    }
    else{
	    x1 = Connection_Table_Orign_X;
	    y1 = Connection_Table_Orign_Y;
	    x2 = x1;
	    y2 = y1 + h1;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Connection_Table_Column1_W;
	    y1 = Connection_Table_Orign_Y + Connection_Table_H;
	    x2 = x1;
	    y2 = y1 + h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Connection_Table_Column2_W;
	    y1 = Connection_Table_Orign_Y + Connection_Table_H;
	    x2 = x1;
	    y2 = y1 + h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Connection_Table_Column3_W;
	    y1 = Connection_Table_Orign_Y + Connection_Table_H;
	    x2 = x1;
	    y2 = y1 + h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Connection_Table_Column4_W;
	    y1 = Connection_Table_Orign_Y + Connection_Table_H;
	    x2 = x1;
	    y2 = y1 + h2;
	    DW_POLY(x1,y1,x2,y2);
	    x1 = x1 + Connection_Table_Column5_W;
	    y1 = Connection_Table_Orign_Y;
	    x2 = x1;
	    y2 = y1 + h1;
	    DW_POLY(x1,y1,x2,y2);
    }
    /*写标题*/
    DW_COLOR(Connection_Table_Text_Colour);
	DW_TSIZE(Connection_Table_Text_Height);
	DW_TATTR(0.0,0.0,5);
	if(Connection_Table_Direction == "Down" ){
        x = Connection_Table_Orign_X + Connection_Table_W / 2;
        y = Connection_Table_Orign_Y - Connection_Table_H / 2;
        text = "管端坐标/连接件表";
        DW_TEXT(x, y, text);
        
        x = Connection_Table_Orign_X + Connection_Table_Column1_W / 2;
        y = Connection_Table_Orign_Y - Connection_Table_H * 1.5;
        text = "编号";
        DW_TEXT(x, y, text);
        
        x = x + Connection_Table_Column1_W / 2 + Connection_Table_Column2_W / 2;
        y = Connection_Table_Orign_Y - Connection_Table_H * 1.5;
        text = "X坐标";
        DW_TEXT(x, y, text);
        
        x = x + Connection_Table_Column2_W / 2 + Connection_Table_Column3_W / 2;
        y = Connection_Table_Orign_Y - Connection_Table_H * 1.5;
        text = "Y坐标";
        DW_TEXT(x, y, text);
        
        x = x + Connection_Table_Column3_W / 2 + Connection_Table_Column4_W / 2;
        y = Connection_Table_Orign_Y - Connection_Table_H * 1.5;
        text = "Z坐标";
        DW_TEXT(x, y, text);
        
        x = x + Connection_Table_Column4_W / 2 + Connection_Table_Column5_W / 2;
        y = Connection_Table_Orign_Y - Connection_Table_H * 1.5;
        text = "连接管号/对象";
        DW_TEXT(x, y, text);
    }
    else{
        x = Connection_Table_Orign_X + Connection_Table_W / 2;
        y = Connection_Table_Orign_Y + Connection_Table_H / 2;
        text = "管端坐标/连接件表";
        DW_TEXT(x, y, text);
        
        x = Connection_Table_Orign_X + Connection_Table_Column1_W / 2;
        y = Connection_Table_Orign_Y + Connection_Table_H * 1.5;
        text = "编号";
        DW_TEXT(x, y, text);
        
        x = x + Connection_Table_Column1_W / 2 + Connection_Table_Column2_W / 2;
        y = Connection_Table_Orign_Y + Connection_Table_H * 1.5;
        text = "X坐标";
        DW_TEXT(x, y, text);
        
        x = x + Connection_Table_Column2_W / 2 + Connection_Table_Column3_W / 2;
        y = Connection_Table_Orign_Y + Connection_Table_H * 1.5;
        text = "Y坐标";
        DW_TEXT(x, y, text);
        
        x = x + Connection_Table_Column3_W / 2 + Connection_Table_Column4_W / 2;
        y = Connection_Table_Orign_Y + Connection_Table_H * 1.5;
        text = "Z坐标";
        DW_TEXT(x, y, text);
        
        x = x + Connection_Table_Column4_W / 2 + Connection_Table_Column5_W / 2;
        y = Connection_Table_Orign_Y + Connection_Table_H * 1.5;
        text = "连接管号/对象";
        DW_TEXT(x, y, text);
    }
    /*写连接表内容*/
	DW_TATTR(0.0,0.0,4);
    for(i=0;i<Connection_Label_Number;i=i+1;){
	    if(Connection_Table_Direction == "Down" ){
            x = Connection_Table_Orign_X + 1;
            y = Connection_Table_Orign_Y - Connection_Table_H * (i + 2.5);
            text = get_2darray(Connection_Table,i,0);
            DW_TEXT(x, y, text);
            
            x = x + Connection_Table_Column1_W;
            y = Connection_Table_Orign_Y - Connection_Table_H * (i + 2.5);
            text = get_2darray(Connection_Table,i,1);
            DW_TEXT(x, y, text);
            
            x = x + Connection_Table_Column2_W;
            y = Connection_Table_Orign_Y - Connection_Table_H * (i + 2.5);
            text = get_2darray(Connection_Table,i,2);
            DW_TEXT(x, y, text);
            
            x = x + Connection_Table_Column3_W;
            y = Connection_Table_Orign_Y - Connection_Table_H * (i + 2.5);
            text = get_2darray(Connection_Table,i,3);
            DW_TEXT(x, y, text);
            
            x = x + Connection_Table_Column4_W;
            y = Connection_Table_Orign_Y - Connection_Table_H * (i + 2.5);
            text = get_2darray(Connection_Table,i,4);
            DW_TEXT(x, y, text);
	    }
	    else{
            x = Connection_Table_Orign_X + 1;
            y = Connection_Table_Orign_Y + Connection_Table_H * (i + 2.5);
            text = get_2darray(Connection_Table,i,0);
            DW_TEXT(x, y, text);
            
            x = x + Connection_Table_Column1_W;
            y = Connection_Table_Orign_Y + Connection_Table_H * (i + 2.5);
            text = get_2darray(Connection_Table,i,1);
            DW_TEXT(x, y, text);
            
            x = x + Connection_Table_Column2_W;
            y = Connection_Table_Orign_Y + Connection_Table_H * (i + 2.5);
            text = get_2darray(Connection_Table,i,2);
            DW_TEXT(x, y, text);
            
            x = x + Connection_Table_Column3_W;
            y = Connection_Table_Orign_Y + Connection_Table_H * (i + 2.5);
            text = get_2darray(Connection_Table,i,3);
            DW_TEXT(x, y, text);
            
            x = x + Connection_Table_Column4_W;
            y = Connection_Table_Orign_Y + Connection_Table_H * (i + 2.5);
            text = get_2darray(Connection_Table,i,4);
            DW_TEXT(x, y, text);
	    }
    }

    PM_TERMINATE_PAGE_ANNOTATION(1);
}


draw_check_table()
{

	style_name = "";
	drafting_style = GetFirstDraftingStyle(style_name);
   dw = PM_START_PAGE_ANNOTATION(style_name);
   DW_ACTIVATEVIEW(dw);

   InitDrawingSettings();

	DW_COLOR(Check_Table_Line_Colour);
	DW_LTYPE(Check_Table_Line_Type,Check_Table_Pattern_Length);

	/*绘制横线*/
	line_number = Check_Node_Number + 3;
	if(Check_Table_Direction == "Down" ){
	   for(i=0;i<line_number;i=i+1;){
	      x1 = Check_Table_Orign_X;
	      x2 = Check_Table_Orign_X + Check_Table_W;
	      y1 = Check_Table_Orign_Y - i * Check_Table_H;
	      y2 = y1;
	      DW_POLY(x1,y1,x2,y2);
	   }
   }
   else{
	   for(i=0;i<line_number;i=i+1;){
	      x1 = Check_Table_Orign_X;
	      x2 = Check_Table_Orign_X + Check_Table_W;
	      y1 = Check_Table_Orign_Y + i * Check_Table_H;
	      y2 = y1;
	      DW_POLY(x1,y1,x2,y2);
	   }
   }
	/*绘制竖线*/
	line_number = Check_Node_Number + 2;
	h1 = line_number * Check_Table_H;
	h2 = (line_number - 1)* Check_Table_H;
	if(Check_Table_Direction == "Down" ){
	   x1 = Check_Table_Orign_X;
	   y1 = Check_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 - h1;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Check_Table_Column1_W;
	   y1 = Check_Table_Orign_Y - Check_Table_H;
	   x2 = x1;
	   y2 = y1 - h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Check_Table_Column2_W;
	   y1 = Check_Table_Orign_Y - Check_Table_H;
	   x2 = x1;
	   y2 = y1 - h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Check_Table_Column3_W;
	   y1 = Check_Table_Orign_Y - Check_Table_H;
	   x2 = x1;
	   y2 = y1 - h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Check_Table_Column4_W;
	   y1 = Check_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 - h1;
	   DW_POLY(x1,y1,x2,y2);
   }
   else{
	   x1 = Check_Table_Orign_X;
	   y1 = Check_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 + h1;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Check_Table_Column1_W;
	   y1 = Check_Table_Orign_Y + Check_Table_H;
	   x2 = x1;
	   y2 = y1 + h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Check_Table_Column2_W;
	   y1 = Check_Table_Orign_Y + Check_Table_H;
	   x2 = x1;
	   y2 = y1 + h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Check_Table_Column3_W;
	   y1 = Check_Table_Orign_Y + Check_Table_H;
	   x2 = x1;
	   y2 = y1 + h2;
	   DW_POLY(x1,y1,x2,y2);
	   x1 = x1 + Check_Table_Column4_W;
	   y1 = Check_Table_Orign_Y;
	   x2 = x1;
	   y2 = y1 + h1;
	   DW_POLY(x1,y1,x2,y2);
   }
   /*写标题*/
   DW_COLOR(Check_Table_Text_Colour);
	DW_TSIZE(Check_Table_Text_Height);
	DW_TATTR(0.0,0.0,5);
	if(Check_Table_Direction == "Down" ){
      x = Check_Table_Orign_X + Check_Table_W / 2;
      y = Check_Table_Orign_Y - Check_Table_H / 2;
      text = "校管表";
      DW_TEXT(x, y, text);

      x = Check_Table_Orign_X + Check_Table_Column1_W / 2;
      y = Check_Table_Orign_Y - Check_Table_H * 1.5;
      text = "节点";
      DW_TEXT(x, y, text);

      x = x + Check_Table_Column1_W / 2 + Check_Table_Column2_W / 2;
      y = Check_Table_Orign_Y - Check_Table_H * 1.5;
      text = "X";
      DW_TEXT(x, y, text);

      x = x + Check_Table_Column2_W / 2 + Check_Table_Column3_W / 2;
      y = Check_Table_Orign_Y - Check_Table_H * 1.5;
      text = "Y";
      DW_TEXT(x, y, text);

      x = x + Check_Table_Column3_W / 2 + Check_Table_Column4_W / 2;
      y = Check_Table_Orign_Y - Check_Table_H * 1.5;
      text = "Z";
      DW_TEXT(x, y, text);
   }
   else{
      x = Check_Table_Orign_X + Check_Table_W / 2;
      y = Check_Table_Orign_Y + Check_Table_H / 2;
      text = "校管表";
      DW_TEXT(x, y, text);

      x = Check_Table_Orign_X + Check_Table_Column1_W / 2;
      y = Check_Table_Orign_Y + Check_Table_H * 1.5;
      text = "节点";
      DW_TEXT(x, y, text);

      x = x + Check_Table_Column1_W / 2 + Check_Table_Column2_W / 2;
      y = Check_Table_Orign_Y + Check_Table_H * 1.5;
      text = "X";
      DW_TEXT(x, y, text);

      x = x + Check_Table_Column2_W / 2 + Check_Table_Column3_W / 2;
      y = Check_Table_Orign_Y + Check_Table_H * 1.5;
      text = "Y";
      DW_TEXT(x, y, text);

      x = x + Check_Table_Column3_W / 2 + Check_Table_Column4_W / 2;
      y = Check_Table_Orign_Y + Check_Table_H * 1.5;
      text = "Z";
      DW_TEXT(x, y, text);
   }
   /*写校管表内容*/
	DW_TATTR(0.0,0.0,4);
   for(i=0;i<Check_Node_Number;i=i+1;){
	   if(Check_Table_Direction == "Down" ){
         x = Check_Table_Orign_X + 1;
         y = Check_Table_Orign_Y - Check_Table_H * (i + 2.5);
         text = get_2darray(Check_Node_Table,i,0);
         DW_TEXT(x, y, text);

         x = x + Check_Table_Column1_W;
         y = Check_Table_Orign_Y - Check_Table_H * (i + 2.5);
         text = get_2darray(Check_Node_Table,i,1);
         DW_TEXT(x, y, text);

         x = x + Check_Table_Column2_W;
         y = Check_Table_Orign_Y - Check_Table_H * (i + 2.5);
         text = get_2darray(Check_Node_Table,i,2);
         DW_TEXT(x, y, text);

         x = x + Check_Table_Column3_W;
         y = Check_Table_Orign_Y - Check_Table_H * (i + 2.5);
         text = get_2darray(Check_Node_Table,i,3);
         DW_TEXT(x, y, text);
	   }
	   else{
         x = Check_Table_Orign_X + 1;
         y = Check_Table_Orign_Y - Check_Table_H * (i + 2.5);
         text = get_2darray(Check_Node_Table,i,0);
         DW_TEXT(x, y, text);

         x = x + Check_Table_Column1_W;
         y = Check_Table_Orign_Y - Check_Table_H * (i + 2.5);
         text = get_2darray(Check_Node_Table,i,1);
         DW_TEXT(x, y, text);

         x = x + Check_Table_Column2_W;
         y = Check_Table_Orign_Y - Check_Table_H * (i + 2.5);
         text = get_2darray(Check_Node_Table,i,2);
         DW_TEXT(x, y, text);

         x = x + Check_Table_Column3_W;
         y = Check_Table_Orign_Y - Check_Table_H * (i + 2.5);
         text = get_2darray(Check_Node_Table,i,3);
         DW_TEXT(x, y, text);
	   }
   }

   PM_TERMINATE_PAGE_ANNOTATION(1);
}

main()
{
    if(!license()){
        return(0);
    }
    init();
	mainform  = create_top_frame();
	Panel_upperpart = create_panel_upperpart(mainform);
	DisplayGrid  = create_grid(mainform);
	command = create_command(mainform);
	set_default();

	MainWindow = mainform;

	W_MAP_FRAME(mainform);
	W_RUN_FRAME(mainform);
	W_UNMAP_FRAME(mainform);
	W_DESTROY_FRAME(mainform);
}

exit()
{
   current_drawing = PM_GET_ACTIVE_DRW_NAME();
	if(current_drawing != ""){
	   PM_SAVE_ACTIVE_DRW();
	   PM_CHECK_IN_ACTIVE_DRW();
	   PM_CLOSE_ACTIVE_DRW();
	}
	/* 将已经加亮的模型恢复原来的颜色 */
	model_number = PM_NR_MEMBERS_IN_SET(High_Light_List);
	for (i = 0 ; i < model_number; i = i + 1){
		model = PM_GET_MEMBER_IN_SET(High_Light_List,i);
		Highlight_Object(model,FALSE);
	}
	/* 释放相关资源 */
	PM_FREE_SET(Object_List);
	PM_FREE_SET(High_Light_List);
	PM_FREE_SET(Selected_Objects);
	PM_FREE_SET(Cur_Spool_Model_Set);
	PM_FREE_SET(Double_Plate_Set);
	A_FREE(Sketch_Tag_Array);
	A_FREE(Column_Description_Array);
	A_FREE(View_Handles);
	A_FREE(View_Names);
	A_FREE(Bending_Action_Number);
	A_FREE(Access_List);
	free_2darray(Object_Info);
	free_2darray(View_Info);
	free_2darray(Mto_Table);
	free_2darray(Mto_Label_Table);
	free_2darray(Label_Table);
	free_2darray(Spool_Branch);
	free_2darray(Spool_Branch_Direction);
	free_2darray(View_Positions);
	free_2darray(Check_Node_Table);
	free_2darray(Connection_Label_Table);
	free_2darray(Connection_Table);
	free_2darray(Dim_Table);
	free_2darray(Spool_Parts);
	free_2darray(Bending_Table_Head);
	free_2darray(Bending_Actions);
	free_2darray(Assembly_Table);
	free_2darray(Assembly_Label_Table);
}

/*判断一个pipe上是否有支管*/
have_branch(pipe)
{
   part_number = PM_NR_PARTS_IN_PIPE(pipe);
   if(part_number<=0){
      return(0);
   }
   else{
      conn_number = PM_GET_NR_OF_CONPNTS(pipe);
      if(conn_number>2){
         return(1);
      }   
      else{
         return(0);
      } 
   }
   return(0);
}

/* 获取pipe上指定零件的节点坐标 */
get_part_node_coord(handle pipe, int part_sequence, int node_id,float x, float y,float z)
{
   objgeom = PM_CREATE_PNTSET(10);
   PM_GET_OBJECT_GEOM(pipe, part_sequence, objgeom);
   PM_GET_PNT(objgeom, node_id, x, y, z);
   PM_FREE_PNTSET(objgeom);
   return(0);
}

/*
	Return values:
	int		-1		Part doesn't belong to bent pipe
	int		0		Belongs to bent pipe, but part is not start or end
	int		1		Part is start of bent pipe
	int		2		Part is end of bent pipe
	int		3		Part is start and end of bent pipe
*/
get_type_of_bent_part(handle obj, int nth_part)
{
	if(!is_pipe(obj, nth_part))
		return(-1);
	
	nr_parts = PM_NR_PARTS_IN_PIPE(obj);
	this_bending = pipe_is_bending(obj, nth_part);
	prev_bending = FALSE;
	next_bending = FALSE;
	if(nth_part > 1)
		prev_bending = pipe_is_bending(obj, nth_part - 1);
	if(nth_part < nr_parts)
		next_bending = pipe_is_bending(obj, nth_part + 1);
		
	if(!this_bending & !prev_bending & !next_bending)
		return(-1);
	
	if(pipe_is_bending(obj, nth_part)){
		if(nr_parts == 1){
			return(3);
		}
		else if(nth_part == 1){
			return(1);
		}
		else if(nth_part == nr_parts){
			return(2);
		}
		else {
			part_id = PM_GET_OBJDATA(obj, nth_part, MMT_TAG_PARTID);
			prev_part_id = PM_GET_OBJDATA(obj, nth_part - 1, MMT_TAG_PARTID);
			next_part_id = PM_GET_OBJDATA(obj, nth_part + 1, MMT_TAG_PARTID);
			if(part_id == next_part_id){
				if(part_id == prev_part_id){
					return(0);
				}
				else {
					return(1);
				}
			}
			else if(part_id == prev_part_id){
				return(2);
			}
			else {
				return(3);
			}
		}
	}
	else {
		if(nr_parts == 1){
			return(-1);
		}
		else if(nth_part == 1){
			part_id = PM_GET_OBJDATA(obj, nth_part, MMT_TAG_PARTID);
			next_part_id = PM_GET_OBJDATA(obj, nth_part + 1, MMT_TAG_PARTID);
			if(part_id == next_part_id & pipe_is_bending(obj, nth_part + 1)){
				return(1);
			}
			else {
				return(-1);
			}
		}
		else if(nth_part == nr_parts){
			part_id = PM_GET_OBJDATA(obj, nth_part, MMT_TAG_PARTID);
			prev_part_id = PM_GET_OBJDATA(obj, nth_part - 1, MMT_TAG_PARTID);
			if(part_id == prev_part_id & pipe_is_bending(obj, nth_part - 1)){
				return(2);
			}
			else {
				return(-1);
			}			
		}
		else {
			part_id = PM_GET_OBJDATA(obj, nth_part, MMT_TAG_PARTID);
			prev_part_id = PM_GET_OBJDATA(obj, nth_part - 1, MMT_TAG_PARTID);
			next_part_id = PM_GET_OBJDATA(obj, nth_part + 1, MMT_TAG_PARTID);
			if(part_id == prev_part_id & pipe_is_bending(obj, nth_part - 1)){
				if(part_id == next_part_id & pipe_is_bending(obj, nth_part + 1)){
					return(0);
				}
				else {
					return(2);
				}
			}
			else if(part_id == next_part_id & pipe_is_bending(obj, nth_part + 1)){
				return(1);
			}			
		}
	}
	
	return(-1);
}

is_pipe(handle obj, int nth_part)
{
	part_id = PM_GET_OBJDATA(obj, nth_part, MMT_TAG_PARTID);
	geo_type = DM_PARTID_DATA(part_id, DM_COSA_GEOTYPE);
	if(geo_type == "1") return(TRUE);
	
	return(FALSE);
}

pipe_is_bending(handle obj, int nth_part)
{
	mth = PM_GET_OBJDATA(obj, nth_part, MMT_TAG_METHOD);
	if(!ISSTRING(mth)) return(FALSE);
	
	if(HEAD(mth, 2) == "$B") return(TRUE);
	
	return(FALSE);
}

is_bending(handle obj, int nth_part)
{
	if(!is_pipe(obj, nth_part)) return(FALSE);
	
	mth = PM_GET_OBJDATA(obj, nth_part, MMT_TAG_METHOD);
	if(!ISSTRING(mth)) return(FALSE);
	
	if(HEAD(mth, 2) == "$B") return(TRUE);
	
	return(FALSE);
}

get_bending_machine_name(handle obj, int nth_part)
{
	pline_name = PM_GET_OBJDATA(obj, 0, "pli");
	if(!ISSTRING(pline_name))
		return(-1);
	pline_h = PM_FIND_BY_NAME(pline_name);
	
	spec1 = PM_GET_OBJDATA(pline_h, 1, "ps1");
	if (!ISSTRING(spec1))
		spec1 = "";
	spec2 = PM_GET_OBJDATA(pline_h, 1, "ps2");
	if (!ISSTRING(spec2))
		spec2 = "";
	spec3 = PM_GET_OBJDATA(pline_h, 1, "ps3");
	if (!ISSTRING(spec3))
		spec3 = "";
	
	mth = PM_GET_OBJDATA(obj, nth_part, "mth");
	if (!ISSTRING(mth))
		return(-1);
	if (mth == "$B") {
		spc = PM_GET_OBJDATA(obj, nth_part, "spc");
		spec_nr = 0;
		if 		(spc == spec1) spec_nr = 1;
		else if (spc == spec2) spec_nr = 2;
		else if (spc == spec3) spec_nr = 3;
		bend_dimtbl = "";
		if (spec_nr > 0) {
			sco = PM_GET_OBJDATA(obj, nth_part, "sco");
			pid = PM_GET_OBJDATA(obj, nth_part, "pid");
			PM_ACT_PIPELINE(pline_name, spec_nr);
			ns = DM_PARTID_NTH_DIM(pid, DM_Q_NS, 1);
			specdef = PM_PID_FROMSPEC(sco, ns, 0);
			if ((HEAD(specdef, 2) == "$B") & (STRLEN(specdef) > 3))
				bend_dimtbl = SUBSTRING(specdef, 2);
		}
	}
	
	bend_dimtbl = SUBSTRING(bend_dimtbl,1);
	bend_dimtbl = STRINGTERM(bend_dimtbl,"-");
	
	COS_READ_OBJECT(bend_dimtbl);
	attrs = COS_GET_OBJECT_ATTRIBUTES(bend_dimtbl);
	name = DM_GET_TAGVAL(attrs, DM_COSA_DSC);
	if(ISSTRING(name)){
	   name = STRINGTERM(name,"-");
	   return(name);
	}
	else{
	   return(-1);
	}		
	return(-1);
}

get_min_between_bendings(handle obj, int nth_part)
{
	part_id = PM_GET_OBJDATA(obj, nth_part, "pid");
	ns = 1.0 * DM_PARTID_DATA(part_id, "D01");
	dt_name = get_bend_mach_dimtbl(obj, nth_part);
	if(ISINT(dt_name))
		return(0);
	line_no = DM_DIMTBL_MATCHLINE(dt_name, ns, 0, 1);
	
	/* Min between bendings = 6th length */
	min_between = DM_DIMTBL_NTH_DIM(dt_name, line_no, 3, 6);
	return(min_between);
}

get_min_after_last_bending(handle obj, int nth_part)
{
	part_id = PM_GET_OBJDATA(obj, nth_part, "pid");
	ns = 1.0 * DM_PARTID_DATA(part_id, "D01");
	dt_name = get_bend_mach_dimtbl(obj, nth_part);
	if(ISINT(dt_name))
		return(0);
	line_no = DM_DIMTBL_MATCHLINE(dt_name, ns, 0, 1);
	
	/* Min after last bending without flanges = 5th length */
	min_after = DM_DIMTBL_NTH_DIM(dt_name, line_no, 3, 5);
	return(min_after);
}

get_min_before_first_bending(handle obj, int nth_part)
{
	part_id = PM_GET_OBJDATA(obj, nth_part, "pid");
	ns = 1.0 * DM_PARTID_DATA(part_id, "D01");
	dt_name = get_bend_mach_dimtbl(obj, nth_part);
	if(ISINT(dt_name))
		return(0);
	line_no = DM_DIMTBL_MATCHLINE(dt_name, ns, 0, 1);
	
	/* Min before 1st bending without flanges = 4th length */
	min_before = DM_DIMTBL_NTH_DIM(dt_name, line_no, 3, 4);
	return(min_before);
}

/*
	Get name of the dimension table of bending machine.
	Note nth_part of given object must be bending. For other pieces
	of bent pipe this must be queried from the previous or next part.
	
	Return values:
	string	name	Name of dimension table and
					empty string if free bending
	int		-1		If object is not bending
*/
get_bend_mach_dimtbl(handle obj, int nth_part)
{
	pline_name = PM_GET_OBJDATA(obj, 0, "pli");
	if(!ISSTRING(pline_name))
		return(-1);
	pline_h = PM_FIND_BY_NAME(pline_name);
	
	spec1 = PM_GET_OBJDATA(pline_h, 1, "ps1");
	if (!ISSTRING(spec1))
		spec1 = "";
	spec2 = PM_GET_OBJDATA(pline_h, 1, "ps2");
	if (!ISSTRING(spec2))
		spec2 = "";
	spec3 = PM_GET_OBJDATA(pline_h, 1, "ps3");
	if (!ISSTRING(spec3))
		spec3 = "";
	
	mth = PM_GET_OBJDATA(obj, nth_part, "mth");
	if (!ISSTRING(mth))
		return(-1);
	if (mth == "$B") {
		spc = PM_GET_OBJDATA(obj, nth_part, "spc");
		spec_nr = 0;
		if 		(spc == spec1) spec_nr = 1;
		else if (spc == spec2) spec_nr = 2;
		else if (spc == spec3) spec_nr = 3;
		bend_dimtbl = "";
		if (spec_nr > 0) {
			sco = PM_GET_OBJDATA(obj, nth_part, "sco");
			pid = PM_GET_OBJDATA(obj, nth_part, "pid");
			PM_ACT_PIPELINE(pline_name, spec_nr);
			ns = DM_PARTID_NTH_DIM(pid, DM_Q_NS, 1);
			specdef = PM_PID_FROMSPEC(sco, ns, 0);
			if ((HEAD(specdef, 2) == "$B") & (STRLEN(specdef) > 3))
				bend_dimtbl = SUBSTRING(specdef, 2);
		}
	}
	
	return(bend_dimtbl);
}

calculate_rotation(float x0, float y0, float z0, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3)
{
	/* Transform center segment 1-2 to X-axis, point 1 to origin */
	dx = x2 - x1;
	dy = y2 - y1;
	dz = z2 - z1;
	VEC_UNITV(dx, dy, dz);
	tm = PM_CREATE_TMAT(3, x1, y1, z1, dx, dy, dz, 0, 0, 0);
	inv_tm 	= PM_INVERSE_TMAT(tm);
	
	/* Transform start and end segments by using previous matrix */
	xs = x0;	ys = y0;	zs = z0;
	xe = x3;	ye = y3;	ze = z3;
	TRF_POINT(inv_tm, xs, ys, zs);
	TRF_POINT(inv_tm, xe, ye, ze);
	
	/* Turn line 1-0 to Y-direction */
	xs = 0.0;
	xe = 0.0;
	VEC_UNITV(xs, ys, zs);
	VEC_UNITV(xe, ye, ze);
	rotate_tm = PM_CREATE_TMAT(1, 0, 0, 0, 1, 0, 0, xs, ys, zs);
	inv_rotate_tm = PM_INVERSE_TMAT(rotate_tm);
	TRF_POINT(inv_rotate_tm, xe, ye, ze);
	
	angle = ASIN(ze);
	if(ye < 0)
		angle = 180 - angle;
		
	if(angle >= 180)
		angle = angle - 360;
	
	return(-angle);
}

/* 如果弯管两端都带有余量或者有中间余量的话，则这个算法有可能不正确 */
get_piece_cutting_length(pipe,nth_part)
{
	length = 1.0 * PM_GET_OBJDATA(pipe,nth_part,MMT_TAG_LENGTH);
	bpl = 1.0 * PM_GET_OBJDATA(pipe,nth_part,MMT_TAG_BENT_PIPE_LEN);
	extra_length = get_extra_length(pipe);
	/*不带现场管余量*/
	if(extra_length == 0.0){
		return(length);
	}
	/*带现场管余量*/
	else{
		/*弯管余量大于现场管余量*/
		if(length - bpl > extra_length){
			length = length;
		}
		/*弯管余量小于或等于现场管余量*/
		else{
			length = bpl + extra_length;
		}   
	}
	return(length);
}

get_extra_length(pipe)
{
	extra_length = 0.0;
	part_number = PM_NR_PARTS_IN_PIPE(pipe);
	for(k=0;k<part_number;k=k+1;){
		part_sequence = k+1;
		part_id = PM_GET_OBJDATA(pipe, part_sequence, "pid");
		gty = DM_PARTID_DATA(part_id,"GT");
		if(gty == "1"){
			extra = PM_GET_OBJDATA(pipe, part_sequence, "el1");
			if(!ISINT(extra)){					
				extra_length = extra_length + extra;
			}
			extra = PM_GET_OBJDATA(pipe, part_sequence, "el2");
			if(!ISINT(extra)){					
				extra_length = extra_length + extra;
			}										
		}				
	}
	return(extra_length);
}

get_piece_final_length(pipe,nth_part)
{
   length   = PM_GET_OBJDATA(pipe,nth_part,MMT_TAG_BENT_PIPE_LEN);
   return(String_To_Float(length));
}

get_insulation_material(spool)
{  
    return(0);
}

/*
	Get coordinates of start point of branch.
	
	Start point is intersection of centerlines of main pipe and branch pipe when:
	1. Branching component is DM_GT_TEE, DM_GT_CROSS, DM_GT_LATERAL or DM_GT_YPIECE.
	2. Main component is DM_GT_PIPE or DM_GT_2P and branch component is DM_GT_PIPE or
	   DM_GT_2P
	   
	Start point is branch point projected (perpendicular) to the center line of main
	pipe:
	1. Main component is DM_GT_PIPE or DM_GT_2P and branch component is not DM_GT_PIPE
	   or DM_GT_2P
	
	Start point is same as branch point in all other cases.
*/
get_coordinates_of_branch_start_point(handle mother_obj, int mother_nod, float x, float y, float z)
{
	obt = PM_GET_OBJDATA(mother_obj, 0, MMT_TAG_OBJTYPE);
	if(obt == MMT_OBT_STANDC){
		pid = PM_GET_OBJDATA(mother_obj, 0, MMT_TAG_PARTID);
		gt = DM_PARTID_DATA(pid, DM_COSA_GEOTYPE);
		if(gt == "7" | gt == "9" | gt == "13"){
			x = 1.0 * PM_GET_CONPNT_DATA(mother_obj, 4, "x");
			y = 1.0 * PM_GET_CONPNT_DATA(mother_obj, 4, "y");
			z = 1.0 * PM_GET_CONPNT_DATA(mother_obj, 4, "z");
		}
		else if(gt == "8"){
			x = 1.0 * PM_GET_CONPNT_DATA(mother_obj, 5, "x");
			y = 1.0 * PM_GET_CONPNT_DATA(mother_obj, 5, "y");
			z = 1.0 * PM_GET_CONPNT_DATA(mother_obj, 5, "z");
		}
	}
	else
		transform_branch_surface_point_to_CL(mother_obj, mother_nod, x, y, z);
	return(0);
}

transform_branch_surface_point_to_CL(handle mother_obj, int mother_nod, float x, float y, float z)
{
	distance = 0.0;
	mother_nth_part = PM_FIND_BRANCH_IN_PIPE(mother_obj, mother_nod, distance);
	if(mother_nth_part < 0)
		return(-1);
		
	branch_nod = 0;
	branch_obj = PM_GET_CONNECTED_OBJECT(mother_obj, mother_nod, branch_nod);
	if(ISINT(branch_obj))
		return(-1);
		
	branch_nth_part = node_id_to_part_number(branch_obj, branch_nod);
	
	mother_pid = PM_GET_OBJDATA(mother_obj, mother_nth_part, MMT_TAG_PARTID);
	branch_pid = PM_GET_OBJDATA(branch_obj, branch_nth_part, MMT_TAG_PARTID);
	
	/* Branch point in case it is not possible to get CL point */
	branch_x = 1.0 * PM_GET_CONPNT_DATA(branch_obj, branch_nod, "x");
	branch_y = 1.0 * PM_GET_CONPNT_DATA(branch_obj, branch_nod, "y");
	branch_z = 1.0 * PM_GET_CONPNT_DATA(branch_obj, branch_nod, "z");
	x = branch_x;
	y = branch_y;
	z = branch_z;
	
	mother_geo_type = DM_PARTID_DATA(mother_pid, "GT");
	if(mother_geo_type != "1" & mother_geo_type != "4")
		return(-1);
		
	/* End points of mother part */
	objgeom = PM_CREATE_PNTSET(10);
	mx1 = 0.0;	my1 = 0.0;	mz1 = 0.0;
	mx2 = 0.0;	my2 = 0.0;	mz2 = 0.0;
	PM_GET_OBJECT_GEOM(mother_obj, mother_nth_part, objgeom);
	PM_GET_PNT(objgeom, 0, mx1, my1, mz1);
	PM_GET_PNT(objgeom, 1, mx2, my2, mz2);
	PM_FREE_PNTSET(objgeom);
		
	is_eccentric = FALSE;
	branch_geo_type = DM_PARTID_DATA(branch_pid, "GT");
	if(branch_geo_type == "1" | branch_geo_type == "4"){
		/* End points of branch part */
		objgeom = PM_CREATE_PNTSET(10);
		bx1 = 0.0;	by1 = 0.0;	bz1 = 0.0;
		bx2 = 0.0;	by2 = 0.0;	bz2 = 0.0;
		PM_GET_OBJECT_GEOM(branch_obj, branch_nth_part, objgeom);
		PM_GET_PNT(objgeom, 0, bx1, by1, bz1);
		PM_GET_PNT(objgeom, 1, bx2, by2, bz2);
		PM_FREE_PNTSET(objgeom);
	
		point_set = PM_CREATE_PNTSET(10);
		PM_SET_PNT(point_set, 0, mx1, my1, mz1);
		PM_SET_PNT(point_set, 1, mx2, my2, mz2);
		PM_SET_PNT(point_set, 2, bx1, by1, bz1);
		PM_SET_PNT(point_set, 3, bx2, by2, bz2);

      /*原来的程序中，如果支管中心线的两个位置坐标的顺序是按照由远到近的话，得到的结果是错误的
      **添加下面的一个段代码来修正这个错误
      */     
      chech_and_fix_point_sequence(point_set);
			
		distance = 0.0;
		angle = 0.0;
		tolerance = 0.1;
		get_nearest_points_of_two_3D_lines(point_set, distance, angle, tolerance);
		PM_GET_PNT(point_set, 4, x, y, z);		
		PM_FREE_PNTSET(point_set);
		if(distance > 2)
			is_eccentric = TRUE;
	}
	if(is_eccentric | (branch_geo_type != "1" & branch_geo_type != "4")){
		point_set = PM_CREATE_PNTSET(10);
		PM_SET_PNT(point_set, 0, mx1, my1, mz1);
		PM_SET_PNT(point_set, 1, mx2, my2, mz2);
		PM_SET_PNT(point_set, 2, branch_x, branch_y, branch_z);
		distance = 0.0;
		project_point_to_line(point_set, distance);
		PM_GET_PNT(point_set, 3, x, y, z);
		PM_FREE_PNTSET(point_set);
	}
	
	return(0);
}


chech_and_fix_point_sequence(point_set)
{
	x0 = 0.0;	y0 = 0.0;	z0 = 0.0;
	x1 = 0.0;	y1 = 0.0;	z1 = 0.0;
	x2 = 0.0;	y2 = 0.0;	z2 = 0.0;	
	x3 = 0.0;	y3 = 0.0;	z3 = 0.0;
	
	PM_GET_PNT(point_set, 0, x0, y0, z0);
	PM_GET_PNT(point_set, 1, x1, y1, z1);
	PM_GET_PNT(point_set, 2, x2, y2, z2);
	PM_GET_PNT(point_set, 3, x3, y3, z3);
	
	dx20 = x2-x0;dy20 = y2-y0;dz20 = z2-z0;
	dx21 = x2-x1;dy21 = y2-y1;dz21 = z2-z1;
	dx30 = x3-x0;dy30 = y3-y0;dz30 = z3-z0;
	dx31 = x3-x1;dy31 = y3-y1;dz31 = z3-z1;
	
   dis20 = SQRT(dx20*dx20+dy20*dy20+dz20*dz20);	
   dis21 = SQRT(dx21*dx21+dy21*dy21+dz21*dz21);	
   dis30 = SQRT(dx30*dx30+dy30*dy30+dz30*dz30);	
   dis31 = SQRT(dx31*dx31+dy31*dy31+dz31*dz31);	
   
   if((dis20+dis21)<(dis30+dis31)){
      x=x2;y=y2;z=z2;
      x2=x3;y2=y3;z2=z3;
      x3=x;y3=y;z3=z;
	   PM_SET_PNT(point_set, 2, x2, y2, z2);
	   PM_SET_PNT(point_set, 3, x3, y3, z3);   
   }	
	return(0);
}

/*
	Project point to line.
	
	Input & Output arguments:
	handle	point_set	Handle of point set, where totally 6 points
						3 input points:
						index 0	= coordinates of the 1st point of line
						index 1	= coordinates of the 2nd point of line
						index 2	= coordinates of the point to be projected
						1 output points:
						index 3	= coordinates of the projected CL point
	float	distance	Distance between nearest points
						
	Return values:
	int		0			Success
	int		-1			Failure
*/
project_point_to_line(handle point_set, float distance)
{
	ax1 = 0.0;	ay1 = 0.0;	az1 = 0.0;
	ax2 = 0.0;	ay2 = 0.0;	az2 = 0.0;
	bx = 0.0;	by = 0.0;	bz = 0.0;
	
	PM_GET_PNT(point_set, 0, ax1, ay1, az1);
	PM_GET_PNT(point_set, 1, ax2, ay2, az2);
	PM_GET_PNT(point_set, 2, bx, by, bz);
	
	/* Direction of line A */
	adx = ax2 - ax1;
	ady = ay2 - ay1;
	adz = az2 - az1;
	len1 = VEC_UNITV(adx, ady, adz);
	if(len1 < 0.1)
		return(-1);
	
	/* Transform line A point 1 to origin & along X-direction */
	orig_tm = PM_CREATE_TMAT(3, ax1, ay1, az1, adx, ady, adz, 0, 0, 0);
	inv_tm 	= PM_INVERSE_TMAT(orig_tm);
	
	TRF_POINT(inv_tm, bx, by, bz);
	
	dx = 0.0;
	dy = by;
	dz = bz;
	distance = VEC_UNITV(dx, dy, dz);
	
	/* Transform to original coordinate system */
	x = bx;		y = 0.0;	z = 0.0;
	TRF_POINT(orig_tm, x, y, z);
	PM_SET_PNT(point_set, 3, x, y, z);
	
	return(0);
}

/*
	Get nearest points of two 3D lines (line A and line B). Two points are given from
	both lines. If lines are parallel (tolerance), then point 1 of line A and nearest
	point related to this point from line B are given as nearest points. Distance
	between nearest points and deviation between lines are given as additional output
	arguments.
	
	Input & Output arguments:
	handle	point_set	Handle of point set, where totally 6 points
						4 input points:
						index 0	= coordinates of the 1st point of 1st line
						index 1	= coordinates of the 2nd point of 1st line
						index 2	= coordinates of the 1st point of 2nd line
						index 3	= coordinates of the 2nd point of 2nd line
						2 output points:
						index 4	= coordinates of the nearest point of 1st line
						index 5	= coordinates of the nearest point of 2nd line
	float	distance	Distance between nearest points
	float	angle		Deviation between lines (-180 < deviation <= 180)
	float	tolerance	Tolerance of parallelity (usually 0.1 is quite good value)
						
	Return values:
	int		0			Success
	int		-1			Failure
*/
get_nearest_points_of_two_3D_lines(handle point_set, float distance, float angle,float tolerance)
{
	ax1 = 0.0;	ay1 = 0.0;	az1 = 0.0;
	ax2 = 0.0;	ay2 = 0.0;	az2 = 0.0;
	bx1 = 0.0;	by1 = 0.0;	bz1 = 0.0;
	bx2 = 0.0;	by2 = 0.0;	bz2 = 0.0;
	
	PM_GET_PNT(point_set, 0, ax1, ay1, az1);
	PM_GET_PNT(point_set, 1, ax2, ay2, az2);
	PM_GET_PNT(point_set, 2, bx1, by1, bz1);
	PM_GET_PNT(point_set, 3, bx2, by2, bz2);
	
	/* Direction of line A */
	adx = ax2 - ax1;
	ady = ay2 - ay1;
	adz = az2 - az1;
	len1 = VEC_UNITV(adx, ady, adz);
	if(len1 < 0.1)
		return(-1);
	
	/* Direction of line B */
	bdx = bx2 - bx1;
	bdy = by2 - by1;
	bdz = bz2 - bz1;
	len2 = VEC_UNITV(bdx, bdy, bdz);
	if(len2 < 0.1)
		return(-1);
	
	/* Deviation between lines A and B */
	dot_prod = 0.0;
	VEC_DOT_PRODUCT(adx, ady, adz, bdx, bdy, bdz, dot_prod);
	angle = ACOS(dot_prod);
	
	/* Transform line A point 1 to origin & along X-direction */
	orig_tm = PM_CREATE_TMAT(3, ax1, ay1, az1, adx, ady, adz, 0, 0, 0);
	inv_tm 	= PM_INVERSE_TMAT(orig_tm);
	
	/* Transform points of line B using previous matrix	*/
	/* Don't change original points						*/
	cbx1 = bx1;	cby1 = by1;	cbz1 = bz1;
	cbx2 = bx2;	cby2 = by2;	cbz2 = bz2;
	TRF_POINT(inv_tm, cbx1, cby1, cbz1);
	TRF_POINT(inv_tm, cbx2, cby2, cbz2);
	
	/* If lines are parallel within given tolerace */
	if(fleq(angle, 0, tolerance) | fleq(angle, 180, tolerance) | fleq(angle, -180, tolerance)){
		dx = 0.0;	dy = by1;	dz = bz1;
		distance = VEC_UNITV(dx, dy, dz);
		/* Get nearest point of line B related to point 1 of line A */
		nbx = 0.0;
		nby = by1;
		nbz = bz1;
		TRF_POINT(orig_tm, nbx, nby, nbz);
		PM_SET_PNT(point_set, 4, ax1, ay1, az1);
		PM_SET_PNT(point_set, 5, nbx, nby, nbz);
		return(0);
	}
	
	/* Get angle of line B projected to YZ-plane */
	bdy = cby2 - cby1;
	bdz = cbz2 - cbz1;
	
	/* Rotate points of line B around X-axis to Y-direction */
	bdx = 0.0;
	VEC_UNITV(bdx, bdy, bdz);
	rotate_tm = PM_CREATE_TMAT(1, 0, 0, 0, 1, 0, 0, bdx, bdy, bdz);
	inv_rotate_tm = PM_INVERSE_TMAT(rotate_tm);
	TRF_POINT(inv_rotate_tm, cbx1, cby1, cbz1);
	
	distance = cbz1;
	if(distance < 0)
		distance = -distance;
		
	/* Calculate X-intersection in transformed coordinate system */
	dy_10 = cby1;
	dy_21 = cby2 - cby1;
	if(dy_21 == 0){
		U_MESSAGE("Error in transformation!");
		return(0);
	}
	dx_21 = cbx2 - cbx1;
	dx_10 = dy_10/dy_21 * dx_21;
	x = cbx1 - dx_10;
	
	/* Transform to original coordinate system */
	nax = x;	nay = 0.0;	naz = 0.0;
	nbx = x;	nby = 0.0;	nbz = cbz1;
	TRF_POINT(rotate_tm, nax, nay, naz);
	TRF_POINT(rotate_tm, nbx, nby, nbz);
	TRF_POINT(orig_tm, nax, nay, naz);
	TRF_POINT(orig_tm, nbx, nby, nbz);
	
	PM_SET_PNT(point_set, 4, nax, nay, naz);
	PM_SET_PNT(point_set, 5, nbx, nby, nbz);
	
	return(0);
}

fleq(float a, float b, float dif)
{
	if(a > b - dif & a < b + dif)
		return(TRUE);
	else
		return(FALSE);
}

node_id_to_part_number(handle obj_handle, int node_id)
{
	obt = PM_GET_OBJDATA(obj_handle, 0, MMT_TAG_OBJTYPE);
	if(obt != "3") return(0);
	
	if(node_id == 1) return(1);	
	if(node_id == 2) return(PM_NR_PARTS_IN_PIPE(obj_handle));
	
	distance = 0.0;
	nr_of_part = PM_FIND_BRANCH_IN_PIPE(obj_handle, node_id, distance);
	if(nr_of_part > 0) return(nr_of_part);
	
	return(-1);
}

/*
	Add dimension between 2 points.
	Dimension can be centered or moved to the left side or right side by using
	argument 'location'. 
	
	One argument defines if dimensioning is horizontal, vertical or diagonal.
	Anyway if dimensioning points are horizontal or vertical (tolerance 1.5mm),
	then result is horizontal or vertical dimensioning even if type is
	defined to diagonal.
	
	Distance of dimension line is from the level of highest (if distance up)
	or lowest (if distance down) point if horizontal or vertical dimensioning
	is used for points, which are diagonal.
	
	Input arguments:
	handle	view_h		Handle of opened view
	int		dim_type	Type of dimension
						1 = horizontal
						4 = vertical
						7 = diagonal
	float	u1			U-coordinate of the point on the left
	float	v1			V-coordinate of the point on the left
	float	w1			W-coordinate of the point on the left
	float	u2			U-coordinate of the point on the right
	float	v2			V-coordinate of the point on the right
	float	w2			W-coordinate of the point on the right
	int		location	Dimension on the left side (1), center (2) or right (3)
	float	distance	Distance of dimension text from the level of points
	
	Return values:
	int		0			Success
*/

add_2p_dimension(handle view_h, int dim_type, float u1, float v1, float w1,
					float u2, float v2, float w2, int location, float distance,
					float txt_h, float txt_w, float txt_s, float sym_h, string dim_text, float gap)
{
	dum = 0.0;	scale = 0.0;
	DW_GET_VIEW_PARAMS(dum, dum, dum, dum, dum, dum, scale);
	
	ddu = u2 - u1;
	ddv = v2 - v1;
	ddw = 0.0;
	
	/*如果是水平标注*/
	if(dim_type == 1){
		if(ddu < 1.0 & ddu > -1.0) return(0);
		ddv = 0.0;
	}
	/*如果是垂直标注*/
	else if(dim_type == 4){
		if(ddv < 1.0 & ddv > -1.0) return(0);
		ddu = 0.0;
	}
	
	/* dimension text */
	len = VEC_UNITV(ddu, ddv, ddw);
	dim_string = "";
	S_PRINTF(dim_string, "%d", len);
	nr_char = STRLEN(dim_text);
	dim_string_len = nr_char * txt_w + (nr_char - 1) * txt_s;
	text_move = scale * (sym_h + dim_string_len/2);
	Set_Pipe_Sketch_Dimensioning_Properties(scale);
	level = distance + scale*gap;
		
	/* the normal */
	ndu = -ddv;
	ndv = ddu;
	if(FloatsEqual(v1, v2, 0.1))
		dim_type = 1;
	else if(FloatsEqual(u1, u2, 0.1))
		dim_type = 4;
	else if(FloatsEqual(v1, v2, 1.5) & FloatsEqual(ddv/ddu, 0, 0.005))
		dim_type = 1;
	else if(FloatsEqual(u1, u2, 1.5) & FloatsEqual(ddu/ddv, 0, 0.005))
		dim_type = 4;
	DW_DIMTYPE(dim_type);
	
	if(location == 1){
		DW_DIMSYM(2, 2);
		text_u = u1 - ddu * text_move + ndu * level;
		text_v = v1 - ddv * text_move + ndv * level;
		if(dim_type == 1 & v2 > v1)
			text_v = v2 + ndv * level;
		else if(dim_type == 4 & u2 < u1)
			text_u = u2 + ndu * level;
	}
	else if(location == 2){
		text_u = (u1 + u2)/2 + ndu * level;
		text_v = (v1 + v2)/2 + ndv * level;
		if(dim_type == 1 & v2 > v1)
			text_v = v2 + ndv * level;
		else if(dim_type == 1 & v2 < v1)
			text_v = v1 + ndv * level;
		else if(dim_type == 4 & u1 > u2)
			text_u = u2 + ndu * level;
		else if(dim_type == 4 & u1 < u2)
			text_u = u1 + ndu * level;
	}
	else if(location == 3){
		DW_DIMSYM(2, 2);
		text_u = u2 + ddu * text_move + ndu * level;
		text_v = v2 + ddv * text_move + ndv * level;
		if(dim_type == 1 & v1 > v2)
			text_v = v1 + ndv * level;
		else if(dim_type == 4 & u1 < u2)
			text_u = u1 + ndu * level;
	}
	
	DW_OPNDIM();
	DW_PNT(text_u, text_v, w1);	/* dim text level		*/
	DW_PNT(u1, v1, w1);				/* first end point		*/
	if(Dimension_Mode){
		DW_DIMVAL("","", dim_text);	/* dimension value		*/
	}	
	DW_DIMVALORG(text_u, text_v);	/* dim text location	   */
	DW_PNT(u2, v2, w2);				/* second end point		*/
	DW_CLSDIM();
	
	return(0);
}

license()
{
    if(!check_license()){
        U_CONFIRM("请使用正版软件！");
        return(0);
    }
    
    if(!check_date()){
        U_CONFIRM("软件已过有效期！");
        return(0);        
    }    
    return(1);
}

check_license()
{
    return(1);
}

check_date()
{
    year = 2019;
    month = 12;
    date = 31;
    
    current_time = GET_TIME();  
    current = CNV_DATE(current_time,7);
    int current_year;
    current_year = SCAN_QUANT(3,STRINGTERM(current,"-"));
    current = SUBSTRING(SEARCH(current,"-"),1);
    int current_month;
    current_month = SCAN_QUANT(3,STRINGTERM(current,"-"));
    int current_date;
    current_date = SCAN_QUANT(3,SUBSTRING(SEARCH(current,"-"),1));
    if(current_year > year){       
        return(0);
    }
    else if(current_month > month){
        return(0);
    }
    else if(current_date > date){
        return(0);
    }
    return(1);
}